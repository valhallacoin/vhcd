codechain patchfile version 2
treehash 0d6e6f642e7f8a7dc5a2fe555bee54e26497d93e13c6e2d2e0d1fbd32f0e88d5
+ f 62f703bc5efc5c19de047f181eee68d58d4e0f84ccb8dd25b1cf9491f7405bd5 .mainnet.secpkg
utf8file 6
{
  "Name": "vhcd-mainnet",
  "Head": "106436465e1c7bfebd610379dbdedc203a9474b0644fb756377bfdd592776e16",
  "DNS": "vhcd-mainnet.valhallacoin.org"
}

+ f 1cc15e07b43617a2634131c13a18ee22e8dc668d139bd73f3222bbe136234f9e .testnet.secpkg
utf8file 6
{
  "Name": "vhcd-testnet",
  "Head": "becbed38e28a6cdd3420e280d1c328daf4c26f9c104c1bcc8b751d33d846b4e3",
  "DNS": "vhcd-testnet.valhallacoin.org"
}

- f c8425f08ffea4f3610ffcb3e6c44ec34872c907714c291a221b114a56b7a3c15 Makefile
+ f cb46d74abaa9b7e3978d337991af734f1fb8fb28bdac9a9431fcee6d81c38b24 Makefile
dmppatch 5
@@ -221,42 +221,263 @@
 or%0A%0A
-vhcd?=$(shell basename $(CURDIR))%0A
+# hack to rename vhcd when installed with secpkg either to vhcd-mainnet%0A# or vhcd-testnet, based on secpkg build directory%0Avhcd=$(shell basename $(shell dirname $(CURDIR)))%0Aifneq ($(vhcd),vhcd-mainnet)%0Aifneq ($(vhcd),vhcd-testnet)%0A  vhcd=vhcd%0Aendif%0Aendif%0A
 %0Aall
- f f546736d54a0df0f1f840fae5c5080d51f72f8801fac5dc5f090a34b5822bd6e go.mod
+ f cd162cd7b508906e6089588c42f3fc6ca3dd3c4d15a921fb1b5b99cd32ffeab9 go.mod
dmppatch 13
@@ -406,32 +406,75 @@
 red/slog v1.0.0%0A
+%09github.com/fatih/color v1.9.0 // indirect%0A
 %09github.com/fran
@@ -718,32 +718,80 @@
 1.0 // indirect%0A
+%09github.com/mattn/go-isatty v0.0.12 // indirect%0A
 %09github.com/onsi
@@ -864,64 +864,129 @@
 ect%0A
-%09golang.org/x/crypto v0.0.0-20200214034016-1d94cc7ab1c6%0A
+%09golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975%0A%09golang.org/x/sys v0.0.0-20200219091948-cb0a6d8edb6c // indirect%0A
 %09gol
- f ee064ac1e1bf602fb9589db2dc8337134387963221ca30cab26f10e534219b13 go.sum
+ f 0b219925f9ac1e5ade628197578b3f59af871de71d266f49874e4ce48f358908 go.sum
dmppatch 17
@@ -2567,16 +2567,179 @@
 ycvMj4=%0A
+github.com/fatih/color v1.9.0 h1:8xPHl4/q1VyqGIPif1F+1V3Y3lSmrq01EabUW3CoW5s=%0Agithub.com/fatih/color v1.9.0/go.mod h1:eQcE1qtQxscV5RaZvpXrrb8Drkc3/DdQ+uUYCNjL+zU=%0A
 github.c
@@ -5207,16 +5207,189 @@
 QCu2WE=%0A
+github.com/mattn/go-isatty v0.0.12 h1:wuysRhFDzyxgEmMf5xjvJ2M9dZoWAXNNr5LSBS7uHXY=%0Agithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=%0A
 github.c
@@ -7318,221 +7318,221 @@
 to=%0A
-golang.org/x/crypto v0.0.0-20200214034016-1d94cc7ab1c6 h1:Sy5bstxEqwwbYs6n0/pBuxKENqOeZUgD45Gp3Q3pqLg=%0Agolang.org/x/crypto v0.0.0-20200214034016-1d94cc7ab1c6/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=%0A
+golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975 h1:/Tl7pH94bvbAAHBdZJT947M/+gp0+CqQXDtMRC0fseo=%0Agolang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=%0A
 gola
@@ -8897,32 +8897,346 @@
 ClVuFLEZdDNbEs=%0A
+golang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0Agolang.org/x/sys v0.0.0-20200219091948-cb0a6d8edb6c h1:jceGD5YNJGgGMkJz79agzOln1K9TaZUjv5ird16qniQ=%0Agolang.org/x/sys v0.0.0-20200219091948-cb0a6d8edb6c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0A
 golang.org/x/tex
+ f dd777d0cb0f8d355b24fc82f0c3f44b5b525dfbdfffa18f30504852f4ab30912 updater/updater.go
utf8file 28
// Copyright (c) 2020 The Valhalla Coin developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package updater

import (
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/secpkg"
)

// UpToDate ensures that the package with the base name of the executing
// process is up-to-date, if it is installed as a secure package. If the
// package is not installed as a secure package a corresponding message is
// shown on stderr.
//
// UpToDate times out after a while if DNS cannot be queried and return nil.
func UpToDate() error {
	exec, err := os.Executable()
	if err != nil {
		return err
	}
	name := filepath.Base(exec)
	return secpkg.UpToDate(name)
}

- f 37a29a29cf330257b9dcb093be7697ea966d8a8811d9d80cb3886351176dfc2d vendor/github.com/fatih/color/.travis.yml
- f b48c28aa4720c070e936675fe386d6512ba1d045b8a6044b301d7739699395b6 vendor/github.com/fatih/color/Gopkg.lock
- f 26876e110d2bac5a95c31965dc85f230a30cf202d012cba93b37c4042378a299 vendor/github.com/fatih/color/Gopkg.toml
- f 3ef1b3417bb6c37894318d27520cb30ab7a21593b448f973e057fb14b7fba4e2 vendor/github.com/fatih/color/README.md
+ f bf372701752f8029a9b9e237eff9f09004f902480637f06ebd4801b932353602 vendor/github.com/fatih/color/README.md
dmppatch 12
@@ -1,238 +1,503 @@
-# Color %5B!%5BGoDoc%5D(https://godoc.org/github.com/fatih/color?status.svg)%5D(https://godoc.org/github.com/fatih/color) %5B!%5BBuild Status%5D(https://img.shields.io/travis/fatih/color.svg?style=flat-square)%5D(https://travis-ci.org/fatih/color)%0A
+# Archived project. No maintenance. %0A
 %0A
+This project is not maintained anymore and is archived. Feel free to fork and%0Amake your own changes if needed. For more detail read my blog post: %5BTaking an indefinite sabbatical from my projects%5D(https://arslan.io/2018/10/09/taking-an-indefinite-sabbatical-from-my-projects/)%0A
 %0A
+Thanks to everyone for their valuable feedback and contributions.%0A%0A%0A# Color %5B!%5BGoDoc%5D(https://godoc.org/github.com/fatih/color?status.svg)%5D(https://godoc.org/github.com/fatih/color) %0A
 %0ACol
@@ -830,133 +830,8 @@
 %60%60%60%0A
-%0ANote that the %60vendor%60 folder is here for stability. Remove the folder if you%0Aalready have the dependencies in your GOPATH.%0A
 %0A## 
+ f c13ad20dd1ccdd163e424c1b5c6ca3681ed37c2a2800d2d25736b5f755b430ed vendor/github.com/fatih/color/go.mod
utf8file 9
module github.com/fatih/color

go 1.13

require (
	github.com/mattn/go-colorable v0.1.4
	github.com/mattn/go-isatty v0.0.11
)

+ f 833ff60d89478a0eaec8cde9e32ab51a30e2dca4b050928c126e50622bae4024 vendor/github.com/fatih/color/go.sum
utf8file 9
github.com/mattn/go-colorable v0.1.4 h1:snbPLB8fVfU9iwbbo30TPtbLRzwWu6aJS6Xh4eaaviA=
github.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.11 h1:FxPOTFNqGkuDUGi3H/qkUbQO4ZiBa2brKq5r0l8TGeM=
github.com/mattn/go-isatty v0.0.11/go.mod h1:PhnuNfih5lzO57/f3n+odYbM4JtupLOxQOAqxQCu2WE=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=

+ f 89a68266a49402da64f89ab021826a65d2403279cbd3853309f3b50e5e4def1c vendor/github.com/frankbraun/codechain/archive/archive.go
utf8file 229
// Package archive implements a simple archive format for `codechain apply -f`.
package archive

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"golang.org/x/crypto/nacl/secretbox"
)

var (
	globalHashchainFile = path.Join(def.CodechainDir, "hashchain")
	globalPatchDir      = path.Join(def.CodechainDir, "patches")
)

// Create a new archive for the given hash chain and write it to w.
// patchDir must contain all the necessary patch files.
// The validity of the patch files is not verified!
func Create(w io.Writer, c *hashchain.HashChain, patchDir string) error {
	var buf bytes.Buffer
	zw := gzip.NewWriter(w)
	tw := tar.NewWriter(zw)

	// write hashchain file
	c.Fprint(&buf)
	hdr := &tar.Header{
		Name: globalHashchainFile,
		Mode: 0644,
		Size: int64(buf.Len()),
	}
	log.Printf("archive: write %s", globalHashchainFile)
	if err := tw.WriteHeader(hdr); err != nil {
		return err
	}
	if _, err := tw.Write(buf.Bytes()); err != nil {
		return err
	}

	// write patch files
	treeHashes := c.TreeHashes()
	for i := 0; i < len(treeHashes)-1; i++ {
		treeHash := treeHashes[i]
		patch, err := ioutil.ReadFile(filepath.Join(patchDir, treeHash))
		if err != nil {
			return err
		}
		patchFile := path.Join(globalPatchDir, treeHash)
		hdr := &tar.Header{
			Name: patchFile,
			Mode: 0644,
			Size: int64(len(patch)),
		}
		log.Printf("archive: write %s", patchFile)
		if err := tw.WriteHeader(hdr); err != nil {
			return err
		}
		if _, err := tw.Write(patch); err != nil {
			return err
		}
	}

	if err := tw.Close(); err != nil {
		return err
	}
	return zw.Close()
}

// Apply the archive read from r to the given hashchainFile and patchDir.
// If the hashchainFile is already present it must be transformable by
// appending to the hashchain present in r, otherwise an error is returned.
// If head is not nil the hash chain read from r must contain the given head.
func Apply(hashchainFile, patchDir string, r io.Reader, head *[32]byte) error {
	zr, err := gzip.NewReader(r)
	if err != nil {
		return err
	}
	tr := tar.NewReader(zr)

	for {
		hdr, err := tr.Next()
		if err != nil {
			if err == io.EOF {
				break // end of archive
			}
			return err
		}
		log.Printf("archive: read %s", hdr.Name)
		if hdr.Name == globalHashchainFile {
			log.Printf("hashchainFile: %s", hashchainFile)
			exists, err := file.Exists(hashchainFile)
			if err != nil {
				return err
			}
			log.Printf("exists: %s", strconv.FormatBool(exists))
			if exists {
				// try to merge hashchain files
				c, err := hashchain.ReadFile(hashchainFile)
				if err != nil {
					return err
				}
				src, err := hashchain.Read(tr)
				if err != nil {
					c.Close()
					return err
				}
				if head != nil {
					if err := src.CheckHead(*head); err != nil {
						c.Close()
						return err
					}
				}
				err = c.Merge(src)
				if err != nil {
					c.Close()
					return nil
				}
				if err := c.Close(); err != nil {
					return err
				}
			} else {
				if err := os.MkdirAll(filepath.Dir(hashchainFile), 0755); err != nil {
					return err
				}
				if err := os.MkdirAll(patchDir, 0755); err != nil {
					return err
				}
				src, err := hashchain.Read(tr)
				if err != nil {
					return err
				}
				if head != nil {
					if err := src.CheckHead(*head); err != nil {
						return err
					}
				}
				// save new hashchain file
				f, err := os.Create(hashchainFile)
				if err != nil {
					return err
				}
				if err := src.Fprint(f); err != nil {
					f.Close()
					os.Remove(f.Name())
					return err
				}
				if err := f.Close(); err != nil {
					return err
				}
			}
		} else if path.Dir(hdr.Name) == globalPatchDir {
			patchFile := filepath.Join(patchDir, path.Base(hdr.Name))
			exists, err := file.Exists(patchFile)
			if err != nil {
				return err
			}
			if exists {
				// we already have the patch file, skip it
				if _, err := io.Copy(ioutil.Discard, tr); err != nil {
					return err
				}
			} else {
				// save new patch file
				f, err := os.Create(patchFile)
				if err != nil {
					return err
				}
				if _, err := io.Copy(f, tr); err != nil {
					f.Close()
					return err
				}
				if err := f.Close(); err != nil {
					return err
				}
			}
		} else {
			log.Printf("hdr.Name:       %s", hdr.Name)
			log.Printf("globalPatchDir: %s", globalPatchDir)
			return ErrUnknownFile
		}
	}

	return zr.Close()
}

// ApplyFile applies the archive in filename to the given hashchainFile and patchDir.
// If the hashchainFile is already present it must be transformable by
// appending to the hashchain present in r, otherwise an error is returned.
// If head is not nil the hash chain read from filename must contain the given head.
func ApplyFile(hashchainFile, patchDir, filename string, head *[32]byte) error {
	f, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	log.Printf("applying distribution '%s'", filename)
	return Apply(hashchainFile, patchDir, f, head)
}

// ApplyEncryptedFile applies the encrypted archive in filename to the given
// hashchainFile and patchDir. If the hashchainFile is already present it must
// be transformable by appending to the hashchain present in r, otherwise an
// error is returned. If head is not nil the hash chain read from filename
// must contain the given head.
func ApplyEncryptedFile(hashchainFile, patchDir, filename string, head, key *[32]byte) error {
	log.Printf("applying encrypted distribution '%s'", filename)
	enc, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}
	var nonce [24]byte
	copy(nonce[:], enc[:24])
	msg, verify := secretbox.Open(nil, enc[24:], &nonce, key)
	if !verify {
		return ErrCannotDecrypt
	}
	return Apply(hashchainFile, patchDir, bytes.NewBuffer(msg), head)
}

+ f ffadde29ad8dd443ee91bd2f2bc2c1be9951e2a8ad16884d53816e002b41d17f vendor/github.com/frankbraun/codechain/archive/createdist.go
utf8file 59
package archive

import (
	"bytes"
	"crypto/rand"
	"fmt"
	"io"
	"io/ioutil"
	"os"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"golang.org/x/crypto/nacl/secretbox"
)

// CreateDist creates a distribution file with filename for hash chain c.
// Filename must not exist.
func CreateDist(c *hashchain.HashChain, filename string) error {
	exists, err := file.Exists(filename)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("distribution file '%s' exists already", filename)
	}
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	log.Printf("creating distribution '%s'", filename)
	return Create(f, c, def.PatchDir)
}

// CreateEncryptedDist creates an encrypted distribution file with filename
// for hash chain c. Filename must not exists.
func CreateEncryptedDist(c *hashchain.HashChain, filename string, key *[32]byte) error {
	exists, err := file.Exists(filename)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("distribution file '%s' exists already", filename)
	}
	var b bytes.Buffer
	if err := Create(&b, c, def.PatchDir); err != nil {
		return err
	}
	var nonce [24]byte
	if _, err := io.ReadFull(rand.Reader, nonce[:]); err != nil {
		return err
	}
	enc := secretbox.Seal(nonce[:], b.Bytes(), &nonce, key)
	log.Printf("creating encrypted distribution '%s'", filename)
	return ioutil.WriteFile(filename, enc, 0666)
}

+ f c1de51610929288bb63df9a62d1edf9c2df843d9490b78b7860c8403fdf2ab06 vendor/github.com/frankbraun/codechain/archive/errors.go
utf8file 12
package archive

import (
	"errors"
)

// ErrUnknownFile is returned if an archive contains an unknown file.
var ErrUnknownFile = errors.New("archive: contains unknown file, not a codechain archive?")

// ErrCannotDecrypt is returned if an encrypted archive cannot be decrypted.
var ErrCannotDecrypt = errors.New("archive: cannot decrypt")

+ f bd8b4826bf6783e157efa851502542a27bb90d6adaca71533cfec23896dccd5a vendor/github.com/frankbraun/codechain/secpkg/checkupdate.go
utf8file 164
package secpkg

import (
	"context"
	"fmt"
	"path/filepath"
	"strconv"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/ssot"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/homedir"
	"github.com/frankbraun/codechain/util/log"
)

func checkUpdate(ctx context.Context, visited map[string]bool, name string) (bool, error) {
	// 1. Make sure the project with NAME has been installed before.
	//    That is, the directory ~/.config/secpkg/pkgs/NAME exists.
	//    Set SKIP_CHECK and NEEDS_UPDATE to false.
	log.Printf("1. make sure '%s' has been installed\n", name)
	pkgDir := filepath.Join(homedir.SecPkg(), "pkgs", name)
	exists, err := file.Exists(pkgDir)
	if err != nil {
		return false, err
	}
	if !exists {
		return false, ErrNotInstalled
	}
	skipCheck := false
	needsUpdate := false

	// 2. Load .secpkg file from ~/.config/secpkg/pkgs/NAME/.secpkg
	log.Println("2. load .secpkg file")
	fn := filepath.Join(pkgDir, File)
	pkg, err := Load(fn)
	if err != nil {
		return false, err
	}
	if pkg.Name != name {
		return false,
			fmt.Errorf("package to update (%s) differs from package name in %s", name, fn)
	}

	// 3. Load signed head from ~/.config/secpkg/pkgs/NAME/signed_head (as DISK)
	log.Println("3. load signed head")
	signedHeadFile := filepath.Join(pkgDir, "signed_head")
	shDisk, err := ssot.Load(signedHeadFile)
	if err != nil {
		return false, err
	}

	// 4. Query TXT record from _codechain-head.DNS, if it is the same as DISK, set
	//    SKIP_CHECK to true.
	log.Println("4. query TX record")
	shDNS, err := ssot.LookupHead(ctx, pkg.DNS)
	if err != nil {
		return false, err
	}
	if shDisk.Marshal() == shDNS.Marshal() {
		skipCheck = true
	}

	// 5. If not SKIP_CHECK, validate signed head from TXT (also see ssot package)
	//    and store HEAD:
	//
	// 	  - pubKey from TXT must be the same as pubKey or pubKeyRotate from DISK,
	// 	    if the signed head from DISK is not expired.
	// 	  - The counter from TXT must be larger than the counter from DISK.
	// 	  - The signed head must be valid (as defined by validFrom and validTo).
	//
	// If the validation fails, abort check update procedure and report error.
	log.Println("5. validate signed head")
	if !skipCheck {
		if err := shDisk.Valid(); err == nil { // not expired
			if !(shDNS.PubKey() == shDisk.PubKey() ||
				shDNS.PubKey() == shDisk.PubKeyRotate()) {
				return false,
					fmt.Errorf("secpkg: public key from TXT record does not match public key (or rotate) from disk")
			}
		}
		if shDNS.Counter() <= shDisk.Counter() {
			return false,
				fmt.Errorf("secpkg: counter from TXT record is not increasing")
		}
		if err := shDNS.Valid(); err != nil {
			return false, err
		}
	} else {
		log.Println("skipped")
	}

	// 6. If not SKIP_CHECK and if signed head from TXT record not the same as the
	//    one from DISK, set SKIP_CHECK and NEEDS_UPDATE to true.
	log.Println("6. compare signed heads")
	if !skipCheck {
		if shDNS.Head() == shDisk.Head() {
			log.Println("set SKIP_CHECK and NEEDS_UPDATE to true")
			skipCheck = true
			needsUpdate = true
		}
	} else {
		log.Println("skipped")
	}

	// 7. If not NEEDS_UPDATE, check if HEAD is contained in
	//    ~/.config/secpkg/pkgs/NAME/src/.codchain/hashchain.
	//    If not, set NEEDS_UPDATE to true.
	log.Println("7. check if HEAD is contained in hashchain")
	if !needsUpdate {
		srcDir := filepath.Join(pkgDir, "src")
		c, err := hashchain.ReadFile(filepath.Join(srcDir, def.HashchainFile))
		if err != nil {
			return false, err
		}
		if err := c.Close(); err != nil {
			return false, err
		}
		log.Printf("c.CheckHead(%s)\n", shDNS.Head())
		if err := c.CheckHead(shDNS.HeadBuf()); err != nil {
			log.Println("set NEEDS_UPDATE=true")
			needsUpdate = true
		}
	} else {
		log.Println("skipped")
	}

	// 8. If NEEDS_UPDATE is false, check if the directory
	//    ~/.config/secpkg/pkgs/NAME/src/.secdep exists and contains any .secpkg
	//    files, ensure these secure dependencies are installed and up-to-date. If
	//    at least one dependency needs an update, set NEEDS_UPDATE to true.
	log.Println("8. check .secdep directory")
	if !needsUpdate {
		needsUpdate, err = ensureCheckUpdate(ctx, visited, name)
		if err != nil {
			return false, err
		}
	} else {
		log.Println("skipped")
	}

	// 9. Update signed head:
	//
	//    - `cp -f ~/.config/secpkg/pkgs/NAME/signed_head
	//             ~/.config/secpkg/pkgs/NAME/previous_signed_head`
	//    - Save new signed head to ~/.config/secpkg/pkgs/NAME/signed_head (atomic).
	log.Println("9. update signed head")
	if err := shDNS.RotateFile(pkgDir); err != nil {
		return false, nil
	}

	// 10. Return NEEDS_UPDATE.
	log.Printf("10. return NEEDS_UPDATE=%s\n", strconv.FormatBool(needsUpdate))
	return needsUpdate, nil
}

// CheckUpdate checks installed package with name for updates, see
// specification for details.
func CheckUpdate(ctx context.Context, name string) (bool, error) {
	visited := make(map[string]bool)
	visited[name] = true
	return checkUpdate(ctx, visited, name)
}

+ f 8951ac10abd9cc06a9cfadde82d1d25b84e973f071edc6ceeabcea008b0b6de7 vendor/github.com/frankbraun/codechain/secpkg/doc.go
utf8file 197
/*
Package secpkg implements the secpkg package format.

A secure package (.secpkg file) contains a JSON object with the following keys:

  {
    "Name": "the project's package name",
    "Head": "head of project's Codechain",
    "DNS": "fully qualified domain name for Codechain's TXT records",
  }

Example .secpkg file for Codechain itself:

  {
    "Name": "codechain",
    "Head": "53f2c26d92e173306e83d54e3103ef2e0bd87a561315bc4b49e1ee6c78dfb583",
    "DNS": "codechain.secpkg.net",
  }

If in the root of a package source tree the directory .secdep exists and
contains any .secpkg files, then these secure dependencies are installed and
kept up-to-date by the install and update procedures specified below.

Install specification

Installing software described by a .secpkg file works as follows:

   1. Parse .secpkg file and validate it. Save head as HEAD_PKG.

   2. Make sure the project with NAME has not been installed before.
      That is, the directory ~/.config/secpkg/pkgs/NAME does not exist.

   3. Create directory ~/.config/secpkg/pkgs/NAME

   4. Save .secpkg file to ~/.config/secpkg/pkgs/NAME/.secpkg

   5. Query TXT record from _codechain-head.DNS and validate the signed head
      contained in it (see ssot package). Save head from TXT record (HEAD_SSOT).

   6. Query TXT record from _codechain-url.DNS and save it as URL.

   7. Store the signed head to ~/.config/secpkg/pkgs/NAME/signed_head

   8. Download distribution file from URL/HEAD_SSOT.tar.gz and save it to
      ~/.config/secpkg/pkgs/NAME/dists

   9. Apply ~/.config/secpkg/pkgs/NAME/dists/HEAD_SSOT.tar.gz
      to ~/.config/secpkg/pkgs/NAME/src with `codechain apply
      -f ~/.config/secpkg/pkgs/NAME/dists/HEAD_SSOT.tar.gz -head HEAD_SSOT`

  10. Make sure HEAD_PKG is contained in
      ~/.config/secpkg/pkgs/NAME/src/.codchain/hashchain

  11. If the directory ~/.config/secpkg/pkgs/NAME/src/.secdep exists and
      contains any .secpkg files, ensure these secure dependencies are
      installed and up-to-date.

  12. `cp -r ~/.config/secpkg/pkgs/NAME/src ~/.config/secpkg/pkgs/NAME/build`

  13. Call `make prefix=~/.config/secpkg/local` in
      ~/.config/secpkg/pkgs/NAME/build

  14. Call `make prefix= ~/.config/secpkg/local install` in
      ~/.config/secpkg/pkgs/NAME/build

  15. `mv ~/.config/secpkg/pkgs/NAME/build ~/.config/secpkg/pkgs/NAME/installed`

  If the installation process fails at any stage during the procedure described
  above, report the error and remove the directory ~/.config/secpkg/pkgs/NAME.

For the process above to work, the projects distributed as secure packages
must contain a Makefile (for GNU Make) with the "all" target building the
software and the "install" target installing it.

The software must be self-contained without any external dependencies, except
for the compiler. For Go software that means at least Go 1.11 must be
installed (with module support) and all dependencies must be vendored.

Update specification

Updating a software package with NAME works as follows:

   1. Make sure the project with NAME has been installed before.
      That is, the directory ~/.config/secpkg/pkgs/NAME exists.
      Set SKIP_BUILD to false.

   2. Load .secpkg file from ~/.config/secpkg/pkgs/NAME/.secpkg

   3. Load signed head from ~/.config/secpkg/pkgs/NAME/signed_head (as DISK)

   4. Query TXT record from _codechain-head.DNS, if it is the same as DISK, set
      SKIP_BUILD to true.

   5. Query TXT record from _codechain-url.DNS and save it as URL.

   6. If not SKIP_BUILD, validate signed head from TXT (also see ssot package)
      and store HEAD:

      - pubKey from TXT must be the same as pubKey or pubKeyRotate from DISK,
        if the signed head from DISK is not expired.
      - The counter from TXT must be larger than the counter from DISK.
      - The signed head must be valid (as defined by validFrom and validTo).

      If the validation fails, abort update procedure and report error.

   7. If not SKIP_BUILD and if signed head from TXT record is the same as the
      one from DISK, set SKIP_BUILD to true.

   8. If SKIP_BUILD, check if HEAD is contained in
      ~/.config/secpkg/pkgs/NAME/src/.codchain/hashchain.
      If not, set SKIP_BUILD to false.
      This can happend if we checked for updates.

   9. If not SKIP_BUILD, download distribution file from URL/HEAD.tar.gz and
      save it to ~/.config/secpkg/pkgs/NAME/dists

  10. If not SKIP_BUILD, apply ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz
      to ~/.config/secpkg/pkgs/NAME/src with `codechain apply
      -f ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz -head HEAD`.

  11. If the directory ~/.config/secpkg/pkgs/NAME/src/.secdep exists and
      contains any .secpkg files, ensure these secure dependencies are
      installed and up-to-date. If at least one dependency was updated, set
      SKIP_BUILD to false.

  12. If not SKIP_BUILD, call `make prefix=~/.config/secpkg/local uninstall` in
      ~/.config/secpkg/pkgs/NAME/installed

  13. If not SKIP_BUILD, `rm -rf ~/.config/secpkg/pkgs/NAME/build`

  14. If not SKIP_BUILD,
      `cp -r ~/.config/secpkg/pkgs/NAME/src ~/.config/secpkg/pkgs/NAME/build`

  15. If not SKIP_BUILD, call `make prefix=~/.config/secpkg/local` in
      ~/.config/secpkg/pkgs/NAME/build

  16. If not SKIP_BUILD, call `make prefix= ~/.config/secpkg/local install` in
      ~/.config/secpkg/pkgs/NAME/build

  17. If not SKIP_BUILD,
      `mv ~/.config/secpkg/pkgs/NAME/build ~/.config/secpkg/pkgs/NAME/installed`

  18. Update signed head:

      - `cp -f ~/.config/secpkg/pkgs/NAME/signed_head
               ~/.config/secpkg/pkgs/NAME/previous_signed_head`
      - Save new signed head to ~/.config/secpkg/pkgs/NAME/signed_head (atomic).

  19. The software has been successfully updated.

CheckUpdate specification

Checking if a software package with NAME needs an update works as follows:

   1. Make sure the project with NAME has been installed before.
      That is, the directory ~/.config/secpkg/pkgs/NAME exists.
      Set SKIP_CHECK and NEEDS_UPDATE to false.

   2. Load .secpkg file from ~/.config/secpkg/pkgs/NAME/.secpkg

   3. Load signed head from ~/.config/secpkg/pkgs/NAME/signed_head (as DISK)

   4. Query TXT record from _codechain-head.DNS, if it is the same as DISK, set
      SKIP_CHECK to true.

   5. If not SKIP_CHECK, validate signed head from TXT (also see ssot package)
      and store HEAD:

      - pubKey from TXT must be the same as pubKey or pubKeyRotate from DISK,
        if the signed head from DISK is not expired.
      - The counter from TXT must be larger than the counter from DISK.
      - The signed head must be valid (as defined by validFrom and validTo).

      If the validation fails, abort check update procedure and report error.

   6. If not SKIP_CHECK and if signed head from TXT record not the same as the
      one from DISK, set SKIP_CHECK and NEEDS_UPDATE to true.

   7. If not NEEDS_UPDATE, check if HEAD is contained in
      ~/.config/secpkg/pkgs/NAME/src/.codchain/hashchain.
      If not, set NEEDS_UPDATE to true.

   8. If NEEDS_UPDATE is false, check if the directory
      ~/.config/secpkg/pkgs/NAME/src/.secdep exists and contains any .secpkg
      files, ensure these secure dependencies are installed and up-to-date. If
      at least one dependency needs an update, set NEEDS_UPDATE to true.

   9. Update signed head:

      - `cp -f ~/.config/secpkg/pkgs/NAME/signed_head
               ~/.config/secpkg/pkgs/NAME/previous_signed_head`
      - Save new signed head to ~/.config/secpkg/pkgs/NAME/signed_head (atomic).

  10. Return NEEDS_UPDATE.
*/
package secpkg

+ f 3f438af001efb679c3e8f3488383535f44faa5d27a5990ae7ac29d3269700e37 vendor/github.com/frankbraun/codechain/secpkg/ensure.go
utf8file 191
package secpkg

import (
	"context"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"strings"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/hex"
	"github.com/frankbraun/codechain/util/homedir"
	"github.com/frankbraun/codechain/util/log"
)

// ensure the secure dependencies for package name are installed and up-to-date.
func ensure(
	ctx context.Context,
	visited map[string]bool,
	name string,
) (bool, error) {
	// If the directory ~/.config/secpkg/pkgs/NAME/src/.secdep exists and
	// contains any .secpkg files, ensure these secure dependencies are
	// installed and up-to-date.
	secdepDir := filepath.Join(homedir.SecPkg(), "pkgs", name, "src", ".secdep")
	exists, err := file.Exists(secdepDir)
	if err != nil {
		return false, err
	}
	if !exists {
		log.Println(".secdep: no dependencies found")
		return false, nil // no dependencies found
	}
	log.Printf(".secdep: scanning dir '%s'\n", secdepDir)

	// process .secdep directory
	files, err := ioutil.ReadDir(secdepDir)
	if err != nil {
		return false, err
	}
	depUpdated := false
	for _, fi := range files {
		if !strings.HasSuffix(fi.Name(), ".secpkg") {
			log.Printf(".secdep: skip '%s'", fi.Name())
			continue // not a .secpkg file
		}
		// load .secpkg file
		log.Printf(".secdep: load '%s'", fi.Name())
		pkg, err := Load(filepath.Join(secdepDir, fi.Name()))
		if err != nil {
			return false, err
		}
		// check for cycles
		if visited[pkg.Name] {
			return false, fmt.Errorf("secpkg: dependency cycle detected for package '%s'",
				pkg.Name)
		}
		// check if it is already installed
		pkgDir := filepath.Join(homedir.SecPkg(), "pkgs", pkg.Name)
		exists, err := file.Exists(pkgDir)
		if err != nil {
			return false, err
		}
		visited[pkg.Name] = true
		if !exists {
			// install
			log.Printf(".secdep: install package '%s'\n", pkg.Name)
			if err := pkg.install(ctx, visited); err != nil {
				return false, err
			}
			depUpdated = true
		} else {
			// parse head
			h, err := hex.Decode(pkg.Head, 32)
			if err != nil {
				return false, err
			}
			var head [32]byte
			copy(head[:], h)
			// update
			log.Printf(".secdep: update package '%s'\n", pkg.Name)
			updated, err := update(ctx, visited, pkg.Name)
			if err != nil {
				return false, err
			}
			if updated {
				depUpdated = true
			}
			// make sure HEAD of .secpkg is actually contained in hash chain
			// (that is, we have updated the correct package).
			hashchainFile := filepath.Join(pkgDir, "src", def.HashchainFile)
			c, err := hashchain.ReadFile(hashchainFile)
			if err != nil {
				return false, err
			}
			if err := c.Close(); err != nil {
				return false, err
			}
			if err := c.CheckHead(head); err != nil {
				if err == hashchain.ErrHeadNotFound {
					return false, fmt.Errorf("secpkg: head '%s' of .secpkg '%s' not found in '%s'. "+
						"Conflicting packages?", pkg.Head, fi.Name(), hashchainFile)
				}
				return false, err
			}
		}
		delete(visited, pkg.Name)
	}

	return depUpdated, nil
}

// ensureCheckUpdate ensures the secure dependencies for package name are up-to-date.
func ensureCheckUpdate(
	ctx context.Context,
	visited map[string]bool,
	name string,
) (bool, error) {
	// If the directory ~/.config/secpkg/pkgs/NAME/src/.secdep exists and
	// contains any .secpkg files, ensure these secure dependencies are
	// up-to-date.
	secdepDir := filepath.Join(homedir.SecPkg(), "pkgs", name, "src", ".secdep")
	exists, err := file.Exists(secdepDir)
	if err != nil {
		return false, err
	}
	if !exists {
		log.Println(".secdep: no dependencies found")
		return false, nil // no dependencies found
	}
	log.Printf(".secdep: scanning dir '%s'\n", secdepDir)

	// process .secdep directory
	files, err := ioutil.ReadDir(secdepDir)
	if err != nil {
		return false, err
	}
	needsUpdate := false
	for _, fi := range files {
		if !strings.HasSuffix(fi.Name(), ".secpkg") {
			log.Printf(".secdep: skip '%s'", fi.Name())
			continue // not a .secpkg file
		}
		// load .secpkg file
		log.Printf(".secdep: load '%s'", fi.Name())
		pkg, err := Load(filepath.Join(secdepDir, fi.Name()))
		if err != nil {
			return false, err
		}
		// check for cycles
		if visited[pkg.Name] {
			return false, fmt.Errorf("secpkg: dependency cycle detected for package '%s'",
				pkg.Name)
		}
		// check if it is already installed
		pkgDir := filepath.Join(homedir.SecPkg(), "pkgs", pkg.Name)
		exists, err := file.Exists(pkgDir)
		if err != nil {
			return false, err
		}
		visited[pkg.Name] = true
		if !exists {
			// not installled
			log.Printf(".secdep: package '%s' not installed\n", pkg.Name)
			needsUpdate = true
		} else {
			// parse head
			h, err := hex.Decode(pkg.Head, 32)
			if err != nil {
				return false, err
			}
			var head [32]byte
			copy(head[:], h)
			// update
			log.Printf(".secdep: check update for package '%s'\n", pkg.Name)
			update, err := checkUpdate(ctx, visited, pkg.Name)
			if err != nil {
				return false, err
			}
			if update {
				needsUpdate = true
			}
		}
		delete(visited, pkg.Name)
	}

	return needsUpdate, nil
}

+ f fe65288c5abdad7b5d3d6d9b673e5d8405112a1f4cfa2fda1b8ffb292361b41f vendor/github.com/frankbraun/codechain/secpkg/errors.go
utf8file 15
package secpkg

import (
	"errors"
)

// ErrNotInstalled is returned if a package is not installed.
var ErrNotInstalled = errors.New("secpkg: package not installed")

// ErrPkgNameWhitespace is returned if a package name contains a white space character.
var ErrPkgNameWhitespace = errors.New("secpkg: package name contains white space character")

// ErrNoKey is returned if a package has no secretbox encryption key.
var ErrNoKey = errors.New("secpkg: package has no secretbox encryption key")

+ f 4efc32060ec9762930c6d9a97baa4bfb630abf5c9e42ef21dd8ec02514b8a38a vendor/github.com/frankbraun/codechain/secpkg/install.go
utf8file 212
package secpkg

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/archive"
	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/ssot"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/gnumake"
	"github.com/frankbraun/codechain/util/hex"
	"github.com/frankbraun/codechain/util/homedir"
)

func (pkg *Package) install(ctx context.Context, visited map[string]bool) error {
	// 1. Has already been done by calling Load().

	// 2. Make sure the project has not been installed before.
	//    That is, the directory ~/.config/secpkg/pkgs/NAME does not exist.
	pkgDir := filepath.Join(homedir.SecPkg(), "pkgs", pkg.Name)
	exists, err := file.Exists(pkgDir)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("package already installed: '%s' exists", pkgDir)
	}

	// 3. Create directory ~/.config/secpkg/pkgs/NAME
	if err := os.MkdirAll(pkgDir, 0755); err != nil {
		return err
	}

	// 4. Save .secpkg file to ~/.config/secpkg/pkgs/NAME/.secpkg
	fn := filepath.Join(pkgDir, File)
	err = ioutil.WriteFile(fn, []byte(pkg.Marshal()+"\n"), 0644)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	fmt.Printf("%s: written\n", fn)

	// 5. Query TXT record from _codechain-head.DNS and validate the signed head
	//    contained in it (see ssot package).
	sh, err := ssot.LookupHead(ctx, pkg.DNS)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 6. Query TXT record from _codechain-url.DNS and save it as URL.
	URL, err := ssot.LookupURL(ctx, pkg.DNS)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 7. Store the signed head to ~/.config/secpkg/pkgs/NAME/signed_head
	signedHead := filepath.Join(pkgDir, ssot.File)
	err = ioutil.WriteFile(signedHead, []byte(sh.Marshal()+"\n"), 0644)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	fmt.Printf("%s: written\n", signedHead)

	// 8. Download distribution file from URL/HEAD_SSOT.tar.gz and save it to
	//    ~/.config/secpkg/pkgs/NAME/dists
	distDir := filepath.Join(pkgDir, "dists")
	if err := os.MkdirAll(distDir, 0755); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	var encSuffix string
	if pkg.Key != "" {
		encSuffix = ".enc"
	}
	fn = sh.Head() + ".tar.gz" + encSuffix
	filename := filepath.Join(distDir, fn)
	url := URL + "/" + fn
	fmt.Printf("download %s\n", url)
	err = file.Download(filename, url)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 9. Apply ~/.config/secpkg/pkgs/NAME/dists/HEAD_SSOT.tar.gz
	//    to ~/.config/secpkg/pkgs/NAME/src with `codechain apply
	//    -f ~/.config/secpkg/pkgs/NAME/dists/HEAD_SSOT.tar.gz -head HEAD_SSOT`
	srcDir := filepath.Join(pkgDir, "src")
	if err := os.MkdirAll(srcDir, 0755); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	if err := os.Chdir(srcDir); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	head := sh.HeadBuf()
	distFile := filepath.Join("..", "dists", fn)
	if pkg.Key != "" {
		key, err := pkg.GetKey()
		if err != nil {
			return err
		}
		err = archive.ApplyEncryptedFile(def.HashchainFile, def.PatchDir,
			distFile, &head, key)
		if err != nil {
			os.RemoveAll(pkgDir)
			return err
		}
	} else {
		err = archive.ApplyFile(def.HashchainFile, def.PatchDir, distFile, &head)
		if err != nil {
			os.RemoveAll(pkgDir)
			return err
		}
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	if err := c.Close(); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	if err := c.Apply(&head); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 10. Make sure HEAD_PKG is contained in
	//     ~/.config/secpkg/pkgs/NAME/src/.codchain/hashchain
	h, err := hex.Decode(pkg.Head, 32)
	if err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	copy(head[:], h)
	if err := c.CheckHead(head); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 11. If the directory ~/.config/secpkg/pkgs/NAME/src/.secdep exists and
	//     contains any .secpkg files, ensure these secure dependencies are
	//     installed and up-to-date.
	if _, err := ensure(ctx, visited, pkg.Name); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 12. `cp -r ~/.config/secpkg/pkgs/NAME/src ~/.config/secpkg/pkgs/NAME/build`
	buildDir := filepath.Join(pkgDir, "build")
	if err := file.CopyDir(srcDir, buildDir); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 13. Call `make prefix=~/.config/secpkg/local` in
	//     ~/.config/secpkg/pkgs/NAME/build
	localDir := filepath.Join(homedir.SecPkg(), "local")
	if err := os.MkdirAll(localDir, 0755); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	if err := os.Chdir(buildDir); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	/* TODO: call via $SHELL
	shell := os.Getenv("SHELL")
	if shell == "" {
		os.RemoveAll(pkgDir)
		return errors.New("secpkg: $SHELL not defined")
	}
	*/
	if err := gnumake.Call(localDir); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 14. Call `make prefix=~/.config/secpkg/local install` in
	//     ~/.config/secpkg/pkgs/NAME/build
	if err := gnumake.Install(localDir); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}

	// 15. `mv ~/.config/secpkg/pkgs/NAME/build ~/.config/secpkg/pkgs/NAME/installed`
	installedDir := filepath.Join(pkgDir, "installed")
	if err := os.Rename(buildDir, installedDir); err != nil {
		os.RemoveAll(pkgDir)
		return err
	}
	return nil
}

// Install pkg, see specification for details.
func (pkg *Package) Install(ctx context.Context) error {
	visited := make(map[string]bool)
	visited[pkg.Name] = true
	return pkg.install(ctx, visited)
}

+ f 479cc63b2683274678bc6850d49811aae66ff6d35d28e2309c0b133ed746887a vendor/github.com/frankbraun/codechain/secpkg/secpkg.go
utf8file 85
package secpkg

import (
	"crypto/rand"
	"encoding/json"
	"io"
	"io/ioutil"
	"net/url"
	"strings"

	"github.com/frankbraun/codechain/util/hex"
)

// File defines the default file (ending) for a secure package.
const File = ".secpkg"

// Package defines a package in secpkg format (stored in .secpkg files).
type Package struct {
	Name string // the project's package name
	Head string // head of project's Codechain
	DNS  string // fully qualified domain name for Codechain's TXT records (SSOT)
	Key  string `json:",omitempty"` // optional secretbox encryption key
}

// New creates a new Package.
func New(name, dns string, head [32]byte, encrypted bool) (*Package, error) {
	// validate arguments
	if strings.Contains(name, " ") {
		return nil, ErrPkgNameWhitespace
	}
	if _, err := url.Parse(dns); err != nil {
		return nil, err
	}
	// create package
	var pkg Package
	pkg.Name = strings.ToLower(name) // project names are lowercase
	pkg.Head = hex.Encode(head[:])
	pkg.DNS = dns
	if encrypted {
		var key [32]byte
		if _, err := io.ReadFull(rand.Reader, key[:]); err != nil {
			return nil, err
		}
		pkg.Key = hex.Encode(key[:])
	}
	return &pkg, nil
}

// Load a .secpkg file from filename and return the Package struct.
func Load(filename string) (*Package, error) {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	var pkg Package
	if err := json.Unmarshal(data, &pkg); err != nil {
		return nil, err
	}
	return &pkg, err
}

// Marshal pkg as string.
func (pkg *Package) Marshal() string {
	jsn, err := json.MarshalIndent(pkg, "", "  ")
	if err != nil {
		panic(err) // should never happen
	}
	return string(jsn)
}

// GetKey returns the secretbox encryption key or an error if the key does not
// exist or is not parsable.
func (pkg *Package) GetKey() (*[32]byte, error) {
	if pkg.Key == "" {
		return nil, ErrNoKey
	}
	k, err := hex.Decode(pkg.Key, 32)
	if err != nil {
		return nil, err
	}
	var key [32]byte
	copy(key[:], k)
	return &key, nil
}

+ f 26af67b0e34966eabd744fcbfa6e9e48bf83eaf3dd9a36db75c95b109929c3c7 vendor/github.com/frankbraun/codechain/secpkg/uninstall.go
utf8file 40
package secpkg

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/gnumake"
	"github.com/frankbraun/codechain/util/homedir"
)

// Uninstall package with name.
func Uninstall(name string) error {
	// 1. Make sure the project with NAME has been installed before.
	//    That is, the directory ~/.config/secpkg/pkgs/NAME exists.
	pkgDir := filepath.Join(homedir.SecPkg(), "pkgs", name)
	exists, err := file.Exists(pkgDir)
	if err != nil {
		return err
	}
	if !exists {
		return fmt.Errorf("package not installed: '%s' does not exist", pkgDir)
	}

	// 2. Call `make prefix= ~/.config/secpkg/local uninstall` in
	//    ~/.config/secpkg/pkgs/NAME/installed
	installedDir := filepath.Join(pkgDir, "installed")
	localDir := filepath.Join(homedir.SecPkg(), "local")
	if err := os.Chdir(installedDir); err != nil {
		return err
	}
	if err := gnumake.Uninstall(localDir); err != nil {
		return err
	}

	// 3. Remove package directory ~/.config/secpkg/pkgs/NAME
	return os.RemoveAll(pkgDir)
}

+ f 7caddb9d7485dd28c3bcd2dac666dcf211ee3f773b3f4ffa2e584ee13b9e6c81 vendor/github.com/frankbraun/codechain/secpkg/update.go
utf8file 270
package secpkg

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/archive"
	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/ssot"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/gnumake"
	"github.com/frankbraun/codechain/util/homedir"
)

func update(ctx context.Context, visited map[string]bool, name string) (bool, error) {
	// 1. Make sure the project with NAME has been installed before.
	//    That is, the directory ~/.config/secpkg/pkgs/NAME exists.
	//    Set SKIP_BUILD to false.
	pkgDir := filepath.Join(homedir.SecPkg(), "pkgs", name)
	exists, err := file.Exists(pkgDir)
	if err != nil {
		return false, err
	}
	if !exists {
		return false, ErrNotInstalled
	}
	skipBuild := false

	// 2. Load .secpkg file from ~/.config/secpkg/pkgs/NAME/.secpkg
	fn := filepath.Join(pkgDir, File)
	pkg, err := Load(fn)
	if err != nil {
		return false, err
	}
	if pkg.Name != name {
		return false,
			fmt.Errorf("package to update (%s) differs from package name in %s", name, fn)
	}

	// 3. Load signed head from ~/.config/secpkg/pkgs/NAME/signed_head (as DISK)
	signedHeadFile := filepath.Join(pkgDir, "signed_head")
	shDisk, err := ssot.Load(signedHeadFile)
	if err != nil {
		return false, err
	}

	// 4. Query TXT record from _codechain-head.DNS, if it is the same as DISK, set
	//    SKIP_BUILD to true.
	shDNS, err := ssot.LookupHead(ctx, pkg.DNS)
	if err != nil {
		return false, err
	}
	if shDisk.Marshal() == shDNS.Marshal() {
		skipBuild = true
	}

	// 5. Query TXT record from _codechain-url.DNS and save it as URL.
	URL, err := ssot.LookupURL(ctx, pkg.DNS)
	if err != nil {
		os.RemoveAll(pkgDir)
		return false, err
	}

	// 6. If not SKIP_BUILD, validate signed head from TXT (also see ssot package)
	//    and store HEAD:
	//
	//    - pubKey from TXT must be the same as pubKey or pubKeyRotate from DISK
	//      if the signed head from DISK is not expired.
	//    - The counter from TXT must be larger than the counter from DISK.
	//    - The signed head must be valid (as defined by validFrom and validTo).
	//
	//    If the validation fails, abort update procedure and report error.
	if !skipBuild {
		if err := shDisk.Valid(); err == nil { // not expired
			if !(shDNS.PubKey() == shDisk.PubKey() ||
				shDNS.PubKey() == shDisk.PubKeyRotate()) {
				return false,
					fmt.Errorf("secpkg: public key from TXT record does not match public key (or rotate) from disk")
			}
		}
		if shDNS.Counter() <= shDisk.Counter() {
			return false,
				fmt.Errorf("secpkg: counter from TXT record is not increasing")
		}
		if err := shDNS.Valid(); err != nil {
			return false, err
		}
	}

	// 7. If not SKIP_BUILD and if signed head from TXT record is the same as the
	//    one from DISK, set SKIP_BUILD to true.
	if !skipBuild {
		if shDNS.Head() == shDisk.Head() {
			skipBuild = true
		}
	}

	// 8. If SKIP_BUILD, check if HEAD is contained in
	//    ~/.config/secpkg/pkgs/NAME/src/.codchain/hashchain.
	//    If not, set SKIP_BUILD to false.
	//    This can happend if we checked for updates.
	srcDir := filepath.Join(pkgDir, "src")
	if skipBuild {
		c, err := hashchain.ReadFile(filepath.Join(srcDir, def.HashchainFile))
		if err != nil {
			return false, err
		}
		if err := c.Close(); err != nil {
			return false, err
		}
		if err := c.CheckHead(shDNS.HeadBuf()); err != nil {
			skipBuild = false
		}
	}

	// 9. If not SKIP_BUILD, download distribution file from URL/HEAD.tar.gz and
	//    save it to ~/.config/secpkg/pkgs/NAME/dists
	if !skipBuild {
		distDir := filepath.Join(pkgDir, "dists")
		var encSuffix string
		if pkg.Key != "" {
			encSuffix = ".enc"
		}
		fn = shDNS.Head() + ".tar.gz" + encSuffix
		filename := filepath.Join(distDir, fn)
		url := URL + "/" + fn
		fmt.Printf("download %s\n", url)
		err = file.Download(filename, url)
		if err != nil {
			return false, err
		}
	}

	// 10. If not SKIP_BUILD, apply ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz
	//     to ~/.config/secpkg/pkgs/NAME/src with `codechain apply
	//     -f ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz -head HEAD`.
	if !skipBuild {
		if err := os.Chdir(srcDir); err != nil {
			return false, err
		}
		head := shDNS.HeadBuf()
		distFile := filepath.Join("..", "dists", fn)
		if pkg.Key != "" {
			key, err := pkg.GetKey()
			if err != nil {
				return false, err
			}
			err = archive.ApplyEncryptedFile(def.HashchainFile, def.PatchDir,
				distFile, &head, key)
			if err != nil {
				return false, err
			}
		} else {
			err = archive.ApplyFile(def.HashchainFile, def.PatchDir, distFile, &head)
			if err != nil {
				return false, err
			}
		}
		c, err := hashchain.ReadFile(def.HashchainFile)
		if err != nil {
			return false, err
		}
		if err := c.Close(); err != nil {
			return false, err
		}
		if err := c.Apply(&head); err != nil {
			return false, err
		}
	}

	// 11. If the directory ~/.config/secpkg/pkgs/NAME/src/.secdep exists and
	//     contains any .secpkg files, ensure these secure dependencies are
	//     installed and up-to-date. If at least one dependency was updated, set
	//     SKIP_BUILD to false.
	depUpdated, err := ensure(ctx, visited, name)
	if err != nil {
		return false, err
	}
	if depUpdated {
		skipBuild = false
	}

	// 12. If not SKIP_BUILD, call `make prefix=~/.config/secpkg/local uninstall` in
	//     ~/.config/secpkg/pkgs/NAME/installed
	installedDir := filepath.Join(pkgDir, "installed")
	localDir := filepath.Join(homedir.SecPkg(), "local")
	if !skipBuild {
		if err := os.Chdir(installedDir); err != nil {
			return false, err
		}
		if err := gnumake.Uninstall(localDir); err != nil {
			return false, err
		}
	}

	// 13. If not SKIP_BUILD, `rm -rf ~/.config/secpkg/pkgs/NAME/build`
	buildDir := filepath.Join(pkgDir, "build")
	if !skipBuild {
		if err := os.RemoveAll(buildDir); err != nil {
			return false, err
		}
	}

	// 14. If not SKIP_BUILD,
	//     `cp -r ~/.config/secpkg/pkgs/NAME/src ~/.config/secpkg/pkgs/NAME/build`
	if !skipBuild {
		if err := file.CopyDir(srcDir, buildDir); err != nil {
			return false, err
		}
	}

	// 16. If not SKIP_BUILD, call `make prefix=~/.config/secpkg/local` in
	//     ~/.config/secpkg/pkgs/NAME/build
	if !skipBuild {
		if err := os.Chdir(buildDir); err != nil {
			os.RemoveAll(pkgDir)
			return false, err
		}
		if err := gnumake.Call(localDir); err != nil {
			return false, err
		}
	}

	// 16. If not SKIP_BUILD, call `make prefix= ~/.config/secpkg/local install` in
	//     ~/.config/secpkg/pkgs/NAME/build
	if !skipBuild {
		if err := gnumake.Install(localDir); err != nil {
			return false, err
		}
	}

	// 17. If not SKIP_BUILD,
	//     `mv ~/.config/secpkg/pkgs/NAME/build ~/.config/secpkg/pkgs/NAME/installed`
	if !skipBuild {
		if err := os.RemoveAll(installedDir); err != nil {
			return false, err
		}
		if err := os.Rename(buildDir, installedDir); err != nil {
			return false, err
		}
	}

	// 18. Update signed head:
	//
	//      - `cp -f ~/.config/secpkg/pkgs/NAME/signed_head
	//               ~/.config/secpkg/pkgs/NAME/previous_signed_head`
	//      - Save new signed head to ~/.config/secpkg/pkgs/NAME/signed_head (atomic).
	if err := shDNS.RotateFile(pkgDir); err != nil {
		return false, nil
	}

	// 19. The software has been successfully updated.
	if skipBuild {
		fmt.Printf("package '%s' already up-to-date\n", name)
		return false, nil
	}
	return true, nil
}

// Update package with name, see specification for details.
func Update(ctx context.Context, name string) error {
	visited := make(map[string]bool)
	visited[name] = true
	_, err := update(ctx, visited, name)
	return err
}

+ f 47cbb36c4573750c55ce850b4f814e1e8fc3da7a827b660eeae0a097cb62766d vendor/github.com/frankbraun/codechain/secpkg/uptodate.go
utf8file 63
package secpkg

import (
	"context"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/frankbraun/codechain/util/homedir"
)

// UpToDateIfInstalled ensures that the package with name is up-to-date, if it is
// installed as a secure package. If the package is not installed as a secure
// package a corresponding message is shown on stderr.
func UpToDateIfInstalled(ctx context.Context, name string) error {
	needsUpdate, err := CheckUpdate(ctx, name)
	if err != nil {
		if err == ErrNotInstalled {
			fmt.Fprintf(os.Stderr, "WARNING: package '%s' not installed via `secpkg install`\n", name)
			return nil
		}
		return err
	}
	// determine path of currently running executable
	path, err := os.Executable()
	if err != nil {
		return err
	}
	localDir := filepath.Join(homedir.SecPkg(), "local")
	// issue warning if we don't actually run the installed executable
	if !strings.HasPrefix(path, localDir) {
		fmt.Fprintf(os.Stderr, "WARNING: package '%s' installed via `secpkg install`, but running different executable: %s\n",
			name, path)
	}
	// now report update needs, if necessary
	if needsUpdate {
		return fmt.Errorf("tool needs update (`secpkg update %s`)", name)
	}
	return nil
}

// UpToDate ensures that the package with name is up-to-date, if it is
// installed as a secure package. If the package is not installed as a secure
// package a corresponding message is shown on stderr.
//
// UpToDate times out after a while if DNS cannot be queried and return nil.
func UpToDate(name string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	if err := UpToDateIfInstalled(ctx, name); err != nil {
		if err, ok := err.(net.Error); ok && err.Timeout() {
			fmt.Fprintf(os.Stderr, "WARNING: update check for package '%s' timed out: %s\n",
				name, err)
			return nil
		}
		return err
	}
	return nil
}

+ f 5184def0aaab6139d1f2b966cc0f48019510692cac8c017d5aebe9bb990b9d4d vendor/github.com/frankbraun/codechain/ssot/doc.go
utf8file 200
/*
Package ssot implements a single source of truth (SSOT) with DNS TXT records.

Signed head specification

Signed heads have the following fields:

  - PUBKEY (32-byte), the Ed25519 public key of SSOT head signer.
  - PUBKEY_ROTATE (32-byte), Ed25519 pubkey to rotate to, set to 0 if unused.
  - VALID_FROM (8-byte), the signed head is valid from the given Unix time.
  - VALID_TO (8-byte), the signed head is valid to the given Unix time.
  - COUNTER (8-byte), strictly increasing signature counter.
  - HEAD, the Codechain head to sign.
  - SIGNATURE, signature with PUBKEY.

The SIGNATURE is over all previous fields:

  PUBKEY|PUBKEY_ROTATE|VALID_FROM|VALID_TO|COUNTER|HEAD

The signed head is a concatenation of

  PUBKEY|PUBKEY_ROTATE|VALID_FROM|VALID_TO|COUNTER|HEAD|SIGNATURE

encoded in base64 (URL encoding without padding).

All integers (VALID_FROM, VALID_TO, COUNTER) are encoded in network order
(big-endian).

CreatePkg specification

To create a new secure package for a project developed with Codechain that
should be distributed with a SSOT using DNS TXT records, the following
procedure is defined:

  1. Make sure the project with NAME has not been published before.
     That is, the directory ~/.config/ssotpub/pkgs/NAME does not exist.

  2. If TXT records are to be published automatically, check credentials.

  3. Test build (see TestBuild specification).

  4. Create a new .secpkg file which specifies the following:

     - The NAME of the project.
     - The fully qualified domain name (DNS) where the TXT records can be
       queried.
     - The current HEAD of the project's Codechain.

     The .secpkg file is saved to the current working directory, which is
     typically added to the root of the project's repository.

  5. Create the first signed head (see SignHead) for the current project's
     HEAD with a supplied secret key and counter set to 0.

  6. Create the directory ~/.config/ssotpub/pkgs/NAME/dists
     and save the current distribution to
      ~/.config/ssotpub/pkgs/NAME/dists/HEAD.tar.gz (`codechain createdist`).

  7. Save the signed head to ~/.config/ssotpub/pkgs/NAME/signed_head

  8. Print the distribution name: ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz

  9. Print DNS TXT records as defined by the .secpkg, the first signed head,
     and the download URL. If TXT records are to be published automatically,
     save credentials and publish the TXT record.

  Afterwards the administrator manually uploads the distribution HEAD.tar.gz
  to the download URL and publishes the new DNS TXT record in the defined
  zone (if not published automatically). DNSSEC should be enabled.

SignHead specification

To publish an update of a secure package with SSOT do the following:

   1. Parse the .secpkg file in the current working directory.

   2. Make sure the project with NAME has been published before.
      That is, the directory ~/.config/ssotpub/pkgs/NAME exists.

   3. Validate the signed head in ~/.config/ssotpub/pkgs/NAME/signed_head.

   4. Get the HEAD from .codechain/hashchain in the current working directory.

   5. If ~/.config/ssotpub/pkgs/NAME/cloudflare.json exits, check the contained
      Cloudflare credentials and switch on automatic publishing of TXT records.

   6. Test build (see TestBuild specification).

   7. If ROTATE is set, check if ~/.config/ssotput/pkgs/NAME/rotate_to exists.
      If it does, abort. Otherwise write public key to rotate to and rotate time
      (see below) to ~/.config/ssotput/pkgs/NAME/rotate_to.

   8. Create a new signed head with current HEAD, the counter of the previous
      signed head plus 1, and update the saved signed head:

      - `cp -f ~/.config/ssotpub/pkgs/NAME/signed_head
               ~/.config/ssotpub/pkgs/NAME/previous_signed_head`
      - Save new signed head to ~/.config/ssotpub/pkgs/NAME/signed_head (atomic).

      If ~/.config/ssotput/pkgs/NAME/rotate_to exists:

      - If rotate time has been reached use pubkey from file as PUBKEY and
        remove ~/.config/ssotput/pkgs/NAME/rotate_to.
      - Otherwise use old PUBKEY and set pubkey from file as PUBKEY_ROTATE.

   9. If the HEAD changed, save the current distribution to:
      ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz (`codechain createdist`).

  10. If the HEAD changed, lookup the download URL and print where to upload
      the distribution file:
      ~/.config/ssotpkg/pkgs/NAME/dists/HEAD.tar.gz

  12. Print DNS TXT record as defined by the .secpkg file and the signed head.
      If TXT records are to be published automatically, publish the TXT record.

  13. If the HEAD changed, update the .secpkg file accordingly.

  Afterwards the administrator manually uploads the distribution HEAD.tar.gz
  to the download URL and publishes the new DNS TXT record in the defined
  zone (if not published automatically). DNSSEC should be enabled.

Refresh specification

To refresh the published head of a secure package with SSOT do the following:

   1. Parse the supplied .secpkg file.

   2. Make sure the project with NAME has been published before.
      That is, the directory ~/.config/ssotpub/pkgs/NAME exists.

   3. Validate the signed head in ~/.config/ssotpub/pkgs/NAME/signed_head.

   4. Make sure the signed head in ~/.config/ssotpub/pkgs/NAME/signed_head
      matches the HEAD in the .secpkg file.

   5. If ~/.config/ssotpub/pkgs/NAME/cloudflare.json exits, check the contained
      Cloudflare credentials and switch on automatic publishing of TXT records.

   6. If ROTATE is set, check if ~/.config/ssotput/pkgs/NAME/rotate_to exists.
      If it does, abort. Otherwise write public key to rotate to and rotate time
      (see below) to ~/.config/ssotput/pkgs/NAME/rotate_to.

   7. Create a new signed head with the same HEAD, the counter of the previous
      signed head plus 1, and update the saved signed head:

      - `cp -f ~/.config/ssotpub/pkgs/NAME/signed_head
               ~/.config/ssotpub/pkgs/NAME/previous_signed_head`
      - Save new signed head to ~/.config/ssotpub/pkgs/NAME/signed_head (atomic).

      If ~/.config/ssotput/pkgs/NAME/rotate_to exists:

      - If rotate time has been reached use pubkey from file as PUBKEY and
        remove ~/.config/ssotput/pkgs/NAME/rotate_to.
      - Otherwise use old PUBKEY and set pubkey from file as PUBKEY_ROTATE.

   8. Print DNS TXT record as defined by the .secpkg file and the signed head.
      If TXT record is to be published automatically, publish the TXT record.

  Afterwards the administrator publishes the new DNS TXT record in the defined
  zone (if not published automatically). DNSSEC should be enabled.

TestBuild specification

To test the build of a secure package do the following:

   1. Create temporary directory TMPDIR with `build` and `local` subdirectories.

   2. `mkdir TMPDIR/build/.codechain`

   3. `cp .codechain/hashchain TMPDIR/build/.codechain`

   4. `cp -r .codechain/patches TMPDIR/build/.codechain`

   5. `cd TMPDIR/build`

   6. `codechain apply`

   7. `make prefix=TMPDIR/local`

   8. `make prefix=TMPDIR/local install`

   9. Make sure TMPDIR/local contains at least one file.

  10. `make prefix=TMPDIR/local uninstall`

  11. Make sure TMPDIR/local contains no files (but empty directories are OK).

  12. Delete temporary directory TMPDIR.

Rotate time calculation

The earliest time a PUBKEY_ROTATE can be used as PUBKEY is when the previous
signed head (without PUBKEY_ROTATE) has expired. This gives clients time to
learn about PUBKEY_ROTATE. To give some extra time we take the time span a
signed head with PUBKEY_ROTATE is valid after the signed head without
PUBKEY_ROTATE has expired and divide it by three. The rotate time is set to the
end of the first third.
*/
package ssot

+ f b1a4f5d0e541c82b00315b30301204f11ee84747a267dd190f6cd3da758e140d vendor/github.com/frankbraun/codechain/ssot/errors.go
utf8file 21
package ssot

import (
	"errors"
)

// ErrSignedHeadSignature is returned if a signed head signature does not verify.
var ErrSignedHeadSignature = errors.New("ssot: signed head signature does not verify")

// ErrSignedHeadFuture is returned if the validity of a signed head is in the future.
var ErrSignedHeadFuture = errors.New("ssot: signed head is valid in the future")

// ErrSignedHeadExpired is returned if the validity of a signed head is expired.
var ErrSignedHeadExpired = errors.New("ssot: signed head is expired")

// ErrValidityTooLong is returned if the validity is too long.
var ErrValidityTooLong = errors.New("ssot: validity is too long")

// ErrValidityTooShort is returned if the validity is too short.
var ErrValidityTooShort = errors.New("ssot: validity is too short")

+ f 8ebc6ada35f56ae8f3d148523a05e21219f87169752f13525ca6c5306c5f41d4 vendor/github.com/frankbraun/codechain/ssot/rotatefile.go
utf8file 40
package ssot

import (
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
)

// RotateFile rotates the pkgDir/signed_head to pkgDir/previous_signed_head and saves
// signed head sh to pkgDir/signed_head.
func (sh *SignedHead) RotateFile(pkgDir string) error {
	prevSignedHeadFile := filepath.Join(pkgDir, "previous_signed_head")
	exists, err := file.Exists(prevSignedHeadFile)
	if err != nil {
		return err
	}
	if exists {
		if err := os.Remove(prevSignedHeadFile); err != nil {
			return err
		}
	}
	signedHeadFile := filepath.Join(pkgDir, "signed_head")
	if err := file.Copy(signedHeadFile, prevSignedHeadFile); err != nil {
		return err
	}
	newSignedHeadFile := filepath.Join(pkgDir, "new_signed_head")
	err = ioutil.WriteFile(newSignedHeadFile, []byte(sh.Marshal()+"\n"), 0644)
	if err != nil {
		return err
	}
	if err := os.Rename(newSignedHeadFile, signedHeadFile); err != nil {
		return err
	}
	log.Printf("ssot: %s: written\n", signedHeadFile)
	return nil
}

+ f 2b17a6a7145187b6f558fe26a48230500d53cce9c2123e612ec1c6f53c3e4f25 vendor/github.com/frankbraun/codechain/ssot/rotateto.go
utf8file 86
package ssot

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"github.com/frankbraun/codechain/util/base64"
	utime "github.com/frankbraun/codechain/util/time"
)

func (sh *SignedHead) calculateRotateTime(validity time.Duration) int64 {
	now := utime.Now()
	rest := now - sh.validTo
	if rest < 0 {
		rest = 0
	}
	rotateIn := int64(validity/time.Second) - rest
	rotateIn /= 3
	if rotateIn < 0 {
		rotateIn = 0
	}
	return now + rotateIn
}

// WriteRotateTo writes "rotate to" file to given filename.
func (sh *SignedHead) WriteRotateTo(
	filename string,
	secKeyRotate *[64]byte,
	sigRotate *[64]byte,
	commentRotate []byte,
	validity time.Duration,
) error {
	rotateTime := sh.calculateRotateTime(validity)
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = fmt.Fprintf(f, "%s %s", base64.Encode(secKeyRotate[32:]),
		base64.Encode(sigRotate[:]))
	if err != nil {
		return err
	}
	if commentRotate != nil {
		_, err := fmt.Fprintf(f, " %s", commentRotate)
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprintf(f, "\n%s\n", utime.Format(rotateTime))
	if err != nil {
		return err
	}
	return nil
}

// ReadRotateTo reads "rotate to" file from given filename and returns the
// public key to rotate to and a bool indicating if the rotation time has been
// reached.
func ReadRotateTo(filename string) (string, bool, error) {
	c, err := ioutil.ReadFile(filename)
	if err != nil {
		return "", false, err
	}
	lines := bytes.SplitN(c, []byte("\n"), 2)
	line0 := strings.SplitN(string(lines[0]), " ", 3)
	line1 := string(bytes.TrimSpace(lines[1]))
	if _, err := base64.Decode(line0[0], 32); err != nil {
		return "", false, err
	}
	rotateTo := line0[0]
	rotateTime, err := utime.Parse(line1)
	if err != nil {
		return "", false, err
	}
	var reached bool
	if rotateTime <= utime.Now() {
		reached = true
	}
	return rotateTo, reached, nil
}

+ f 8b6058159b1af653c8c18b9e8deaf885c01a1e3abaad3f91644f13ed1ce7c829 vendor/github.com/frankbraun/codechain/ssot/signhead.go
utf8file 38
package ssot

import (
	"time"

	"crypto/ed25519"
)

// SignHead signs the given Codechain head.
func SignHead(
	head [32]byte,
	counter uint64,
	secKey [64]byte,
	pubKeyRotate *[32]byte,
	validity time.Duration,
) (*SignedHead, error) {
	var sh SignedHead
	copy(sh.pubKey[:], secKey[32:])
	if pubKeyRotate != nil {
		copy(sh.pubKeyRotate[:], pubKeyRotate[:])
	}
	now := time.Now().UTC().Unix()
	sh.validFrom = now
	if validity > MaximumValidity {
		return nil, ErrValidityTooLong
	}
	if validity < MinimumValidity {
		return nil, ErrValidityTooShort
	}
	sh.validTo = now + int64(validity/time.Second)
	sh.counter = counter
	copy(sh.head[:], head[:])
	msg := sh.marshal()
	sig := ed25519.Sign(secKey[:], msg[:])
	copy(sh.signature[:], sig)
	return &sh, nil
}

+ f 0aa96e87534d6b3104fb56d1a34d3df6f58a891a0de01d22efcbcc6f4ff31c60 vendor/github.com/frankbraun/codechain/ssot/ssot.go
utf8file 223
package ssot

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"encoding/binary"
	"errors"
	"fmt"
	"io/ioutil"
	"net"
	"net/url"
	"os"
	"time"

	"github.com/fatih/color"
	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/hex"
	"github.com/frankbraun/codechain/util/log"
)

// File defines the default file name for a signed head.
const File = "signed_head"

// MaximumValidity of signed heads.
const MaximumValidity = 30 * 24 * time.Hour // 30d

// MinimumValidity of signed heads.
const MinimumValidity = 1 * time.Hour // 1h

// TTL of signed head TXT records
const TTL = 600 // 10m

// SignedHead is a signed Codechain head ready for publication as a SSOT with
// DNS TXT records.
type SignedHead struct {
	pubKey       [32]byte // Ed25519 public key of SSOT head signer
	pubKeyRotate [32]byte // Ed25519 pubkey to rotate to, all 0 if unused
	validFrom    int64    // this signed head is valid from the given Unix time
	validTo      int64    // this signed head is valid to the given Unix time
	counter      uint64   // signature counter
	head         [32]byte // the Codechain head to sign
	signature    [64]byte // signature with pubkey over all previous fields
}

// marshal signed head without signature.
func (sh *SignedHead) marshal() [120]byte {
	var m [120]byte
	var b [8]byte
	copy(m[:32], sh.pubKey[:])
	copy(m[32:64], sh.pubKeyRotate[:])
	binary.BigEndian.PutUint64(b[:], uint64(sh.validFrom))
	copy(m[64:72], b[:])
	binary.BigEndian.PutUint64(b[:], uint64(sh.validTo))
	copy(m[72:80], b[:])
	binary.BigEndian.PutUint64(b[:], sh.counter)
	copy(m[80:88], b[:])
	copy(m[88:120], sh.head[:])
	return m
}

// Marshal signed head with signature and encode it as base64.
func (sh *SignedHead) Marshal() string {
	var m [184]byte
	b := sh.marshal()
	copy(m[:120], b[:])
	copy(m[120:184], sh.signature[:])
	return base64.Encode(m[:])
}

// MarshalText marshals signed head as text (for status output).
func (sh *SignedHead) MarshalText() string {
	var (
		b       bytes.Buffer
		expired string
	)
	validFrom := time.Unix(sh.validFrom, 0)
	validTo := time.Unix(sh.validTo, 0)
	if err := sh.Valid(); err == ErrSignedHeadExpired {
		expired = color.RedString(" EXPIRED!")
	}
	fmt.Fprintf(&b, "PUBKEY:        %s\n", base64.Encode(sh.pubKey[:]))
	fmt.Fprintf(&b, "PUBKEY_ROTATE: %s\n", base64.Encode(sh.pubKeyRotate[:]))
	fmt.Fprintf(&b, "VALID_FROM:    %s\n", validFrom.Format(time.RFC3339))
	fmt.Fprintf(&b, "VALID_TO:      %s%s\n", validTo.Format(time.RFC3339), expired)
	fmt.Fprintf(&b, "COUNTER:       %d\n", sh.counter)
	fmt.Fprintf(&b, "HEAD:          %s\n", hex.Encode(sh.head[:]))
	fmt.Fprintf(&b, "SIGNATURE:     %s\n", base64.Encode(sh.signature[:]))
	return b.String()
}

func unmarshal(m [184]byte) (*SignedHead, error) {
	var sh SignedHead
	copy(sh.pubKey[:], m[:32])
	copy(sh.pubKeyRotate[:], m[32:64])
	sh.validFrom = int64(binary.BigEndian.Uint64(m[64:72]))
	sh.validTo = int64(binary.BigEndian.Uint64(m[72:80]))
	sh.counter = binary.BigEndian.Uint64(m[80:88])
	copy(sh.head[:], m[88:120])
	copy(sh.signature[:], m[120:184])
	msg := sh.marshal()
	if !ed25519.Verify(sh.pubKey[:], msg[:], sh.signature[:]) {
		return nil, ErrSignedHeadSignature
	}
	return &sh, nil
}

// Unmarshal and verify a base64 encoded signed head.
func Unmarshal(signedHead string) (*SignedHead, error) {
	b, err := base64.Decode(signedHead, 184)
	if err != nil {
		return nil, err
	}
	var m [184]byte
	copy(m[:], b)
	return unmarshal(m)
}

// Load and verify a base64 encoded signed head from filename.
func Load(filename string) (*SignedHead, error) {
	b, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	sh, err := Unmarshal(string(b))
	if err != nil {
		return nil, err
	}
	return sh, nil
}

// LookupHead and verify base64 encoded signed head from dns.
func LookupHead(ctx context.Context, dns string) (*SignedHead, error) {
	txts, err := net.DefaultResolver.LookupTXT(ctx, def.CodechainHeadName+dns)
	if err != nil {
		return nil, err
	}
	var sh *SignedHead
	for _, txt := range txts {
		// parse TXT records and look for signed head
		sh, err = Unmarshal(txt)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ssot: cannot unmarshal: %s\n", txt)
			sh = nil // reset head (invalid)
			continue // try next TXT record
		}
		log.Printf("ssot: signed head found: %s\n", sh.Head())
		if err := sh.Valid(); err != nil {
			fmt.Printf("ssot: not valid: %v\n", err)
			sh = nil // reset head (invalid)
			continue // try next TXT record
		}
		break // valid TXT record found
	}
	if sh == nil {
		return nil, errors.New("ssot: no valid TXT record for head found")
	}
	return sh, nil
}

// LookupURL looks up URL from dns and returns it.
func LookupURL(ctx context.Context, dns string) (string, error) {
	txts, err := net.DefaultResolver.LookupTXT(ctx, def.CodechainURLName+dns)
	if err != nil {
		return "", err
	}
	var URL string
	for _, txt := range txts {
		// parse TXT records as URL
		if _, err := url.Parse(txt); err != nil {
			fmt.Fprintf(os.Stderr, "cannot parse as URL: %s\n", txt)
			continue
		}
		URL = txt
		fmt.Printf("URL found: %s\n", URL)
		break // valid TXT record found
	}
	if URL == "" {
		return "", errors.New("ssot: no valid TXT record for URL found")
	}
	return URL, nil
}

// Head returns the signed head.
func (sh *SignedHead) Head() string {
	return hex.Encode(sh.head[:])
}

// PubKey returns the public key in base64 notation.
func (sh *SignedHead) PubKey() string {
	return base64.Encode(sh.pubKey[:])
}

// PubKeyRotate returns the public key rotate in base64 notation.
func (sh *SignedHead) PubKeyRotate() string {
	return base64.Encode(sh.pubKeyRotate[:])
}

// Counter returns the counter of signed head.
func (sh *SignedHead) Counter() uint64 {
	return sh.counter
}

// HeadBuf returns the signed head.
func (sh *SignedHead) HeadBuf() [32]byte {
	var b [32]byte
	copy(b[:], sh.head[:])
	return b
}

// TXTPrintHead prints the TXT record to publish the signed head.
func (sh *SignedHead) TXTPrintHead(dns string) {
	fmt.Printf("%s%s.\t\t%d\tIN\tTXT\t\"%s\"\n",
		def.CodechainHeadName, dns, TTL, sh.Marshal())
}

// TXTPrintURL prints the TXT record to publish the url.
func TXTPrintURL(dns, url string) {
	fmt.Printf("%s%s.\t\t%d\tIN\tTXT\t\"%s\"\n",
		def.CodechainURLName, dns, TTL, url)
}

+ f 35338c197961189a09be26f8e4c0bc63480051640761d989200b2ac34a4eeb27 vendor/github.com/frankbraun/codechain/ssot/valid.go
utf8file 20
package ssot

import (
	"time"
)

// Valid checks if the signed head sh is currently valid
// (as defined by validFrom and validTo).
// It returns nil, if the signed check is valid and an error otherwise.
func (sh *SignedHead) Valid() error {
	now := time.Now().UTC().Unix()
	if now < sh.validFrom {
		return ErrSignedHeadFuture
	}
	if now > sh.validTo {
		return ErrSignedHeadExpired
	}
	return nil
}

+ f 68d2f96820b34425a1027cc173f171311fbeafbf161471926ccf7a09d4ebee81 vendor/github.com/frankbraun/codechain/util/gnumake/gnumake.go
utf8file 36
// Package gnumake contains wrappers around some GNU make commands.
package gnumake

import (
	"fmt"
	"os"
	"os/exec"
)

// Call 'make' with prefix=prefix.
func Call(prefix string) error {
	prefixStr := fmt.Sprintf("prefix=%s", prefix)
	cmd := exec.Command("make", prefixStr)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Install calls 'make install' with prefix=prefix.
func Install(prefix string) error {
	prefixStr := fmt.Sprintf("prefix=%s", prefix)
	cmd := exec.Command("make", prefixStr, "install")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Uninstall calls 'make uninstall' with prefix=prefix.
func Uninstall(prefix string) error {
	prefixStr := fmt.Sprintf("prefix=%s", prefix)
	cmd := exec.Command("make", prefixStr, "uninstall")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

+ f dc6d1d924696adc5f08663792e2375e50dff65c8381fcd2bae8e8407a91a957e vendor/github.com/frankbraun/codechain/util/home/appdata.go
utf8file 120
// Copyright (c) 2013-2017 The btcsuite developers
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

// Source: https://github.com/btcsuite/btcutil/blob/master/appdata.go

// Package home provides utility methods for application specific home
// directories.
package home

import (
	"os"
	"os/user"
	"path/filepath"
	"runtime"
	"strings"
	"unicode"
)

// appDataDir returns an operating system specific directory to be used for
// storing application data for an application.  See AppDataDir for more
// details.  This unexported version takes an operating system argument
// primarily to enable the testing package to properly test the function by
// forcing an operating system that is not the currently one.
func appDataDir(goos, appName string, roaming bool) string {
	if appName == "" || appName == "." {
		return "."
	}

	// The caller really shouldn't prepend the appName with a period, but
	// if they do, handle it gracefully by trimming it.
	appName = strings.TrimPrefix(appName, ".")
	appNameUpper := string(unicode.ToUpper(rune(appName[0]))) + appName[1:]
	appNameLower := string(unicode.ToLower(rune(appName[0]))) + appName[1:]

	// Get the OS specific home directory via the Go standard lib.
	var homeDir string
	usr, err := user.Current()
	if err == nil {
		homeDir = usr.HomeDir
	}

	// Fall back to standard HOME environment variable that works
	// for most POSIX OSes if the directory from the Go standard
	// lib failed.
	if err != nil || homeDir == "" {
		homeDir = os.Getenv("HOME")
	}

	switch goos {
	// Attempt to use the LOCALAPPDATA or APPDATA environment variable on
	// Windows.
	case "windows":
		// Windows XP and before didn't have a LOCALAPPDATA, so fallback
		// to regular APPDATA when LOCALAPPDATA is not set.
		appData := os.Getenv("LOCALAPPDATA")
		if roaming || appData == "" {
			appData = os.Getenv("APPDATA")
		}

		if appData != "" {
			return filepath.Join(appData, appNameUpper)
		}

	case "darwin":
		if homeDir != "" {
			return filepath.Join(homeDir, "Library",
				"Application Support", appNameUpper)
		}

	case "plan9":
		if homeDir != "" {
			return filepath.Join(homeDir, appNameLower)
		}

	default:
		if homeDir != "" {
			return filepath.Join(homeDir, ".config", appNameLower)
		}
	}

	// Fall back to the current directory if all else fails.
	return "."
}

// AppDataDir returns an operating system specific directory to be used for
// storing application data for an application.
//
// The appName parameter is the name of the application the data directory is
// being requested for.  This function will prepend a period to the appName for
// POSIX style operating systems since that is standard practice.  An empty
// appName or one with a single dot is treated as requesting the current
// directory so only "." will be returned.  Further, the first character
// of appName will be made lowercase for POSIX style operating systems and
// uppercase for Mac and Windows since that is standard practice.
//
// The roaming parameter only applies to Windows where it specifies the roaming
// application data profile (%APPDATA%) should be used instead of the local one
// (%LOCALAPPDATA%) that is used by default.
//
// Example results:
//  dir := AppDataDir("myapp", false)
//   POSIX (Linux/BSD): ~/.config/myapp
//   Mac OS: $HOME/Library/Application Support/Myapp
//   Windows: %LOCALAPPDATA%\Myapp
//   Plan 9: $home/myapp
func AppDataDir(appName string, roaming bool) string {
	return appDataDir(runtime.GOOS, appName, roaming)
}

+ f 515608b72ba20dca0e700a467b122b2fc190b0fd629904d29627a4dc803a1b3f vendor/github.com/frankbraun/codechain/util/homedir/homedir.go
utf8file 39
// Package homedir implements helper methods to get the home directories of
// various tools.
package homedir

import (
	"os"
	"strings"

	"github.com/frankbraun/codechain/util/home"
	"github.com/frankbraun/codechain/util/log"
)

// Get returns the home directory for the given app name.
func Get(app string) string {
	env := strings.ToUpper(app) + "HOMEDIR"
	if homeDir := os.Getenv(env); homeDir != "" {
		log.Printf("$%s=%s", env, homeDir)
		return homeDir
	}
	homeDir := home.AppDataDir(app, false)
	log.Printf("homeDir: %s", homeDir)
	return homeDir
}

// Codechain returns the home directory for 'codechain'.
func Codechain() string {
	return Get("codechain")
}

// SecPkg returns the home directory for 'secpkg'.
func SecPkg() string {
	return Get("secpkg")
}

// SSOTPub returns the home directory for 'ssotpub'.
func SSOTPub() string {
	return Get("ssotpub")
}

- f 71d8792e3b18d51476f8016111f58d6e8bc82e67b3f2c9c266abd03b244300c8 vendor/github.com/mattn/go-isatty/.travis.yml
+ f 2b32753ea2d62f0050749505ca9701e8500d37d2be5363fcde0bcadc0da87b69 vendor/github.com/mattn/go-isatty/.travis.yml
dmppatch 20
@@ -10,12 +10,35 @@
  go%0A
+sudo: false%0A
 go:%0A
+  - 1.13.x%0A
   - 
@@ -46,31 +46,8 @@
 ip%0A%0A
-os:%0A  - linux%0A  - osx%0A%0A
 befo
@@ -62,94 +62,40 @@
 ll:%0A
-  - go get github.com/mattn/goveralls%0A  - go get golang.org/x/tools/cmd/cover%0A
+  - go get -t -v ./...%0A%0A
 script:%0A
   - 
@@ -94,80 +94,81 @@
 pt:%0A
-  - $HOME/gopath/bin/goveralls -repotoken 3gHdORO5k5ziZcWMBxnd9LrMZaJs8m9x5%0A
+  - ./go.test.sh%0A%0Aafter_success:%0A  - bash %3C(curl -s https://codecov.io/bash)%0A
- f 65c905383882592539f246600e8ac35223a6a8ab3474274017718ff812903b82 vendor/github.com/mattn/go-isatty/README.md
+ f e4637bdbfc367bce541dc4131d2fb1a6e036f839b502b0e12a5c72e2f24f5d1e vendor/github.com/mattn/go-isatty/README.md
dmppatch 5
@@ -133,122 +133,129 @@
 ty)%0A
-%5B!%5BBuild Status%5D(https://travis-ci.org/mattn/go-isatty.svg?branch=master)%5D(https://travis-ci.org/mattn/go-isatty)%0A
+%5B!%5BCodecov%5D(https://codecov.io/gh/mattn/go-isatty/branch/master/graph/badge.svg)%5D(https://codecov.io/gh/mattn/go-isatty)%0A
 %5B!%5BC
- f fa4f67fef16cdebef54b24e43e01f8ad2a6ddc2db3c42e02caa432491bb39b20 vendor/github.com/mattn/go-isatty/go.mod
+ f 1a062e56c0266d004bea51115acf8c2b597d1407ca55ad56cce01e97ada3da4b vendor/github.com/mattn/go-isatty/go.mod
dmppatch 4
@@ -41,64 +41,64 @@
 12%0A%0A
-require golang.org/x/sys v0.0.0-20191026070338-33540a1f6037%0A
+require golang.org/x/sys v0.0.0-20200116001909-b77594299b42%0A
- f 6481a3e0f0881d388779f682e9d0ea88eee8bd8db37105707ea01c1a3e4c6402 vendor/github.com/mattn/go-isatty/go.sum
+ f f096823e49689a6a55b7bba1fe01c233c5855df82e1f1f1b6d09a915d56dc8d7 vendor/github.com/mattn/go-isatty/go.sum
dmppatch 3
@@ -1,207 +1,207 @@
-golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4=%0Agolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0A
+golang.org/x/sys v0.0.0-20200116001909-b77594299b42 h1:vEOn+mP2zCOVzKckCZy6YsCtDblrpj/w7B9nxGNELpg=%0Agolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0A
+ f 827af55d528924cbeb7f0702b91148bcd9d1707160718ba6d13efa8ad863b821 vendor/github.com/mattn/go-isatty/go.test.sh
utf8file 13
#!/usr/bin/env bash

set -e
echo "" > coverage.txt

for d in $(go list ./... | grep -v vendor); do
    go test -race -coverprofile=profile.out -covermode=atomic "$d"
    if [ -f profile.out ]; then
        cat profile.out >> coverage.txt
        rm profile.out
    fi
done

- f 399480e4631e770511246c5a96b9e85ff01101d54a0f8ac55d6dde826eeac833 vendor/github.com/mattn/go-isatty/isatty_android.go
- f 1008e3ece64fb5ae5707d4fce2774d1114439f1ae9fc2e9187e0c41b013e2091 vendor/github.com/mattn/go-isatty/isatty_bsd.go
+ f 4d176981801b6cb3344b89eb35990e98e76fb2f2ac08674d1823b65796198da2 vendor/github.com/mattn/go-isatty/isatty_bsd.go
dmppatch 10
@@ -85,83 +85,39 @@
 ty%0A%0A
-import (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Aconst ioctlReadTermios = syscall.TIOCGETA%0A
+import %22golang.org/x/sys/unix%22%0A
 %0A// 
@@ -214,170 +214,83 @@
 l %7B%0A
-%09var termios syscall.Termios%0A%09_, _, err := syscall.Syscall6(syscall.SYS_IOCTL, fd, ioctlReadTermios, uintptr(unsafe.Pointer(&termios)), 0, 0, 0)%0A%09return err == 0%0A
+%09_, err := unix.IoctlGetTermios(int(fd), unix.TIOCGETA)%0A%09return err == nil%0A
 %7D%0A%0A/
- f 32c1a666cdf28497e94e76f299bee9a7c0fa9f5d6828b2d902c2a7db25d4fe61 vendor/github.com/mattn/go-isatty/isatty_tcgets.go
+ f 43a6c635ac17741bd3c640798114c85d92b2a659c2e0afdd393a90dabeecd310 vendor/github.com/mattn/go-isatty/isatty_tcgets.go
dmppatch 4
@@ -38,27 +38,8 @@
 ine%0A
-// +build !android%0A
 %0Apac
+ f 96e1663d9b8ba09579d1aa914cd2454b3acfbdfbff3370dcaaad52c44052c1ac vendor/github.com/mattn/go-isatty/renovate.json
utf8file 9
{
  "extends": [
    "config:base"
  ],
  "postUpdateOptions": [
    "gomodTidy"
  ]
}

+ f 3417d21c5fdd8193510233ec062e40a2cdb30bc50296313ac4d72c4d00d675c1 vendor/golang.org/x/crypto/internal/subtle/aliasing.go
utf8file 33
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !appengine

// Package subtle implements functions that are often useful in cryptographic
// code but require careful thought to use correctly.
package subtle // import "golang.org/x/crypto/internal/subtle"

import "unsafe"

// AnyOverlap reports whether x and y share memory at any (not necessarily
// corresponding) index. The memory beyond the slice length is ignored.
func AnyOverlap(x, y []byte) bool {
	return len(x) > 0 && len(y) > 0 &&
		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
}

// InexactOverlap reports whether x and y share memory at any non-corresponding
// index. The memory beyond the slice length is ignored. Note that x and y can
// have different lengths and still not have any inexact overlap.
//
// InexactOverlap can be used to implement the requirements of the crypto/cipher
// AEAD, Block, BlockMode and Stream interfaces.
func InexactOverlap(x, y []byte) bool {
	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
		return false
	}
	return AnyOverlap(x, y)
}

+ f 7795ac254dcf9128ee1030558907c4507df05597a5a3ab32ec987e08940d9c08 vendor/golang.org/x/crypto/internal/subtle/aliasing_appengine.go
utf8file 36
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build appengine

// Package subtle implements functions that are often useful in cryptographic
// code but require careful thought to use correctly.
package subtle // import "golang.org/x/crypto/internal/subtle"

// This is the Google App Engine standard variant based on reflect
// because the unsafe package and cgo are disallowed.

import "reflect"

// AnyOverlap reports whether x and y share memory at any (not necessarily
// corresponding) index. The memory beyond the slice length is ignored.
func AnyOverlap(x, y []byte) bool {
	return len(x) > 0 && len(y) > 0 &&
		reflect.ValueOf(&x[0]).Pointer() <= reflect.ValueOf(&y[len(y)-1]).Pointer() &&
		reflect.ValueOf(&y[0]).Pointer() <= reflect.ValueOf(&x[len(x)-1]).Pointer()
}

// InexactOverlap reports whether x and y share memory at any non-corresponding
// index. The memory beyond the slice length is ignored. Note that x and y can
// have different lengths and still not have any inexact overlap.
//
// InexactOverlap can be used to implement the requirements of the crypto/cipher
// AEAD, Block, BlockMode and Stream interfaces.
func InexactOverlap(x, y []byte) bool {
	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
		return false
	}
	return AnyOverlap(x, y)
}

+ f cdfe9638276aeaa95f9f69d8c31e2aa078da2aa3985eac2b00f0d15b7f427eb3 vendor/golang.org/x/crypto/nacl/secretbox/secretbox.go
utf8file 174
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
Package secretbox encrypts and authenticates small messages.

Secretbox uses XSalsa20 and Poly1305 to encrypt and authenticate messages with
secret-key cryptography. The length of messages is not hidden.

It is the caller's responsibility to ensure the uniqueness of noncesfor
example, by using nonce 1 for the first message, nonce 2 for the second
message, etc. Nonces are long enough that randomly generated nonces have
negligible risk of collision.

Messages should be small because:

1. The whole message needs to be held in memory to be processed.

2. Using large messages pressures implementations on small machines to decrypt
and process plaintext before authenticating it. This is very dangerous, and
this API does not allow it, but a protocol that uses excessive message sizes
might present some implementations with no other choice.

3. Fixed overheads will be sufficiently amortised by messages as small as 8KB.

4. Performance may be improved by working with messages that fit into data caches.

Thus large amounts of data should be chunked so that each message is small.
(Each message still needs a unique nonce.) If in doubt, 16KB is a reasonable
chunk size.

This package is interoperable with NaCl: https://nacl.cr.yp.to/secretbox.html.
*/
package secretbox // import "golang.org/x/crypto/nacl/secretbox"

import (
	"golang.org/x/crypto/internal/subtle"
	"golang.org/x/crypto/poly1305"
	"golang.org/x/crypto/salsa20/salsa"
)

// Overhead is the number of bytes of overhead when boxing a message.
const Overhead = poly1305.TagSize

// setup produces a sub-key and Salsa20 counter given a nonce and key.
func setup(subKey *[32]byte, counter *[16]byte, nonce *[24]byte, key *[32]byte) {
	// We use XSalsa20 for encryption so first we need to generate a
	// key and nonce with HSalsa20.
	var hNonce [16]byte
	copy(hNonce[:], nonce[:])
	salsa.HSalsa20(subKey, &hNonce, key, &salsa.Sigma)

	// The final 8 bytes of the original nonce form the new nonce.
	copy(counter[:], nonce[16:])
}

// sliceForAppend takes a slice and a requested number of bytes. It returns a
// slice with the contents of the given slice followed by that many bytes and a
// second slice that aliases into it and contains only the extra bytes. If the
// original slice has sufficient capacity then no allocation is performed.
func sliceForAppend(in []byte, n int) (head, tail []byte) {
	if total := len(in) + n; cap(in) >= total {
		head = in[:total]
	} else {
		head = make([]byte, total)
		copy(head, in)
	}
	tail = head[len(in):]
	return
}

// Seal appends an encrypted and authenticated copy of message to out, which
// must not overlap message. The key and nonce pair must be unique for each
// distinct message and the output will be Overhead bytes longer than message.
func Seal(out, message []byte, nonce *[24]byte, key *[32]byte) []byte {
	var subKey [32]byte
	var counter [16]byte
	setup(&subKey, &counter, nonce, key)

	// The Poly1305 key is generated by encrypting 32 bytes of zeros. Since
	// Salsa20 works with 64-byte blocks, we also generate 32 bytes of
	// keystream as a side effect.
	var firstBlock [64]byte
	salsa.XORKeyStream(firstBlock[:], firstBlock[:], &counter, &subKey)

	var poly1305Key [32]byte
	copy(poly1305Key[:], firstBlock[:])

	ret, out := sliceForAppend(out, len(message)+poly1305.TagSize)
	if subtle.AnyOverlap(out, message) {
		panic("nacl: invalid buffer overlap")
	}

	// We XOR up to 32 bytes of message with the keystream generated from
	// the first block.
	firstMessageBlock := message
	if len(firstMessageBlock) > 32 {
		firstMessageBlock = firstMessageBlock[:32]
	}

	tagOut := out
	out = out[poly1305.TagSize:]
	for i, x := range firstMessageBlock {
		out[i] = firstBlock[32+i] ^ x
	}
	message = message[len(firstMessageBlock):]
	ciphertext := out
	out = out[len(firstMessageBlock):]

	// Now encrypt the rest.
	counter[8] = 1
	salsa.XORKeyStream(out, message, &counter, &subKey)

	var tag [poly1305.TagSize]byte
	poly1305.Sum(&tag, ciphertext, &poly1305Key)
	copy(tagOut, tag[:])

	return ret
}

// Open authenticates and decrypts a box produced by Seal and appends the
// message to out, which must not overlap box. The output will be Overhead
// bytes smaller than box.
func Open(out, box []byte, nonce *[24]byte, key *[32]byte) ([]byte, bool) {
	if len(box) < Overhead {
		return nil, false
	}

	var subKey [32]byte
	var counter [16]byte
	setup(&subKey, &counter, nonce, key)

	// The Poly1305 key is generated by encrypting 32 bytes of zeros. Since
	// Salsa20 works with 64-byte blocks, we also generate 32 bytes of
	// keystream as a side effect.
	var firstBlock [64]byte
	salsa.XORKeyStream(firstBlock[:], firstBlock[:], &counter, &subKey)

	var poly1305Key [32]byte
	copy(poly1305Key[:], firstBlock[:])
	var tag [poly1305.TagSize]byte
	copy(tag[:], box)

	if !poly1305.Verify(&tag, box[poly1305.TagSize:], &poly1305Key) {
		return nil, false
	}

	ret, out := sliceForAppend(out, len(box)-Overhead)
	if subtle.AnyOverlap(out, box) {
		panic("nacl: invalid buffer overlap")
	}

	// We XOR up to 32 bytes of box with the keystream generated from
	// the first block.
	box = box[Overhead:]
	firstMessageBlock := box
	if len(firstMessageBlock) > 32 {
		firstMessageBlock = firstMessageBlock[:32]
	}
	for i, x := range firstMessageBlock {
		out[i] = firstBlock[32+i] ^ x
	}

	box = box[len(firstMessageBlock):]
	out = out[len(firstMessageBlock):]

	// Now decrypt the rest.
	counter[8] = 1
	salsa.XORKeyStream(out, box, &counter, &subKey)

	return ret, true
}

+ f 3c62cc27a070700ef4d6458fc05ee595a6619c4fb055f735762bfdfcdca93be6 vendor/golang.org/x/crypto/poly1305/bits_compat.go
utf8file 40
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !go1.13

package poly1305

// Generic fallbacks for the math/bits intrinsics, copied from
// src/math/bits/bits.go. They were added in Go 1.12, but Add64 and Sum64 had
// variable time fallbacks until Go 1.13.

func bitsAdd64(x, y, carry uint64) (sum, carryOut uint64) {
	sum = x + y + carry
	carryOut = ((x & y) | ((x | y) &^ sum)) >> 63
	return
}

func bitsSub64(x, y, borrow uint64) (diff, borrowOut uint64) {
	diff = x - y - borrow
	borrowOut = ((^x & y) | (^(x ^ y) & diff)) >> 63
	return
}

func bitsMul64(x, y uint64) (hi, lo uint64) {
	const mask32 = 1<<32 - 1
	x0 := x & mask32
	x1 := x >> 32
	y0 := y & mask32
	y1 := y >> 32
	w0 := x0 * y0
	t := x1*y0 + w0>>32
	w1 := t & mask32
	w2 := t >> 32
	w1 += x0 * y1
	hi = x1*y1 + w2 + w1>>32
	lo = x * y
	return
}

+ f 5f05a4b2b6f37c22794c906c39d8c04da9de0e7b5fb6e2784ea3202e1816fd53 vendor/golang.org/x/crypto/poly1305/bits_go1.13.go
utf8file 22
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.13

package poly1305

import "math/bits"

func bitsAdd64(x, y, carry uint64) (sum, carryOut uint64) {
	return bits.Add64(x, y, carry)
}

func bitsSub64(x, y, borrow uint64) (diff, borrowOut uint64) {
	return bits.Sub64(x, y, borrow)
}

func bitsMul64(x, y uint64) (hi, lo uint64) {
	return bits.Mul64(x, y)
}

+ f 48b77d89600bee71e59e6ab9a3734a1afe783f5b224b847d7303b2bd2fbb4f11 vendor/golang.org/x/crypto/poly1305/mac_noasm.go
utf8file 12
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !amd64,!ppc64le gccgo appengine

package poly1305

type mac struct{ macGeneric }

func newMAC(key *[32]byte) mac { return mac{newMACGeneric(key)} }

+ f aa54613f7082f35c4307c57c09eff105b8df5fea633c181a44b3d208a7852f57 vendor/golang.org/x/crypto/poly1305/poly1305.go
utf8file 90
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package poly1305 implements Poly1305 one-time message authentication code as
// specified in https://cr.yp.to/mac/poly1305-20050329.pdf.
//
// Poly1305 is a fast, one-time authentication function. It is infeasible for an
// attacker to generate an authenticator for a message without the key. However, a
// key must only be used for a single message. Authenticating two different
// messages with the same key allows an attacker to forge authenticators for other
// messages with the same key.
//
// Poly1305 was originally coupled with AES in order to make Poly1305-AES. AES was
// used with a fixed key in order to generate one-time keys from an nonce.
// However, in this package AES isn't used and the one-time key is specified
// directly.
package poly1305 // import "golang.org/x/crypto/poly1305"

import "crypto/subtle"

// TagSize is the size, in bytes, of a poly1305 authenticator.
const TagSize = 16

// Sum generates an authenticator for msg using a one-time key and puts the
// 16-byte result into out. Authenticating two different messages with the same
// key allows an attacker to forge messages at will.
func Sum(out *[16]byte, m []byte, key *[32]byte) {
	sum(out, m, key)
}

// Verify returns true if mac is a valid authenticator for m with the given key.
func Verify(mac *[16]byte, m []byte, key *[32]byte) bool {
	var tmp [16]byte
	Sum(&tmp, m, key)
	return subtle.ConstantTimeCompare(tmp[:], mac[:]) == 1
}

// New returns a new MAC computing an authentication
// tag of all data written to it with the given key.
// This allows writing the message progressively instead
// of passing it as a single slice. Common users should use
// the Sum function instead.
//
// The key must be unique for each message, as authenticating
// two different messages with the same key allows an attacker
// to forge messages at will.
func New(key *[32]byte) *MAC {
	return &MAC{
		mac:       newMAC(key),
		finalized: false,
	}
}

// MAC is an io.Writer computing an authentication tag
// of the data written to it.
//
// MAC cannot be used like common hash.Hash implementations,
// because using a poly1305 key twice breaks its security.
// Therefore writing data to a running MAC after calling
// Sum causes it to panic.
type MAC struct {
	mac // platform-dependent implementation

	finalized bool
}

// Size returns the number of bytes Sum will return.
func (h *MAC) Size() int { return TagSize }

// Write adds more data to the running message authentication code.
// It never returns an error.
//
// It must not be called after the first call of Sum.
func (h *MAC) Write(p []byte) (n int, err error) {
	if h.finalized {
		panic("poly1305: write to MAC after Sum")
	}
	return h.mac.Write(p)
}

// Sum computes the authenticator of all data written to the
// message authentication code.
func (h *MAC) Sum(b []byte) []byte {
	var mac [TagSize]byte
	h.mac.Sum(&mac)
	h.finalized = true
	return append(b, mac[:]...)
}

+ f 3bd974d2e3c9c1209bb83e596eed6637be5245cc8734e00bee3c06dee6569885 vendor/golang.org/x/crypto/poly1305/sum_amd64.go
utf8file 59
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!gccgo,!appengine

package poly1305

//go:noescape
func update(state *macState, msg []byte)

func sum(out *[16]byte, m []byte, key *[32]byte) {
	h := newMAC(key)
	h.Write(m)
	h.Sum(out)
}

func newMAC(key *[32]byte) (h mac) {
	initialize(key, &h.r, &h.s)
	return
}

// mac is a wrapper for macGeneric that redirects calls that would have gone to
// updateGeneric to update.
//
// Its Write and Sum methods are otherwise identical to the macGeneric ones, but
// using function pointers would carry a major performance cost.
type mac struct{ macGeneric }

func (h *mac) Write(p []byte) (int, error) {
	nn := len(p)
	if h.offset > 0 {
		n := copy(h.buffer[h.offset:], p)
		if h.offset+n < TagSize {
			h.offset += n
			return nn, nil
		}
		p = p[n:]
		h.offset = 0
		update(&h.macState, h.buffer[:])
	}
	if n := len(p) - (len(p) % TagSize); n > 0 {
		update(&h.macState, p[:n])
		p = p[n:]
	}
	if len(p) > 0 {
		h.offset += copy(h.buffer[h.offset:], p)
	}
	return nn, nil
}

func (h *mac) Sum(out *[16]byte) {
	state := h.macState
	if h.offset > 0 {
		update(&state, h.buffer[:h.offset])
	}
	finalize(out, &state.h, &state.s)
}

+ f f6ae2f91df32ea29715284de9b34516321ccd1f10041a660495e65f4c2544e16 vendor/golang.org/x/crypto/poly1305/sum_amd64.s
utf8file 109
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!gccgo,!appengine

#include "textflag.h"

#define POLY1305_ADD(msg, h0, h1, h2) \
	ADDQ 0(msg), h0;  \
	ADCQ 8(msg), h1;  \
	ADCQ $1, h2;      \
	LEAQ 16(msg), msg

#define POLY1305_MUL(h0, h1, h2, r0, r1, t0, t1, t2, t3) \
	MOVQ  r0, AX;                  \
	MULQ  h0;                      \
	MOVQ  AX, t0;                  \
	MOVQ  DX, t1;                  \
	MOVQ  r0, AX;                  \
	MULQ  h1;                      \
	ADDQ  AX, t1;                  \
	ADCQ  $0, DX;                  \
	MOVQ  r0, t2;                  \
	IMULQ h2, t2;                  \
	ADDQ  DX, t2;                  \
	                               \
	MOVQ  r1, AX;                  \
	MULQ  h0;                      \
	ADDQ  AX, t1;                  \
	ADCQ  $0, DX;                  \
	MOVQ  DX, h0;                  \
	MOVQ  r1, t3;                  \
	IMULQ h2, t3;                  \
	MOVQ  r1, AX;                  \
	MULQ  h1;                      \
	ADDQ  AX, t2;                  \
	ADCQ  DX, t3;                  \
	ADDQ  h0, t2;                  \
	ADCQ  $0, t3;                  \
	                               \
	MOVQ  t0, h0;                  \
	MOVQ  t1, h1;                  \
	MOVQ  t2, h2;                  \
	ANDQ  $3, h2;                  \
	MOVQ  t2, t0;                  \
	ANDQ  $0xFFFFFFFFFFFFFFFC, t0; \
	ADDQ  t0, h0;                  \
	ADCQ  t3, h1;                  \
	ADCQ  $0, h2;                  \
	SHRQ  $2, t3, t2;              \
	SHRQ  $2, t3;                  \
	ADDQ  t2, h0;                  \
	ADCQ  t3, h1;                  \
	ADCQ  $0, h2

// func update(state *[7]uint64, msg []byte)
TEXT update(SB), $0-32
	MOVQ state+0(FP), DI
	MOVQ msg_base+8(FP), SI
	MOVQ msg_len+16(FP), R15

	MOVQ 0(DI), R8   // h0
	MOVQ 8(DI), R9   // h1
	MOVQ 16(DI), R10 // h2
	MOVQ 24(DI), R11 // r0
	MOVQ 32(DI), R12 // r1

	CMPQ R15, $16
	JB   bytes_between_0_and_15

loop:
	POLY1305_ADD(SI, R8, R9, R10)

multiply:
	POLY1305_MUL(R8, R9, R10, R11, R12, BX, CX, R13, R14)
	SUBQ $16, R15
	CMPQ R15, $16
	JAE  loop

bytes_between_0_and_15:
	TESTQ R15, R15
	JZ    done
	MOVQ  $1, BX
	XORQ  CX, CX
	XORQ  R13, R13
	ADDQ  R15, SI

flush_buffer:
	SHLQ $8, BX, CX
	SHLQ $8, BX
	MOVB -1(SI), R13
	XORQ R13, BX
	DECQ SI
	DECQ R15
	JNZ  flush_buffer

	ADDQ BX, R8
	ADCQ CX, R9
	ADCQ $0, R10
	MOVQ $16, R15
	JMP  multiply

done:
	MOVQ R8, 0(DI)
	MOVQ R9, 8(DI)
	MOVQ R10, 16(DI)
	RET

+ f 1658ccadfa9fc2e6538d9277df0c892fc69da08943f1ffae152a24bb3be43a23 vendor/golang.org/x/crypto/poly1305/sum_generic.go
utf8file 308
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file provides the generic implementation of Sum and MAC. Other files
// might provide optimized assembly implementations of some of this code.

package poly1305

import "encoding/binary"

// Poly1305 [RFC 7539] is a relatively simple algorithm: the authentication tag
// for a 64 bytes message is approximately
//
//     s + m[0:16] * r + m[16:32] * r + m[32:48] * r + m[48:64] * r  mod  2 - 5
//
// for some secret r and s. It can be computed sequentially like
//
//     for len(msg) > 0:
//         h += read(msg, 16)
//         h *= r
//         h %= 2 - 5
//     return h + s
//
// All the complexity is about doing performant constant-time math on numbers
// larger than any available numeric type.

func sumGeneric(out *[TagSize]byte, msg []byte, key *[32]byte) {
	h := newMACGeneric(key)
	h.Write(msg)
	h.Sum(out)
}

func newMACGeneric(key *[32]byte) (h macGeneric) {
	initialize(key, &h.r, &h.s)
	return
}

// macState holds numbers in saturated 64-bit little-endian limbs. That is,
// the value of [x0, x1, x2] is x[0] + x[1] * 2 + x[2] * 2.
type macState struct {
	// h is the main accumulator. It is to be interpreted modulo 2 - 5, but
	// can grow larger during and after rounds.
	h [3]uint64
	// r and s are the private key components.
	r [2]uint64
	s [2]uint64
}

type macGeneric struct {
	macState

	buffer [TagSize]byte
	offset int
}

// Write splits the incoming message into TagSize chunks, and passes them to
// update. It buffers incomplete chunks.
func (h *macGeneric) Write(p []byte) (int, error) {
	nn := len(p)
	if h.offset > 0 {
		n := copy(h.buffer[h.offset:], p)
		if h.offset+n < TagSize {
			h.offset += n
			return nn, nil
		}
		p = p[n:]
		h.offset = 0
		updateGeneric(&h.macState, h.buffer[:])
	}
	if n := len(p) - (len(p) % TagSize); n > 0 {
		updateGeneric(&h.macState, p[:n])
		p = p[n:]
	}
	if len(p) > 0 {
		h.offset += copy(h.buffer[h.offset:], p)
	}
	return nn, nil
}

// Sum flushes the last incomplete chunk from the buffer, if any, and generates
// the MAC output. It does not modify its state, in order to allow for multiple
// calls to Sum, even if no Write is allowed after Sum.
func (h *macGeneric) Sum(out *[TagSize]byte) {
	state := h.macState
	if h.offset > 0 {
		updateGeneric(&state, h.buffer[:h.offset])
	}
	finalize(out, &state.h, &state.s)
}

// [rMask0, rMask1] is the specified Poly1305 clamping mask in little-endian. It
// clears some bits of the secret coefficient to make it possible to implement
// multiplication more efficiently.
const (
	rMask0 = 0x0FFFFFFC0FFFFFFF
	rMask1 = 0x0FFFFFFC0FFFFFFC
)

func initialize(key *[32]byte, r, s *[2]uint64) {
	r[0] = binary.LittleEndian.Uint64(key[0:8]) & rMask0
	r[1] = binary.LittleEndian.Uint64(key[8:16]) & rMask1
	s[0] = binary.LittleEndian.Uint64(key[16:24])
	s[1] = binary.LittleEndian.Uint64(key[24:32])
}

// uint128 holds a 128-bit number as two 64-bit limbs, for use with the
// bits.Mul64 and bits.Add64 intrinsics.
type uint128 struct {
	lo, hi uint64
}

func mul64(a, b uint64) uint128 {
	hi, lo := bitsMul64(a, b)
	return uint128{lo, hi}
}

func add128(a, b uint128) uint128 {
	lo, c := bitsAdd64(a.lo, b.lo, 0)
	hi, c := bitsAdd64(a.hi, b.hi, c)
	if c != 0 {
		panic("poly1305: unexpected overflow")
	}
	return uint128{lo, hi}
}

func shiftRightBy2(a uint128) uint128 {
	a.lo = a.lo>>2 | (a.hi&3)<<62
	a.hi = a.hi >> 2
	return a
}

// updateGeneric absorbs msg into the state.h accumulator. For each chunk m of
// 128 bits of message, it computes
//
//     h = (h + m) * r  mod  2 - 5
//
// If the msg length is not a multiple of TagSize, it assumes the last
// incomplete chunk is the final one.
func updateGeneric(state *macState, msg []byte) {
	h0, h1, h2 := state.h[0], state.h[1], state.h[2]
	r0, r1 := state.r[0], state.r[1]

	for len(msg) > 0 {
		var c uint64

		// For the first step, h + m, we use a chain of bits.Add64 intrinsics.
		// The resulting value of h might exceed 2 - 5, but will be partially
		// reduced at the end of the multiplication below.
		//
		// The spec requires us to set a bit just above the message size, not to
		// hide leading zeroes. For full chunks, that's 1 << 128, so we can just
		// add 1 to the most significant (2) limb, h2.
		if len(msg) >= TagSize {
			h0, c = bitsAdd64(h0, binary.LittleEndian.Uint64(msg[0:8]), 0)
			h1, c = bitsAdd64(h1, binary.LittleEndian.Uint64(msg[8:16]), c)
			h2 += c + 1

			msg = msg[TagSize:]
		} else {
			var buf [TagSize]byte
			copy(buf[:], msg)
			buf[len(msg)] = 1

			h0, c = bitsAdd64(h0, binary.LittleEndian.Uint64(buf[0:8]), 0)
			h1, c = bitsAdd64(h1, binary.LittleEndian.Uint64(buf[8:16]), c)
			h2 += c

			msg = nil
		}

		// Multiplication of big number limbs is similar to elementary school
		// columnar multiplication. Instead of digits, there are 64-bit limbs.
		//
		// We are multiplying a 3 limbs number, h, by a 2 limbs number, r.
		//
		//                        h2    h1    h0  x
		//                              r1    r0  =
		//                       ----------------
		//                      h2r0  h1r0  h0r0     <-- individual 128-bit products
		//            +   h2r1  h1r1  h0r1
		//               ------------------------
		//                 m3    m2    m1    m0      <-- result in 128-bit overlapping limbs
		//               ------------------------
		//         m3.hi m2.hi m1.hi m0.hi           <-- carry propagation
		//     +         m3.lo m2.lo m1.lo m0.lo
		//        -------------------------------
		//           t4    t3    t2    t1    t0      <-- final result in 64-bit limbs
		//
		// The main difference from pen-and-paper multiplication is that we do
		// carry propagation in a separate step, as if we wrote two digit sums
		// at first (the 128-bit limbs), and then carried the tens all at once.

		h0r0 := mul64(h0, r0)
		h1r0 := mul64(h1, r0)
		h2r0 := mul64(h2, r0)
		h0r1 := mul64(h0, r1)
		h1r1 := mul64(h1, r1)
		h2r1 := mul64(h2, r1)

		// Since h2 is known to be at most 7 (5 + 1 + 1), and r0 and r1 have their
		// top 4 bits cleared by rMask{0,1}, we know that their product is not going
		// to overflow 64 bits, so we can ignore the high part of the products.
		//
		// This also means that the product doesn't have a fifth limb (t4).
		if h2r0.hi != 0 {
			panic("poly1305: unexpected overflow")
		}
		if h2r1.hi != 0 {
			panic("poly1305: unexpected overflow")
		}

		m0 := h0r0
		m1 := add128(h1r0, h0r1) // These two additions don't overflow thanks again
		m2 := add128(h2r0, h1r1) // to the 4 masked bits at the top of r0 and r1.
		m3 := h2r1

		t0 := m0.lo
		t1, c := bitsAdd64(m1.lo, m0.hi, 0)
		t2, c := bitsAdd64(m2.lo, m1.hi, c)
		t3, _ := bitsAdd64(m3.lo, m2.hi, c)

		// Now we have the result as 4 64-bit limbs, and we need to reduce it
		// modulo 2 - 5. The special shape of this Crandall prime lets us do
		// a cheap partial reduction according to the reduction identity
		//
		//     c * 2 + n  =  c * 5 + n  mod  2 - 5
		//
		// because 2 = 5 mod 2 - 5. Partial reduction since the result is
		// likely to be larger than 2 - 5, but still small enough to fit the
		// assumptions we make about h in the rest of the code.
		//
		// See also https://speakerdeck.com/gtank/engineering-prime-numbers?slide=23

		// We split the final result at the 2 mark into h and cc, the carry.
		// Note that the carry bits are effectively shifted left by 2, in other
		// words, cc = c * 4 for the c in the reduction identity.
		h0, h1, h2 = t0, t1, t2&maskLow2Bits
		cc := uint128{t2 & maskNotLow2Bits, t3}

		// To add c * 5 to h, we first add cc = c * 4, and then add (cc >> 2) = c.

		h0, c = bitsAdd64(h0, cc.lo, 0)
		h1, c = bitsAdd64(h1, cc.hi, c)
		h2 += c

		cc = shiftRightBy2(cc)

		h0, c = bitsAdd64(h0, cc.lo, 0)
		h1, c = bitsAdd64(h1, cc.hi, c)
		h2 += c

		// h2 is at most 3 + 1 + 1 = 5, making the whole of h at most
		//
		//     5 * 2 + (2 - 1) = 6 * 2 - 1
	}

	state.h[0], state.h[1], state.h[2] = h0, h1, h2
}

const (
	maskLow2Bits    uint64 = 0x0000000000000003
	maskNotLow2Bits uint64 = ^maskLow2Bits
)

// select64 returns x if v == 1 and y if v == 0, in constant time.
func select64(v, x, y uint64) uint64 { return ^(v-1)&x | (v-1)&y }

// [p0, p1, p2] is 2 - 5 in little endian order.
const (
	p0 = 0xFFFFFFFFFFFFFFFB
	p1 = 0xFFFFFFFFFFFFFFFF
	p2 = 0x0000000000000003
)

// finalize completes the modular reduction of h and computes
//
//     out = h + s  mod  2
//
func finalize(out *[TagSize]byte, h *[3]uint64, s *[2]uint64) {
	h0, h1, h2 := h[0], h[1], h[2]

	// After the partial reduction in updateGeneric, h might be more than
	// 2 - 5, but will be less than 2 * (2 - 5). To complete the reduction
	// in constant time, we compute t = h - (2 - 5), and select h as the
	// result if the subtraction underflows, and t otherwise.

	hMinusP0, b := bitsSub64(h0, p0, 0)
	hMinusP1, b := bitsSub64(h1, p1, b)
	_, b = bitsSub64(h2, p2, b)

	// h = h if h < p else h - p
	h0 = select64(b, h0, hMinusP0)
	h1 = select64(b, h1, hMinusP1)

	// Finally, we compute the last Poly1305 step
	//
	//     tag = h + s  mod  2
	//
	// by just doing a wide addition with the 128 low bits of h and discarding
	// the overflow.
	h0, c := bitsAdd64(h0, s[0], 0)
	h1, _ = bitsAdd64(h1, s[1], c)

	binary.LittleEndian.PutUint64(out[0:8], h0)
	binary.LittleEndian.PutUint64(out[8:16], h1)
}

+ f fa91f5af33d6b891aa1c268dc79c2ed8d4576445073c7954657c919b67e1ae42 vendor/golang.org/x/crypto/poly1305/sum_noasm.go
utf8file 14
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build s390x,!go1.11 !amd64,!s390x,!ppc64le gccgo appengine nacl

package poly1305

func sum(out *[TagSize]byte, msg []byte, key *[32]byte) {
	h := newMAC(key)
	h.Write(msg)
	h.Sum(out)
}

+ f 20db6ce5a8cccc93d35580b0832a0e0d1b920a3164cecac94c38c958eb8ffec7 vendor/golang.org/x/crypto/poly1305/sum_ppc64le.go
utf8file 59
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ppc64le,!gccgo,!appengine

package poly1305

//go:noescape
func update(state *macState, msg []byte)

func sum(out *[16]byte, m []byte, key *[32]byte) {
	h := newMAC(key)
	h.Write(m)
	h.Sum(out)
}

func newMAC(key *[32]byte) (h mac) {
	initialize(key, &h.r, &h.s)
	return
}

// mac is a wrapper for macGeneric that redirects calls that would have gone to
// updateGeneric to update.
//
// Its Write and Sum methods are otherwise identical to the macGeneric ones, but
// using function pointers would carry a major performance cost.
type mac struct{ macGeneric }

func (h *mac) Write(p []byte) (int, error) {
	nn := len(p)
	if h.offset > 0 {
		n := copy(h.buffer[h.offset:], p)
		if h.offset+n < TagSize {
			h.offset += n
			return nn, nil
		}
		p = p[n:]
		h.offset = 0
		update(&h.macState, h.buffer[:])
	}
	if n := len(p) - (len(p) % TagSize); n > 0 {
		update(&h.macState, p[:n])
		p = p[n:]
	}
	if len(p) > 0 {
		h.offset += copy(h.buffer[h.offset:], p)
	}
	return nn, nil
}

func (h *mac) Sum(out *[16]byte) {
	state := h.macState
	if h.offset > 0 {
		update(&state, h.buffer[:h.offset])
	}
	finalize(out, &state.h, &state.s)
}

+ f 4702c0291f5350307de60e98fa1e650a4cf4e98045c5be89d8f9c9a4a6be79d7 vendor/golang.org/x/crypto/poly1305/sum_ppc64le.s
utf8file 182
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ppc64le,!gccgo,!appengine

#include "textflag.h"

// This was ported from the amd64 implementation.

#define POLY1305_ADD(msg, h0, h1, h2, t0, t1, t2) \
	MOVD (msg), t0;  \
	MOVD 8(msg), t1; \
	MOVD $1, t2;     \
	ADDC t0, h0, h0; \
	ADDE t1, h1, h1; \
	ADDE t2, h2;     \
	ADD  $16, msg

#define POLY1305_MUL(h0, h1, h2, r0, r1, t0, t1, t2, t3, t4, t5) \
	MULLD  r0, h0, t0;  \
	MULLD  r0, h1, t4;  \
	MULHDU r0, h0, t1;  \
	MULHDU r0, h1, t5;  \
	ADDC   t4, t1, t1;  \
	MULLD  r0, h2, t2;  \
	ADDZE  t5;          \
	MULHDU r1, h0, t4;  \
	MULLD  r1, h0, h0;  \
	ADD    t5, t2, t2;  \
	ADDC   h0, t1, t1;  \
	MULLD  h2, r1, t3;  \
	ADDZE  t4, h0;      \
	MULHDU r1, h1, t5;  \
	MULLD  r1, h1, t4;  \
	ADDC   t4, t2, t2;  \
	ADDE   t5, t3, t3;  \
	ADDC   h0, t2, t2;  \
	MOVD   $-4, t4;     \
	MOVD   t0, h0;      \
	MOVD   t1, h1;      \
	ADDZE  t3;          \
	ANDCC  $3, t2, h2;  \
	AND    t2, t4, t0;  \
	ADDC   t0, h0, h0;  \
	ADDE   t3, h1, h1;  \
	SLD    $62, t3, t4; \
	SRD    $2, t2;      \
	ADDZE  h2;          \
	OR     t4, t2, t2;  \
	SRD    $2, t3;      \
	ADDC   t2, h0, h0;  \
	ADDE   t3, h1, h1;  \
	ADDZE  h2

DATA poly1305Mask<>+0x00(SB)/8, $0x0FFFFFFC0FFFFFFF
DATA poly1305Mask<>+0x08(SB)/8, $0x0FFFFFFC0FFFFFFC
GLOBL poly1305Mask<>(SB), RODATA, $16

// func update(state *[7]uint64, msg []byte)
TEXT update(SB), $0-32
	MOVD state+0(FP), R3
	MOVD msg_base+8(FP), R4
	MOVD msg_len+16(FP), R5

	MOVD 0(R3), R8   // h0
	MOVD 8(R3), R9   // h1
	MOVD 16(R3), R10 // h2
	MOVD 24(R3), R11 // r0
	MOVD 32(R3), R12 // r1

	CMP R5, $16
	BLT bytes_between_0_and_15

loop:
	POLY1305_ADD(R4, R8, R9, R10, R20, R21, R22)

multiply:
	POLY1305_MUL(R8, R9, R10, R11, R12, R16, R17, R18, R14, R20, R21)
	ADD $-16, R5
	CMP R5, $16
	BGE loop

bytes_between_0_and_15:
	CMP  $0, R5
	BEQ  done
	MOVD $0, R16 // h0
	MOVD $0, R17 // h1

flush_buffer:
	CMP R5, $8
	BLE just1

	MOVD $8, R21
	SUB  R21, R5, R21

	// Greater than 8 -- load the rightmost remaining bytes in msg
	// and put into R17 (h1)
	MOVD (R4)(R21), R17
	MOVD $16, R22

	// Find the offset to those bytes
	SUB R5, R22, R22
	SLD $3, R22

	// Shift to get only the bytes in msg
	SRD R22, R17, R17

	// Put 1 at high end
	MOVD $1, R23
	SLD  $3, R21
	SLD  R21, R23, R23
	OR   R23, R17, R17

	// Remainder is 8
	MOVD $8, R5

just1:
	CMP R5, $8
	BLT less8

	// Exactly 8
	MOVD (R4), R16

	CMP $0, R17

	// Check if we've already set R17; if not
	// set 1 to indicate end of msg.
	BNE  carry
	MOVD $1, R17
	BR   carry

less8:
	MOVD  $0, R16   // h0
	MOVD  $0, R22   // shift count
	CMP   R5, $4
	BLT   less4
	MOVWZ (R4), R16
	ADD   $4, R4
	ADD   $-4, R5
	MOVD  $32, R22

less4:
	CMP   R5, $2
	BLT   less2
	MOVHZ (R4), R21
	SLD   R22, R21, R21
	OR    R16, R21, R16
	ADD   $16, R22
	ADD   $-2, R5
	ADD   $2, R4

less2:
	CMP   $0, R5
	BEQ   insert1
	MOVBZ (R4), R21
	SLD   R22, R21, R21
	OR    R16, R21, R16
	ADD   $8, R22

insert1:
	// Insert 1 at end of msg
	MOVD $1, R21
	SLD  R22, R21, R21
	OR   R16, R21, R16

carry:
	// Add new values to h0, h1, h2
	ADDC R16, R8
	ADDE R17, R9
	ADDE $0, R10
	MOVD $16, R5
	ADD  R5, R4
	BR   multiply

done:
	// Save h0, h1, h2 in state
	MOVD R8, 0(R3)
	MOVD R9, 8(R3)
	MOVD R10, 16(R3)
	RET

+ f a1ec2eb20077260a034e16aa64628798f25fcd12e89bde9489eff9b17642fabd vendor/golang.org/x/crypto/poly1305/sum_s390x.go
utf8file 40
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build s390x,go1.11,!gccgo,!appengine

package poly1305

import (
	"golang.org/x/sys/cpu"
)

// poly1305vx is an assembly implementation of Poly1305 that uses vector
// instructions. It must only be called if the vector facility (vx) is
// available.
//go:noescape
func poly1305vx(out *[16]byte, m *byte, mlen uint64, key *[32]byte)

// poly1305vmsl is an assembly implementation of Poly1305 that uses vector
// instructions, including VMSL. It must only be called if the vector facility (vx) is
// available and if VMSL is supported.
//go:noescape
func poly1305vmsl(out *[16]byte, m *byte, mlen uint64, key *[32]byte)

func sum(out *[16]byte, m []byte, key *[32]byte) {
	if cpu.S390X.HasVX {
		var mPtr *byte
		if len(m) > 0 {
			mPtr = &m[0]
		}
		if cpu.S390X.HasVXE && len(m) > 256 {
			poly1305vmsl(out, mPtr, uint64(len(m)), key)
		} else {
			poly1305vx(out, mPtr, uint64(len(m)), key)
		}
	} else {
		sumGeneric(out, m, key)
	}
}

+ f 974f50e9d292fd429131eb10f6f6918fc58c133fe061e29cb0daf65c3d31e2d2 vendor/golang.org/x/crypto/poly1305/sum_s390x.s
utf8file 379
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build s390x,go1.11,!gccgo,!appengine

#include "textflag.h"

// Implementation of Poly1305 using the vector facility (vx).

// constants
#define MOD26 V0
#define EX0   V1
#define EX1   V2
#define EX2   V3

// temporaries
#define T_0 V4
#define T_1 V5
#define T_2 V6
#define T_3 V7
#define T_4 V8

// key (r)
#define R_0  V9
#define R_1  V10
#define R_2  V11
#define R_3  V12
#define R_4  V13
#define R5_1 V14
#define R5_2 V15
#define R5_3 V16
#define R5_4 V17
#define RSAVE_0 R5
#define RSAVE_1 R6
#define RSAVE_2 R7
#define RSAVE_3 R8
#define RSAVE_4 R9
#define R5SAVE_1 V28
#define R5SAVE_2 V29
#define R5SAVE_3 V30
#define R5SAVE_4 V31

// message block
#define F_0 V18
#define F_1 V19
#define F_2 V20
#define F_3 V21
#define F_4 V22

// accumulator
#define H_0 V23
#define H_1 V24
#define H_2 V25
#define H_3 V26
#define H_4 V27

GLOBL keyMask<>(SB), RODATA, $16
DATA keyMask<>+0(SB)/8, $0xffffff0ffcffff0f
DATA keyMask<>+8(SB)/8, $0xfcffff0ffcffff0f

GLOBL bswapMask<>(SB), RODATA, $16
DATA bswapMask<>+0(SB)/8, $0x0f0e0d0c0b0a0908
DATA bswapMask<>+8(SB)/8, $0x0706050403020100

GLOBL constants<>(SB), RODATA, $64
// MOD26
DATA constants<>+0(SB)/8, $0x3ffffff
DATA constants<>+8(SB)/8, $0x3ffffff
// EX0
DATA constants<>+16(SB)/8, $0x0006050403020100
DATA constants<>+24(SB)/8, $0x1016151413121110
// EX1
DATA constants<>+32(SB)/8, $0x060c0b0a09080706
DATA constants<>+40(SB)/8, $0x161c1b1a19181716
// EX2
DATA constants<>+48(SB)/8, $0x0d0d0d0d0d0f0e0d
DATA constants<>+56(SB)/8, $0x1d1d1d1d1d1f1e1d

// h = (f*g) % (2**130-5) [partial reduction]
#define MULTIPLY(f0, f1, f2, f3, f4, g0, g1, g2, g3, g4, g51, g52, g53, g54, h0, h1, h2, h3, h4) \
	VMLOF  f0, g0, h0        \
	VMLOF  f0, g1, h1        \
	VMLOF  f0, g2, h2        \
	VMLOF  f0, g3, h3        \
	VMLOF  f0, g4, h4        \
	VMLOF  f1, g54, T_0      \
	VMLOF  f1, g0, T_1       \
	VMLOF  f1, g1, T_2       \
	VMLOF  f1, g2, T_3       \
	VMLOF  f1, g3, T_4       \
	VMALOF f2, g53, h0, h0   \
	VMALOF f2, g54, h1, h1   \
	VMALOF f2, g0, h2, h2    \
	VMALOF f2, g1, h3, h3    \
	VMALOF f2, g2, h4, h4    \
	VMALOF f3, g52, T_0, T_0 \
	VMALOF f3, g53, T_1, T_1 \
	VMALOF f3, g54, T_2, T_2 \
	VMALOF f3, g0, T_3, T_3  \
	VMALOF f3, g1, T_4, T_4  \
	VMALOF f4, g51, h0, h0   \
	VMALOF f4, g52, h1, h1   \
	VMALOF f4, g53, h2, h2   \
	VMALOF f4, g54, h3, h3   \
	VMALOF f4, g0, h4, h4    \
	VAG    T_0, h0, h0       \
	VAG    T_1, h1, h1       \
	VAG    T_2, h2, h2       \
	VAG    T_3, h3, h3       \
	VAG    T_4, h4, h4

// carry h0->h1 h3->h4, h1->h2 h4->h0, h0->h1 h2->h3, h3->h4
#define REDUCE(h0, h1, h2, h3, h4) \
	VESRLG $26, h0, T_0  \
	VESRLG $26, h3, T_1  \
	VN     MOD26, h0, h0 \
	VN     MOD26, h3, h3 \
	VAG    T_0, h1, h1   \
	VAG    T_1, h4, h4   \
	VESRLG $26, h1, T_2  \
	VESRLG $26, h4, T_3  \
	VN     MOD26, h1, h1 \
	VN     MOD26, h4, h4 \
	VESLG  $2, T_3, T_4  \
	VAG    T_3, T_4, T_4 \
	VAG    T_2, h2, h2   \
	VAG    T_4, h0, h0   \
	VESRLG $26, h2, T_0  \
	VESRLG $26, h0, T_1  \
	VN     MOD26, h2, h2 \
	VN     MOD26, h0, h0 \
	VAG    T_0, h3, h3   \
	VAG    T_1, h1, h1   \
	VESRLG $26, h3, T_2  \
	VN     MOD26, h3, h3 \
	VAG    T_2, h4, h4

// expand in0 into d[0] and in1 into d[1]
#define EXPAND(in0, in1, d0, d1, d2, d3, d4) \
	VGBM   $0x0707, d1       \ // d1=tmp
	VPERM  in0, in1, EX2, d4 \
	VPERM  in0, in1, EX0, d0 \
	VPERM  in0, in1, EX1, d2 \
	VN     d1, d4, d4        \
	VESRLG $26, d0, d1       \
	VESRLG $30, d2, d3       \
	VESRLG $4, d2, d2        \
	VN     MOD26, d0, d0     \
	VN     MOD26, d1, d1     \
	VN     MOD26, d2, d2     \
	VN     MOD26, d3, d3

// pack h4:h0 into h1:h0 (no carry)
#define PACK(h0, h1, h2, h3, h4) \
	VESLG $26, h1, h1  \
	VESLG $26, h3, h3  \
	VO    h0, h1, h0   \
	VO    h2, h3, h2   \
	VESLG $4, h2, h2   \
	VLEIB $7, $48, h1  \
	VSLB  h1, h2, h2   \
	VO    h0, h2, h0   \
	VLEIB $7, $104, h1 \
	VSLB  h1, h4, h3   \
	VO    h3, h0, h0   \
	VLEIB $7, $24, h1  \
	VSRLB h1, h4, h1

// if h > 2**130-5 then h -= 2**130-5
#define MOD(h0, h1, t0, t1, t2) \
	VZERO t0          \
	VLEIG $1, $5, t0  \
	VACCQ h0, t0, t1  \
	VAQ   h0, t0, t0  \
	VONE  t2          \
	VLEIG $1, $-4, t2 \
	VAQ   t2, t1, t1  \
	VACCQ h1, t1, t1  \
	VONE  t2          \
	VAQ   t2, t1, t1  \
	VN    h0, t1, t2  \
	VNC   t0, t1, t1  \
	VO    t1, t2, h0

// func poly1305vx(out *[16]byte, m *byte, mlen uint64, key *[32]key)
TEXT poly1305vx(SB), $0-32
	// This code processes up to 2 blocks (32 bytes) per iteration
	// using the algorithm described in:
	// NEON crypto, Daniel J. Bernstein & Peter Schwabe
	// https://cryptojedi.org/papers/neoncrypto-20120320.pdf
	LMG out+0(FP), R1, R4 // R1=out, R2=m, R3=mlen, R4=key

	// load MOD26, EX0, EX1 and EX2
	MOVD $constants<>(SB), R5
	VLM  (R5), MOD26, EX2

	// setup r
	VL   (R4), T_0
	MOVD $keyMask<>(SB), R6
	VL   (R6), T_1
	VN   T_0, T_1, T_0
	EXPAND(T_0, T_0, R_0, R_1, R_2, R_3, R_4)

	// setup r*5
	VLEIG $0, $5, T_0
	VLEIG $1, $5, T_0

	// store r (for final block)
	VMLOF T_0, R_1, R5SAVE_1
	VMLOF T_0, R_2, R5SAVE_2
	VMLOF T_0, R_3, R5SAVE_3
	VMLOF T_0, R_4, R5SAVE_4
	VLGVG $0, R_0, RSAVE_0
	VLGVG $0, R_1, RSAVE_1
	VLGVG $0, R_2, RSAVE_2
	VLGVG $0, R_3, RSAVE_3
	VLGVG $0, R_4, RSAVE_4

	// skip r**2 calculation
	CMPBLE R3, $16, skip

	// calculate r**2
	MULTIPLY(R_0, R_1, R_2, R_3, R_4, R_0, R_1, R_2, R_3, R_4, R5SAVE_1, R5SAVE_2, R5SAVE_3, R5SAVE_4, H_0, H_1, H_2, H_3, H_4)
	REDUCE(H_0, H_1, H_2, H_3, H_4)
	VLEIG $0, $5, T_0
	VLEIG $1, $5, T_0
	VMLOF T_0, H_1, R5_1
	VMLOF T_0, H_2, R5_2
	VMLOF T_0, H_3, R5_3
	VMLOF T_0, H_4, R5_4
	VLR   H_0, R_0
	VLR   H_1, R_1
	VLR   H_2, R_2
	VLR   H_3, R_3
	VLR   H_4, R_4

	// initialize h
	VZERO H_0
	VZERO H_1
	VZERO H_2
	VZERO H_3
	VZERO H_4

loop:
	CMPBLE R3, $32, b2
	VLM    (R2), T_0, T_1
	SUB    $32, R3
	MOVD   $32(R2), R2
	EXPAND(T_0, T_1, F_0, F_1, F_2, F_3, F_4)
	VLEIB  $4, $1, F_4
	VLEIB  $12, $1, F_4

multiply:
	VAG    H_0, F_0, F_0
	VAG    H_1, F_1, F_1
	VAG    H_2, F_2, F_2
	VAG    H_3, F_3, F_3
	VAG    H_4, F_4, F_4
	MULTIPLY(F_0, F_1, F_2, F_3, F_4, R_0, R_1, R_2, R_3, R_4, R5_1, R5_2, R5_3, R5_4, H_0, H_1, H_2, H_3, H_4)
	REDUCE(H_0, H_1, H_2, H_3, H_4)
	CMPBNE R3, $0, loop

finish:
	// sum vectors
	VZERO  T_0
	VSUMQG H_0, T_0, H_0
	VSUMQG H_1, T_0, H_1
	VSUMQG H_2, T_0, H_2
	VSUMQG H_3, T_0, H_3
	VSUMQG H_4, T_0, H_4

	// h may be >= 2*(2**130-5) so we need to reduce it again
	REDUCE(H_0, H_1, H_2, H_3, H_4)

	// carry h1->h4
	VESRLG $26, H_1, T_1
	VN     MOD26, H_1, H_1
	VAQ    T_1, H_2, H_2
	VESRLG $26, H_2, T_2
	VN     MOD26, H_2, H_2
	VAQ    T_2, H_3, H_3
	VESRLG $26, H_3, T_3
	VN     MOD26, H_3, H_3
	VAQ    T_3, H_4, H_4

	// h is now < 2*(2**130-5)
	// pack h into h1 (hi) and h0 (lo)
	PACK(H_0, H_1, H_2, H_3, H_4)

	// if h > 2**130-5 then h -= 2**130-5
	MOD(H_0, H_1, T_0, T_1, T_2)

	// h += s
	MOVD  $bswapMask<>(SB), R5
	VL    (R5), T_1
	VL    16(R4), T_0
	VPERM T_0, T_0, T_1, T_0    // reverse bytes (to big)
	VAQ   T_0, H_0, H_0
	VPERM H_0, H_0, T_1, H_0    // reverse bytes (to little)
	VST   H_0, (R1)

	RET

b2:
	CMPBLE R3, $16, b1

	// 2 blocks remaining
	SUB    $17, R3
	VL     (R2), T_0
	VLL    R3, 16(R2), T_1
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBEQ R3, $16, 2(PC)
	VLVGB  R3, R0, T_1
	EXPAND(T_0, T_1, F_0, F_1, F_2, F_3, F_4)
	CMPBNE R3, $16, 2(PC)
	VLEIB  $12, $1, F_4
	VLEIB  $4, $1, F_4

	// setup [r,r]
	VLVGG $1, RSAVE_0, R_0
	VLVGG $1, RSAVE_1, R_1
	VLVGG $1, RSAVE_2, R_2
	VLVGG $1, RSAVE_3, R_3
	VLVGG $1, RSAVE_4, R_4
	VPDI  $0, R5_1, R5SAVE_1, R5_1
	VPDI  $0, R5_2, R5SAVE_2, R5_2
	VPDI  $0, R5_3, R5SAVE_3, R5_3
	VPDI  $0, R5_4, R5SAVE_4, R5_4

	MOVD $0, R3
	BR   multiply

skip:
	VZERO H_0
	VZERO H_1
	VZERO H_2
	VZERO H_3
	VZERO H_4

	CMPBEQ R3, $0, finish

b1:
	// 1 block remaining
	SUB    $1, R3
	VLL    R3, (R2), T_0
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBEQ R3, $16, 2(PC)
	VLVGB  R3, R0, T_0
	VZERO  T_1
	EXPAND(T_0, T_1, F_0, F_1, F_2, F_3, F_4)
	CMPBNE R3, $16, 2(PC)
	VLEIB  $4, $1, F_4
	VLEIG  $1, $1, R_0
	VZERO  R_1
	VZERO  R_2
	VZERO  R_3
	VZERO  R_4
	VZERO  R5_1
	VZERO  R5_2
	VZERO  R5_3
	VZERO  R5_4

	// setup [r, 1]
	VLVGG $0, RSAVE_0, R_0
	VLVGG $0, RSAVE_1, R_1
	VLVGG $0, RSAVE_2, R_2
	VLVGG $0, RSAVE_3, R_3
	VLVGG $0, RSAVE_4, R_4
	VPDI  $0, R5SAVE_1, R5_1, R5_1
	VPDI  $0, R5SAVE_2, R5_2, R5_2
	VPDI  $0, R5SAVE_3, R5_3, R5_3
	VPDI  $0, R5SAVE_4, R5_4, R5_4

	MOVD $0, R3
	BR   multiply

+ f f5a4421c95a36ad381c268619404ea3300ae9ecdf0b6ece984fa65ee9114d129 vendor/golang.org/x/crypto/poly1305/sum_vmsl_s390x.s
utf8file 910
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build s390x,go1.11,!gccgo,!appengine

#include "textflag.h"

// Implementation of Poly1305 using the vector facility (vx) and the VMSL instruction.

// constants
#define EX0   V1
#define EX1   V2
#define EX2   V3

// temporaries
#define T_0 V4
#define T_1 V5
#define T_2 V6
#define T_3 V7
#define T_4 V8
#define T_5 V9
#define T_6 V10
#define T_7 V11
#define T_8 V12
#define T_9 V13
#define T_10 V14

// r**2 & r**4
#define R_0  V15
#define R_1  V16
#define R_2  V17
#define R5_1 V18
#define R5_2 V19
// key (r)
#define RSAVE_0 R7
#define RSAVE_1 R8
#define RSAVE_2 R9
#define R5SAVE_1 R10
#define R5SAVE_2 R11

// message block
#define M0 V20
#define M1 V21
#define M2 V22
#define M3 V23
#define M4 V24
#define M5 V25

// accumulator
#define H0_0 V26
#define H1_0 V27
#define H2_0 V28
#define H0_1 V29
#define H1_1 V30
#define H2_1 V31

GLOBL keyMask<>(SB), RODATA, $16
DATA keyMask<>+0(SB)/8, $0xffffff0ffcffff0f
DATA keyMask<>+8(SB)/8, $0xfcffff0ffcffff0f

GLOBL bswapMask<>(SB), RODATA, $16
DATA bswapMask<>+0(SB)/8, $0x0f0e0d0c0b0a0908
DATA bswapMask<>+8(SB)/8, $0x0706050403020100

GLOBL constants<>(SB), RODATA, $48
// EX0
DATA constants<>+0(SB)/8, $0x18191a1b1c1d1e1f
DATA constants<>+8(SB)/8, $0x0000050403020100
// EX1
DATA constants<>+16(SB)/8, $0x18191a1b1c1d1e1f
DATA constants<>+24(SB)/8, $0x00000a0908070605
// EX2
DATA constants<>+32(SB)/8, $0x18191a1b1c1d1e1f
DATA constants<>+40(SB)/8, $0x0000000f0e0d0c0b

GLOBL c<>(SB), RODATA, $48
// EX0
DATA c<>+0(SB)/8, $0x0000050403020100
DATA c<>+8(SB)/8, $0x0000151413121110
// EX1
DATA c<>+16(SB)/8, $0x00000a0908070605
DATA c<>+24(SB)/8, $0x00001a1918171615
// EX2
DATA c<>+32(SB)/8, $0x0000000f0e0d0c0b
DATA c<>+40(SB)/8, $0x0000001f1e1d1c1b

GLOBL reduce<>(SB), RODATA, $32
// 44 bit
DATA reduce<>+0(SB)/8, $0x0
DATA reduce<>+8(SB)/8, $0xfffffffffff
// 42 bit
DATA reduce<>+16(SB)/8, $0x0
DATA reduce<>+24(SB)/8, $0x3ffffffffff

// h = (f*g) % (2**130-5) [partial reduction]
// uses T_0...T_9 temporary registers
// input: m02_0, m02_1, m02_2, m13_0, m13_1, m13_2, r_0, r_1, r_2, r5_1, r5_2, m4_0, m4_1, m4_2, m5_0, m5_1, m5_2
// temp: t0, t1, t2, t3, t4, t5, t6, t7, t8, t9
// output: m02_0, m02_1, m02_2, m13_0, m13_1, m13_2
#define MULTIPLY(m02_0, m02_1, m02_2, m13_0, m13_1, m13_2, r_0, r_1, r_2, r5_1, r5_2, m4_0, m4_1, m4_2, m5_0, m5_1, m5_2, t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) \
	\ // Eliminate the dependency for the last 2 VMSLs
	VMSLG m02_0, r_2, m4_2, m4_2                       \
	VMSLG m13_0, r_2, m5_2, m5_2                       \ // 8 VMSLs pipelined
	VMSLG m02_0, r_0, m4_0, m4_0                       \
	VMSLG m02_1, r5_2, V0, T_0                         \
	VMSLG m02_0, r_1, m4_1, m4_1                       \
	VMSLG m02_1, r_0, V0, T_1                          \
	VMSLG m02_1, r_1, V0, T_2                          \
	VMSLG m02_2, r5_1, V0, T_3                         \
	VMSLG m02_2, r5_2, V0, T_4                         \
	VMSLG m13_0, r_0, m5_0, m5_0                       \
	VMSLG m13_1, r5_2, V0, T_5                         \
	VMSLG m13_0, r_1, m5_1, m5_1                       \
	VMSLG m13_1, r_0, V0, T_6                          \
	VMSLG m13_1, r_1, V0, T_7                          \
	VMSLG m13_2, r5_1, V0, T_8                         \
	VMSLG m13_2, r5_2, V0, T_9                         \
	VMSLG m02_2, r_0, m4_2, m4_2                       \
	VMSLG m13_2, r_0, m5_2, m5_2                       \
	VAQ   m4_0, T_0, m02_0                             \
	VAQ   m4_1, T_1, m02_1                             \
	VAQ   m5_0, T_5, m13_0                             \
	VAQ   m5_1, T_6, m13_1                             \
	VAQ   m02_0, T_3, m02_0                            \
	VAQ   m02_1, T_4, m02_1                            \
	VAQ   m13_0, T_8, m13_0                            \
	VAQ   m13_1, T_9, m13_1                            \
	VAQ   m4_2, T_2, m02_2                             \
	VAQ   m5_2, T_7, m13_2                             \

// SQUARE uses three limbs of r and r_2*5 to output square of r
// uses T_1, T_5 and T_7 temporary registers
// input: r_0, r_1, r_2, r5_2
// temp: TEMP0, TEMP1, TEMP2
// output: p0, p1, p2
#define SQUARE(r_0, r_1, r_2, r5_2, p0, p1, p2, TEMP0, TEMP1, TEMP2) \
	VMSLG r_0, r_0, p0, p0     \
	VMSLG r_1, r5_2, V0, TEMP0 \
	VMSLG r_2, r5_2, p1, p1    \
	VMSLG r_0, r_1, V0, TEMP1  \
	VMSLG r_1, r_1, p2, p2     \
	VMSLG r_0, r_2, V0, TEMP2  \
	VAQ   TEMP0, p0, p0        \
	VAQ   TEMP1, p1, p1        \
	VAQ   TEMP2, p2, p2        \
	VAQ   TEMP0, p0, p0        \
	VAQ   TEMP1, p1, p1        \
	VAQ   TEMP2, p2, p2        \

// carry h0->h1->h2->h0 || h3->h4->h5->h3
// uses T_2, T_4, T_5, T_7, T_8, T_9
//       t6,  t7,  t8,  t9, t10, t11
// input: h0, h1, h2, h3, h4, h5
// temp: t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11
// output: h0, h1, h2, h3, h4, h5
#define REDUCE(h0, h1, h2, h3, h4, h5, t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) \
	VLM    (R12), t6, t7  \ // 44 and 42 bit clear mask
	VLEIB  $7, $0x28, t10 \ // 5 byte shift mask
	VREPIB $4, t8         \ // 4 bit shift mask
	VREPIB $2, t11        \ // 2 bit shift mask
	VSRLB  t10, h0, t0    \ // h0 byte shift
	VSRLB  t10, h1, t1    \ // h1 byte shift
	VSRLB  t10, h2, t2    \ // h2 byte shift
	VSRLB  t10, h3, t3    \ // h3 byte shift
	VSRLB  t10, h4, t4    \ // h4 byte shift
	VSRLB  t10, h5, t5    \ // h5 byte shift
	VSRL   t8, t0, t0     \ // h0 bit shift
	VSRL   t8, t1, t1     \ // h2 bit shift
	VSRL   t11, t2, t2    \ // h2 bit shift
	VSRL   t8, t3, t3     \ // h3 bit shift
	VSRL   t8, t4, t4     \ // h4 bit shift
	VESLG  $2, t2, t9     \ // h2 carry x5
	VSRL   t11, t5, t5    \ // h5 bit shift
	VN     t6, h0, h0     \ // h0 clear carry
	VAQ    t2, t9, t2     \ // h2 carry x5
	VESLG  $2, t5, t9     \ // h5 carry x5
	VN     t6, h1, h1     \ // h1 clear carry
	VN     t7, h2, h2     \ // h2 clear carry
	VAQ    t5, t9, t5     \ // h5 carry x5
	VN     t6, h3, h3     \ // h3 clear carry
	VN     t6, h4, h4     \ // h4 clear carry
	VN     t7, h5, h5     \ // h5 clear carry
	VAQ    t0, h1, h1     \ // h0->h1
	VAQ    t3, h4, h4     \ // h3->h4
	VAQ    t1, h2, h2     \ // h1->h2
	VAQ    t4, h5, h5     \ // h4->h5
	VAQ    t2, h0, h0     \ // h2->h0
	VAQ    t5, h3, h3     \ // h5->h3
	VREPG  $1, t6, t6     \ // 44 and 42 bit masks across both halves
	VREPG  $1, t7, t7     \
	VSLDB  $8, h0, h0, h0 \ // set up [h0/1/2, h3/4/5]
	VSLDB  $8, h1, h1, h1 \
	VSLDB  $8, h2, h2, h2 \
	VO     h0, h3, h3     \
	VO     h1, h4, h4     \
	VO     h2, h5, h5     \
	VESRLG $44, h3, t0    \ // 44 bit shift right
	VESRLG $44, h4, t1    \
	VESRLG $42, h5, t2    \
	VN     t6, h3, h3     \ // clear carry bits
	VN     t6, h4, h4     \
	VN     t7, h5, h5     \
	VESLG  $2, t2, t9     \ // multiply carry by 5
	VAQ    t9, t2, t2     \
	VAQ    t0, h4, h4     \
	VAQ    t1, h5, h5     \
	VAQ    t2, h3, h3     \

// carry h0->h1->h2->h0
// input: h0, h1, h2
// temp: t0, t1, t2, t3, t4, t5, t6, t7, t8
// output: h0, h1, h2
#define REDUCE2(h0, h1, h2, t0, t1, t2, t3, t4, t5, t6, t7, t8) \
	VLEIB  $7, $0x28, t3 \ // 5 byte shift mask
	VREPIB $4, t4        \ // 4 bit shift mask
	VREPIB $2, t7        \ // 2 bit shift mask
	VGBM   $0x003F, t5   \ // mask to clear carry bits
	VSRLB  t3, h0, t0    \
	VSRLB  t3, h1, t1    \
	VSRLB  t3, h2, t2    \
	VESRLG $4, t5, t5    \ // 44 bit clear mask
	VSRL   t4, t0, t0    \
	VSRL   t4, t1, t1    \
	VSRL   t7, t2, t2    \
	VESRLG $2, t5, t6    \ // 42 bit clear mask
	VESLG  $2, t2, t8    \
	VAQ    t8, t2, t2    \
	VN     t5, h0, h0    \
	VN     t5, h1, h1    \
	VN     t6, h2, h2    \
	VAQ    t0, h1, h1    \
	VAQ    t1, h2, h2    \
	VAQ    t2, h0, h0    \
	VSRLB  t3, h0, t0    \
	VSRLB  t3, h1, t1    \
	VSRLB  t3, h2, t2    \
	VSRL   t4, t0, t0    \
	VSRL   t4, t1, t1    \
	VSRL   t7, t2, t2    \
	VN     t5, h0, h0    \
	VN     t5, h1, h1    \
	VESLG  $2, t2, t8    \
	VN     t6, h2, h2    \
	VAQ    t0, h1, h1    \
	VAQ    t8, t2, t2    \
	VAQ    t1, h2, h2    \
	VAQ    t2, h0, h0    \

// expands two message blocks into the lower halfs of the d registers
// moves the contents of the d registers into upper halfs
// input: in1, in2, d0, d1, d2, d3, d4, d5
// temp: TEMP0, TEMP1, TEMP2, TEMP3
// output: d0, d1, d2, d3, d4, d5
#define EXPACC(in1, in2, d0, d1, d2, d3, d4, d5, TEMP0, TEMP1, TEMP2, TEMP3) \
	VGBM   $0xff3f, TEMP0      \
	VGBM   $0xff1f, TEMP1      \
	VESLG  $4, d1, TEMP2       \
	VESLG  $4, d4, TEMP3       \
	VESRLG $4, TEMP0, TEMP0    \
	VPERM  in1, d0, EX0, d0    \
	VPERM  in2, d3, EX0, d3    \
	VPERM  in1, d2, EX2, d2    \
	VPERM  in2, d5, EX2, d5    \
	VPERM  in1, TEMP2, EX1, d1 \
	VPERM  in2, TEMP3, EX1, d4 \
	VN     TEMP0, d0, d0       \
	VN     TEMP0, d3, d3       \
	VESRLG $4, d1, d1          \
	VESRLG $4, d4, d4          \
	VN     TEMP1, d2, d2       \
	VN     TEMP1, d5, d5       \
	VN     TEMP0, d1, d1       \
	VN     TEMP0, d4, d4       \

// expands one message block into the lower halfs of the d registers
// moves the contents of the d registers into upper halfs
// input: in, d0, d1, d2
// temp: TEMP0, TEMP1, TEMP2
// output: d0, d1, d2
#define EXPACC2(in, d0, d1, d2, TEMP0, TEMP1, TEMP2) \
	VGBM   $0xff3f, TEMP0     \
	VESLG  $4, d1, TEMP2      \
	VGBM   $0xff1f, TEMP1     \
	VPERM  in, d0, EX0, d0    \
	VESRLG $4, TEMP0, TEMP0   \
	VPERM  in, d2, EX2, d2    \
	VPERM  in, TEMP2, EX1, d1 \
	VN     TEMP0, d0, d0      \
	VN     TEMP1, d2, d2      \
	VESRLG $4, d1, d1         \
	VN     TEMP0, d1, d1      \

// pack h2:h0 into h1:h0 (no carry)
// input: h0, h1, h2
// output: h0, h1, h2
#define PACK(h0, h1, h2) \
	VMRLG  h1, h2, h2  \ // copy h1 to upper half h2
	VESLG  $44, h1, h1 \ // shift limb 1 44 bits, leaving 20
	VO     h0, h1, h0  \ // combine h0 with 20 bits from limb 1
	VESRLG $20, h2, h1 \ // put top 24 bits of limb 1 into h1
	VLEIG  $1, $0, h1  \ // clear h2 stuff from lower half of h1
	VO     h0, h1, h0  \ // h0 now has 88 bits (limb 0 and 1)
	VLEIG  $0, $0, h2  \ // clear upper half of h2
	VESRLG $40, h2, h1 \ // h1 now has upper two bits of result
	VLEIB  $7, $88, h1 \ // for byte shift (11 bytes)
	VSLB   h1, h2, h2  \ // shift h2 11 bytes to the left
	VO     h0, h2, h0  \ // combine h0 with 20 bits from limb 1
	VLEIG  $0, $0, h1  \ // clear upper half of h1

// if h > 2**130-5 then h -= 2**130-5
// input: h0, h1
// temp: t0, t1, t2
// output: h0
#define MOD(h0, h1, t0, t1, t2) \
	VZERO t0          \
	VLEIG $1, $5, t0  \
	VACCQ h0, t0, t1  \
	VAQ   h0, t0, t0  \
	VONE  t2          \
	VLEIG $1, $-4, t2 \
	VAQ   t2, t1, t1  \
	VACCQ h1, t1, t1  \
	VONE  t2          \
	VAQ   t2, t1, t1  \
	VN    h0, t1, t2  \
	VNC   t0, t1, t1  \
	VO    t1, t2, h0  \

// func poly1305vmsl(out *[16]byte, m *byte, mlen uint64, key *[32]key)
TEXT poly1305vmsl(SB), $0-32
	// This code processes 6 + up to 4 blocks (32 bytes) per iteration
	// using the algorithm described in:
	// NEON crypto, Daniel J. Bernstein & Peter Schwabe
	// https://cryptojedi.org/papers/neoncrypto-20120320.pdf
	// And as moddified for VMSL as described in
	// Accelerating Poly1305 Cryptographic Message Authentication on the z14
	// O'Farrell et al, CASCON 2017, p48-55
	// https://ibm.ent.box.com/s/jf9gedj0e9d2vjctfyh186shaztavnht

	LMG   out+0(FP), R1, R4 // R1=out, R2=m, R3=mlen, R4=key
	VZERO V0                // c

	// load EX0, EX1 and EX2
	MOVD $constants<>(SB), R5
	VLM  (R5), EX0, EX2        // c

	// setup r
	VL    (R4), T_0
	MOVD  $keyMask<>(SB), R6
	VL    (R6), T_1
	VN    T_0, T_1, T_0
	VZERO T_2                 // limbs for r
	VZERO T_3
	VZERO T_4
	EXPACC2(T_0, T_2, T_3, T_4, T_1, T_5, T_7)

	// T_2, T_3, T_4: [0, r]

	// setup r*20
	VLEIG $0, $0, T_0
	VLEIG $1, $20, T_0       // T_0: [0, 20]
	VZERO T_5
	VZERO T_6
	VMSLG T_0, T_3, T_5, T_5
	VMSLG T_0, T_4, T_6, T_6

	// store r for final block in GR
	VLGVG $1, T_2, RSAVE_0  // c
	VLGVG $1, T_3, RSAVE_1  // c
	VLGVG $1, T_4, RSAVE_2  // c
	VLGVG $1, T_5, R5SAVE_1 // c
	VLGVG $1, T_6, R5SAVE_2 // c

	// initialize h
	VZERO H0_0
	VZERO H1_0
	VZERO H2_0
	VZERO H0_1
	VZERO H1_1
	VZERO H2_1

	// initialize pointer for reduce constants
	MOVD $reduce<>(SB), R12

	// calculate r**2 and 20*(r**2)
	VZERO R_0
	VZERO R_1
	VZERO R_2
	SQUARE(T_2, T_3, T_4, T_6, R_0, R_1, R_2, T_1, T_5, T_7)
	REDUCE2(R_0, R_1, R_2, M0, M1, M2, M3, M4, R5_1, R5_2, M5, T_1)
	VZERO R5_1
	VZERO R5_2
	VMSLG T_0, R_1, R5_1, R5_1
	VMSLG T_0, R_2, R5_2, R5_2

	// skip r**4 calculation if 3 blocks or less
	CMPBLE R3, $48, b4

	// calculate r**4 and 20*(r**4)
	VZERO T_8
	VZERO T_9
	VZERO T_10
	SQUARE(R_0, R_1, R_2, R5_2, T_8, T_9, T_10, T_1, T_5, T_7)
	REDUCE2(T_8, T_9, T_10, M0, M1, M2, M3, M4, T_2, T_3, M5, T_1)
	VZERO T_2
	VZERO T_3
	VMSLG T_0, T_9, T_2, T_2
	VMSLG T_0, T_10, T_3, T_3

	// put r**2 to the right and r**4 to the left of R_0, R_1, R_2
	VSLDB $8, T_8, T_8, T_8
	VSLDB $8, T_9, T_9, T_9
	VSLDB $8, T_10, T_10, T_10
	VSLDB $8, T_2, T_2, T_2
	VSLDB $8, T_3, T_3, T_3

	VO T_8, R_0, R_0
	VO T_9, R_1, R_1
	VO T_10, R_2, R_2
	VO T_2, R5_1, R5_1
	VO T_3, R5_2, R5_2

	CMPBLE R3, $80, load // less than or equal to 5 blocks in message

	// 6(or 5+1) blocks
	SUB    $81, R3
	VLM    (R2), M0, M4
	VLL    R3, 80(R2), M5
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBGE R3, $16, 2(PC)
	VLVGB  R3, R0, M5
	MOVD   $96(R2), R2
	EXPACC(M0, M1, H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_0, T_1, T_2, T_3)
	EXPACC(M2, M3, H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_0, T_1, T_2, T_3)
	VLEIB  $2, $1, H2_0
	VLEIB  $2, $1, H2_1
	VLEIB  $10, $1, H2_0
	VLEIB  $10, $1, H2_1

	VZERO  M0
	VZERO  M1
	VZERO  M2
	VZERO  M3
	VZERO  T_4
	VZERO  T_10
	EXPACC(M4, M5, M0, M1, M2, M3, T_4, T_10, T_0, T_1, T_2, T_3)
	VLR    T_4, M4
	VLEIB  $10, $1, M2
	CMPBLT R3, $16, 2(PC)
	VLEIB  $10, $1, T_10
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, T_10, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_10, M0, M1, M2, M3, M4, T_4, T_5, T_2, T_7, T_8, T_9)
	VMRHG  V0, H0_1, H0_0
	VMRHG  V0, H1_1, H1_0
	VMRHG  V0, H2_1, H2_0
	VMRLG  V0, H0_1, H0_1
	VMRLG  V0, H1_1, H1_1
	VMRLG  V0, H2_1, H2_1

	SUB    $16, R3
	CMPBLE R3, $0, square

load:
	// load EX0, EX1 and EX2
	MOVD $c<>(SB), R5
	VLM  (R5), EX0, EX2

loop:
	CMPBLE R3, $64, add // b4	// last 4 or less blocks left

	// next 4 full blocks
	VLM  (R2), M2, M5
	SUB  $64, R3
	MOVD $64(R2), R2
	REDUCE(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_10, M0, M1, T_0, T_1, T_3, T_4, T_5, T_2, T_7, T_8, T_9)

	// expacc in-lined to create [m2, m3] limbs
	VGBM   $0x3f3f, T_0     // 44 bit clear mask
	VGBM   $0x1f1f, T_1     // 40 bit clear mask
	VPERM  M2, M3, EX0, T_3
	VESRLG $4, T_0, T_0     // 44 bit clear mask ready
	VPERM  M2, M3, EX1, T_4
	VPERM  M2, M3, EX2, T_5
	VN     T_0, T_3, T_3
	VESRLG $4, T_4, T_4
	VN     T_1, T_5, T_5
	VN     T_0, T_4, T_4
	VMRHG  H0_1, T_3, H0_0
	VMRHG  H1_1, T_4, H1_0
	VMRHG  H2_1, T_5, H2_0
	VMRLG  H0_1, T_3, H0_1
	VMRLG  H1_1, T_4, H1_1
	VMRLG  H2_1, T_5, H2_1
	VLEIB  $10, $1, H2_0
	VLEIB  $10, $1, H2_1
	VPERM  M4, M5, EX0, T_3
	VPERM  M4, M5, EX1, T_4
	VPERM  M4, M5, EX2, T_5
	VN     T_0, T_3, T_3
	VESRLG $4, T_4, T_4
	VN     T_1, T_5, T_5
	VN     T_0, T_4, T_4
	VMRHG  V0, T_3, M0
	VMRHG  V0, T_4, M1
	VMRHG  V0, T_5, M2
	VMRLG  V0, T_3, M3
	VMRLG  V0, T_4, M4
	VMRLG  V0, T_5, M5
	VLEIB  $10, $1, M2
	VLEIB  $10, $1, M5

	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	CMPBNE R3, $0, loop
	REDUCE(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_10, M0, M1, M3, M4, M5, T_4, T_5, T_2, T_7, T_8, T_9)
	VMRHG  V0, H0_1, H0_0
	VMRHG  V0, H1_1, H1_0
	VMRHG  V0, H2_1, H2_0
	VMRLG  V0, H0_1, H0_1
	VMRLG  V0, H1_1, H1_1
	VMRLG  V0, H2_1, H2_1

	// load EX0, EX1, EX2
	MOVD $constants<>(SB), R5
	VLM  (R5), EX0, EX2

	// sum vectors
	VAQ H0_0, H0_1, H0_0
	VAQ H1_0, H1_1, H1_0
	VAQ H2_0, H2_1, H2_0

	// h may be >= 2*(2**130-5) so we need to reduce it again
	// M0...M4 are used as temps here
	REDUCE2(H0_0, H1_0, H2_0, M0, M1, M2, M3, M4, T_9, T_10, H0_1, M5)

next:  // carry h1->h2
	VLEIB  $7, $0x28, T_1
	VREPIB $4, T_2
	VGBM   $0x003F, T_3
	VESRLG $4, T_3

	// byte shift
	VSRLB T_1, H1_0, T_4

	// bit shift
	VSRL T_2, T_4, T_4

	// clear h1 carry bits
	VN T_3, H1_0, H1_0

	// add carry
	VAQ T_4, H2_0, H2_0

	// h is now < 2*(2**130-5)
	// pack h into h1 (hi) and h0 (lo)
	PACK(H0_0, H1_0, H2_0)

	// if h > 2**130-5 then h -= 2**130-5
	MOD(H0_0, H1_0, T_0, T_1, T_2)

	// h += s
	MOVD  $bswapMask<>(SB), R5
	VL    (R5), T_1
	VL    16(R4), T_0
	VPERM T_0, T_0, T_1, T_0    // reverse bytes (to big)
	VAQ   T_0, H0_0, H0_0
	VPERM H0_0, H0_0, T_1, H0_0 // reverse bytes (to little)
	VST   H0_0, (R1)
	RET

add:
	// load EX0, EX1, EX2
	MOVD $constants<>(SB), R5
	VLM  (R5), EX0, EX2

	REDUCE(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_10, M0, M1, M3, M4, M5, T_4, T_5, T_2, T_7, T_8, T_9)
	VMRHG  V0, H0_1, H0_0
	VMRHG  V0, H1_1, H1_0
	VMRHG  V0, H2_1, H2_0
	VMRLG  V0, H0_1, H0_1
	VMRLG  V0, H1_1, H1_1
	VMRLG  V0, H2_1, H2_1
	CMPBLE R3, $64, b4

b4:
	CMPBLE R3, $48, b3 // 3 blocks or less

	// 4(3+1) blocks remaining
	SUB    $49, R3
	VLM    (R2), M0, M2
	VLL    R3, 48(R2), M3
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBEQ R3, $16, 2(PC)
	VLVGB  R3, R0, M3
	MOVD   $64(R2), R2
	EXPACC(M0, M1, H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_0, T_1, T_2, T_3)
	VLEIB  $10, $1, H2_0
	VLEIB  $10, $1, H2_1
	VZERO  M0
	VZERO  M1
	VZERO  M4
	VZERO  M5
	VZERO  T_4
	VZERO  T_10
	EXPACC(M2, M3, M0, M1, M4, M5, T_4, T_10, T_0, T_1, T_2, T_3)
	VLR    T_4, M2
	VLEIB  $10, $1, M4
	CMPBNE R3, $16, 2(PC)
	VLEIB  $10, $1, T_10
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M4, M5, M2, T_10, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_10, M0, M1, M3, M4, M5, T_4, T_5, T_2, T_7, T_8, T_9)
	VMRHG  V0, H0_1, H0_0
	VMRHG  V0, H1_1, H1_0
	VMRHG  V0, H2_1, H2_0
	VMRLG  V0, H0_1, H0_1
	VMRLG  V0, H1_1, H1_1
	VMRLG  V0, H2_1, H2_1
	SUB    $16, R3
	CMPBLE R3, $0, square // this condition must always hold true!

b3:
	CMPBLE R3, $32, b2

	// 3 blocks remaining

	// setup [r,r]
	VSLDB $8, R_0, R_0, R_0
	VSLDB $8, R_1, R_1, R_1
	VSLDB $8, R_2, R_2, R_2
	VSLDB $8, R5_1, R5_1, R5_1
	VSLDB $8, R5_2, R5_2, R5_2

	VLVGG $1, RSAVE_0, R_0
	VLVGG $1, RSAVE_1, R_1
	VLVGG $1, RSAVE_2, R_2
	VLVGG $1, R5SAVE_1, R5_1
	VLVGG $1, R5SAVE_2, R5_2

	// setup [h0, h1]
	VSLDB $8, H0_0, H0_0, H0_0
	VSLDB $8, H1_0, H1_0, H1_0
	VSLDB $8, H2_0, H2_0, H2_0
	VO    H0_1, H0_0, H0_0
	VO    H1_1, H1_0, H1_0
	VO    H2_1, H2_0, H2_0
	VZERO H0_1
	VZERO H1_1
	VZERO H2_1

	VZERO M0
	VZERO M1
	VZERO M2
	VZERO M3
	VZERO M4
	VZERO M5

	// H*[r**2, r]
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M0, M1, M2, M3, M4, H0_1, H1_1, T_10, M5)

	SUB    $33, R3
	VLM    (R2), M0, M1
	VLL    R3, 32(R2), M2
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBEQ R3, $16, 2(PC)
	VLVGB  R3, R0, M2

	// H += m0
	VZERO T_1
	VZERO T_2
	VZERO T_3
	EXPACC2(M0, T_1, T_2, T_3, T_4, T_5, T_6)
	VLEIB $10, $1, T_3
	VAG   H0_0, T_1, H0_0
	VAG   H1_0, T_2, H1_0
	VAG   H2_0, T_3, H2_0

	VZERO M0
	VZERO M3
	VZERO M4
	VZERO M5
	VZERO T_10

	// (H+m0)*r
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M3, M4, M5, V0, T_10, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M0, M3, M4, M5, T_10, H0_1, H1_1, H2_1, T_9)

	// H += m1
	VZERO V0
	VZERO T_1
	VZERO T_2
	VZERO T_3
	EXPACC2(M1, T_1, T_2, T_3, T_4, T_5, T_6)
	VLEIB $10, $1, T_3
	VAQ   H0_0, T_1, H0_0
	VAQ   H1_0, T_2, H1_0
	VAQ   H2_0, T_3, H2_0
	REDUCE2(H0_0, H1_0, H2_0, M0, M3, M4, M5, T_9, H0_1, H1_1, H2_1, T_10)

	// [H, m2] * [r**2, r]
	EXPACC2(M2, H0_0, H1_0, H2_0, T_1, T_2, T_3)
	CMPBNE R3, $16, 2(PC)
	VLEIB  $10, $1, H2_0
	VZERO  M0
	VZERO  M1
	VZERO  M2
	VZERO  M3
	VZERO  M4
	VZERO  M5
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M0, M1, M2, M3, M4, H0_1, H1_1, M5, T_10)
	SUB    $16, R3
	CMPBLE R3, $0, next   // this condition must always hold true!

b2:
	CMPBLE R3, $16, b1

	// 2 blocks remaining

	// setup [r,r]
	VSLDB $8, R_0, R_0, R_0
	VSLDB $8, R_1, R_1, R_1
	VSLDB $8, R_2, R_2, R_2
	VSLDB $8, R5_1, R5_1, R5_1
	VSLDB $8, R5_2, R5_2, R5_2

	VLVGG $1, RSAVE_0, R_0
	VLVGG $1, RSAVE_1, R_1
	VLVGG $1, RSAVE_2, R_2
	VLVGG $1, R5SAVE_1, R5_1
	VLVGG $1, R5SAVE_2, R5_2

	// setup [h0, h1]
	VSLDB $8, H0_0, H0_0, H0_0
	VSLDB $8, H1_0, H1_0, H1_0
	VSLDB $8, H2_0, H2_0, H2_0
	VO    H0_1, H0_0, H0_0
	VO    H1_1, H1_0, H1_0
	VO    H2_1, H2_0, H2_0
	VZERO H0_1
	VZERO H1_1
	VZERO H2_1

	VZERO M0
	VZERO M1
	VZERO M2
	VZERO M3
	VZERO M4
	VZERO M5

	// H*[r**2, r]
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, T_10, M0, M1, M2, M3, M4, T_4, T_5, T_2, T_7, T_8, T_9)
	VMRHG V0, H0_1, H0_0
	VMRHG V0, H1_1, H1_0
	VMRHG V0, H2_1, H2_0
	VMRLG V0, H0_1, H0_1
	VMRLG V0, H1_1, H1_1
	VMRLG V0, H2_1, H2_1

	// move h to the left and 0s at the right
	VSLDB $8, H0_0, H0_0, H0_0
	VSLDB $8, H1_0, H1_0, H1_0
	VSLDB $8, H2_0, H2_0, H2_0

	// get message blocks and append 1 to start
	SUB    $17, R3
	VL     (R2), M0
	VLL    R3, 16(R2), M1
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBEQ R3, $16, 2(PC)
	VLVGB  R3, R0, M1
	VZERO  T_6
	VZERO  T_7
	VZERO  T_8
	EXPACC2(M0, T_6, T_7, T_8, T_1, T_2, T_3)
	EXPACC2(M1, T_6, T_7, T_8, T_1, T_2, T_3)
	VLEIB  $2, $1, T_8
	CMPBNE R3, $16, 2(PC)
	VLEIB  $10, $1, T_8

	// add [m0, m1] to h
	VAG H0_0, T_6, H0_0
	VAG H1_0, T_7, H1_0
	VAG H2_0, T_8, H2_0

	VZERO M2
	VZERO M3
	VZERO M4
	VZERO M5
	VZERO T_10
	VZERO M0

	// at this point R_0 .. R5_2 look like [r**2, r]
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M2, M3, M4, M5, T_10, M0, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M2, M3, M4, M5, T_9, H0_1, H1_1, H2_1, T_10)
	SUB    $16, R3, R3
	CMPBLE R3, $0, next

b1:
	CMPBLE R3, $0, next

	// 1 block remaining

	// setup [r,r]
	VSLDB $8, R_0, R_0, R_0
	VSLDB $8, R_1, R_1, R_1
	VSLDB $8, R_2, R_2, R_2
	VSLDB $8, R5_1, R5_1, R5_1
	VSLDB $8, R5_2, R5_2, R5_2

	VLVGG $1, RSAVE_0, R_0
	VLVGG $1, RSAVE_1, R_1
	VLVGG $1, RSAVE_2, R_2
	VLVGG $1, R5SAVE_1, R5_1
	VLVGG $1, R5SAVE_2, R5_2

	// setup [h0, h1]
	VSLDB $8, H0_0, H0_0, H0_0
	VSLDB $8, H1_0, H1_0, H1_0
	VSLDB $8, H2_0, H2_0, H2_0
	VO    H0_1, H0_0, H0_0
	VO    H1_1, H1_0, H1_0
	VO    H2_1, H2_0, H2_0
	VZERO H0_1
	VZERO H1_1
	VZERO H2_1

	VZERO M0
	VZERO M1
	VZERO M2
	VZERO M3
	VZERO M4
	VZERO M5

	// H*[r**2, r]
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M0, M1, M2, M3, M4, T_9, T_10, H0_1, M5)

	// set up [0, m0] limbs
	SUB    $1, R3
	VLL    R3, (R2), M0
	ADD    $1, R3
	MOVBZ  $1, R0
	CMPBEQ R3, $16, 2(PC)
	VLVGB  R3, R0, M0
	VZERO  T_1
	VZERO  T_2
	VZERO  T_3
	EXPACC2(M0, T_1, T_2, T_3, T_4, T_5, T_6)// limbs: [0, m]
	CMPBNE R3, $16, 2(PC)
	VLEIB  $10, $1, T_3

	// h+m0
	VAQ H0_0, T_1, H0_0
	VAQ H1_0, T_2, H1_0
	VAQ H2_0, T_3, H2_0

	VZERO M0
	VZERO M1
	VZERO M2
	VZERO M3
	VZERO M4
	VZERO M5
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M0, M1, M2, M3, M4, T_9, T_10, H0_1, M5)

	BR next

square:
	// setup [r,r]
	VSLDB $8, R_0, R_0, R_0
	VSLDB $8, R_1, R_1, R_1
	VSLDB $8, R_2, R_2, R_2
	VSLDB $8, R5_1, R5_1, R5_1
	VSLDB $8, R5_2, R5_2, R5_2

	VLVGG $1, RSAVE_0, R_0
	VLVGG $1, RSAVE_1, R_1
	VLVGG $1, RSAVE_2, R_2
	VLVGG $1, R5SAVE_1, R5_1
	VLVGG $1, R5SAVE_2, R5_2

	// setup [h0, h1]
	VSLDB $8, H0_0, H0_0, H0_0
	VSLDB $8, H1_0, H1_0, H1_0
	VSLDB $8, H2_0, H2_0, H2_0
	VO    H0_1, H0_0, H0_0
	VO    H1_1, H1_0, H1_0
	VO    H2_1, H2_0, H2_0
	VZERO H0_1
	VZERO H1_1
	VZERO H2_1

	VZERO M0
	VZERO M1
	VZERO M2
	VZERO M3
	VZERO M4
	VZERO M5

	// (h0*r**2) + (h1*r)
	MULTIPLY(H0_0, H1_0, H2_0, H0_1, H1_1, H2_1, R_0, R_1, R_2, R5_1, R5_2, M0, M1, M2, M3, M4, M5, T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9)
	REDUCE2(H0_0, H1_0, H2_0, M0, M1, M2, M3, M4, T_9, T_10, H0_1, M5)
	BR next

+ f f8cffa3cc6a911bb0ddcb7f049d809cc261faae54867be7d8e6e64427dc6a70e vendor/golang.org/x/crypto/salsa20/salsa/hsalsa20.go
utf8file 145
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package salsa provides low-level access to functions in the Salsa family.
package salsa // import "golang.org/x/crypto/salsa20/salsa"

// Sigma is the Salsa20 constant for 256-bit keys.
var Sigma = [16]byte{'e', 'x', 'p', 'a', 'n', 'd', ' ', '3', '2', '-', 'b', 'y', 't', 'e', ' ', 'k'}

// HSalsa20 applies the HSalsa20 core function to a 16-byte input in, 32-byte
// key k, and 16-byte constant c, and puts the result into the 32-byte array
// out.
func HSalsa20(out *[32]byte, in *[16]byte, k *[32]byte, c *[16]byte) {
	x0 := uint32(c[0]) | uint32(c[1])<<8 | uint32(c[2])<<16 | uint32(c[3])<<24
	x1 := uint32(k[0]) | uint32(k[1])<<8 | uint32(k[2])<<16 | uint32(k[3])<<24
	x2 := uint32(k[4]) | uint32(k[5])<<8 | uint32(k[6])<<16 | uint32(k[7])<<24
	x3 := uint32(k[8]) | uint32(k[9])<<8 | uint32(k[10])<<16 | uint32(k[11])<<24
	x4 := uint32(k[12]) | uint32(k[13])<<8 | uint32(k[14])<<16 | uint32(k[15])<<24
	x5 := uint32(c[4]) | uint32(c[5])<<8 | uint32(c[6])<<16 | uint32(c[7])<<24
	x6 := uint32(in[0]) | uint32(in[1])<<8 | uint32(in[2])<<16 | uint32(in[3])<<24
	x7 := uint32(in[4]) | uint32(in[5])<<8 | uint32(in[6])<<16 | uint32(in[7])<<24
	x8 := uint32(in[8]) | uint32(in[9])<<8 | uint32(in[10])<<16 | uint32(in[11])<<24
	x9 := uint32(in[12]) | uint32(in[13])<<8 | uint32(in[14])<<16 | uint32(in[15])<<24
	x10 := uint32(c[8]) | uint32(c[9])<<8 | uint32(c[10])<<16 | uint32(c[11])<<24
	x11 := uint32(k[16]) | uint32(k[17])<<8 | uint32(k[18])<<16 | uint32(k[19])<<24
	x12 := uint32(k[20]) | uint32(k[21])<<8 | uint32(k[22])<<16 | uint32(k[23])<<24
	x13 := uint32(k[24]) | uint32(k[25])<<8 | uint32(k[26])<<16 | uint32(k[27])<<24
	x14 := uint32(k[28]) | uint32(k[29])<<8 | uint32(k[30])<<16 | uint32(k[31])<<24
	x15 := uint32(c[12]) | uint32(c[13])<<8 | uint32(c[14])<<16 | uint32(c[15])<<24

	for i := 0; i < 20; i += 2 {
		u := x0 + x12
		x4 ^= u<<7 | u>>(32-7)
		u = x4 + x0
		x8 ^= u<<9 | u>>(32-9)
		u = x8 + x4
		x12 ^= u<<13 | u>>(32-13)
		u = x12 + x8
		x0 ^= u<<18 | u>>(32-18)

		u = x5 + x1
		x9 ^= u<<7 | u>>(32-7)
		u = x9 + x5
		x13 ^= u<<9 | u>>(32-9)
		u = x13 + x9
		x1 ^= u<<13 | u>>(32-13)
		u = x1 + x13
		x5 ^= u<<18 | u>>(32-18)

		u = x10 + x6
		x14 ^= u<<7 | u>>(32-7)
		u = x14 + x10
		x2 ^= u<<9 | u>>(32-9)
		u = x2 + x14
		x6 ^= u<<13 | u>>(32-13)
		u = x6 + x2
		x10 ^= u<<18 | u>>(32-18)

		u = x15 + x11
		x3 ^= u<<7 | u>>(32-7)
		u = x3 + x15
		x7 ^= u<<9 | u>>(32-9)
		u = x7 + x3
		x11 ^= u<<13 | u>>(32-13)
		u = x11 + x7
		x15 ^= u<<18 | u>>(32-18)

		u = x0 + x3
		x1 ^= u<<7 | u>>(32-7)
		u = x1 + x0
		x2 ^= u<<9 | u>>(32-9)
		u = x2 + x1
		x3 ^= u<<13 | u>>(32-13)
		u = x3 + x2
		x0 ^= u<<18 | u>>(32-18)

		u = x5 + x4
		x6 ^= u<<7 | u>>(32-7)
		u = x6 + x5
		x7 ^= u<<9 | u>>(32-9)
		u = x7 + x6
		x4 ^= u<<13 | u>>(32-13)
		u = x4 + x7
		x5 ^= u<<18 | u>>(32-18)

		u = x10 + x9
		x11 ^= u<<7 | u>>(32-7)
		u = x11 + x10
		x8 ^= u<<9 | u>>(32-9)
		u = x8 + x11
		x9 ^= u<<13 | u>>(32-13)
		u = x9 + x8
		x10 ^= u<<18 | u>>(32-18)

		u = x15 + x14
		x12 ^= u<<7 | u>>(32-7)
		u = x12 + x15
		x13 ^= u<<9 | u>>(32-9)
		u = x13 + x12
		x14 ^= u<<13 | u>>(32-13)
		u = x14 + x13
		x15 ^= u<<18 | u>>(32-18)
	}
	out[0] = byte(x0)
	out[1] = byte(x0 >> 8)
	out[2] = byte(x0 >> 16)
	out[3] = byte(x0 >> 24)

	out[4] = byte(x5)
	out[5] = byte(x5 >> 8)
	out[6] = byte(x5 >> 16)
	out[7] = byte(x5 >> 24)

	out[8] = byte(x10)
	out[9] = byte(x10 >> 8)
	out[10] = byte(x10 >> 16)
	out[11] = byte(x10 >> 24)

	out[12] = byte(x15)
	out[13] = byte(x15 >> 8)
	out[14] = byte(x15 >> 16)
	out[15] = byte(x15 >> 24)

	out[16] = byte(x6)
	out[17] = byte(x6 >> 8)
	out[18] = byte(x6 >> 16)
	out[19] = byte(x6 >> 24)

	out[20] = byte(x7)
	out[21] = byte(x7 >> 8)
	out[22] = byte(x7 >> 16)
	out[23] = byte(x7 >> 24)

	out[24] = byte(x8)
	out[25] = byte(x8 >> 8)
	out[26] = byte(x8 >> 16)
	out[27] = byte(x8 >> 24)

	out[28] = byte(x9)
	out[29] = byte(x9 >> 8)
	out[30] = byte(x9 >> 16)
	out[31] = byte(x9 >> 24)
}

+ f a59ddd01915d7260b1e26fd652ce29879a39cfaa87afde06e65754d7ec1717b6 vendor/golang.org/x/crypto/salsa20/salsa/salsa208.go
utf8file 200
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package salsa

// Core208 applies the Salsa20/8 core function to the 64-byte array in and puts
// the result into the 64-byte array out. The input and output may be the same array.
func Core208(out *[64]byte, in *[64]byte) {
	j0 := uint32(in[0]) | uint32(in[1])<<8 | uint32(in[2])<<16 | uint32(in[3])<<24
	j1 := uint32(in[4]) | uint32(in[5])<<8 | uint32(in[6])<<16 | uint32(in[7])<<24
	j2 := uint32(in[8]) | uint32(in[9])<<8 | uint32(in[10])<<16 | uint32(in[11])<<24
	j3 := uint32(in[12]) | uint32(in[13])<<8 | uint32(in[14])<<16 | uint32(in[15])<<24
	j4 := uint32(in[16]) | uint32(in[17])<<8 | uint32(in[18])<<16 | uint32(in[19])<<24
	j5 := uint32(in[20]) | uint32(in[21])<<8 | uint32(in[22])<<16 | uint32(in[23])<<24
	j6 := uint32(in[24]) | uint32(in[25])<<8 | uint32(in[26])<<16 | uint32(in[27])<<24
	j7 := uint32(in[28]) | uint32(in[29])<<8 | uint32(in[30])<<16 | uint32(in[31])<<24
	j8 := uint32(in[32]) | uint32(in[33])<<8 | uint32(in[34])<<16 | uint32(in[35])<<24
	j9 := uint32(in[36]) | uint32(in[37])<<8 | uint32(in[38])<<16 | uint32(in[39])<<24
	j10 := uint32(in[40]) | uint32(in[41])<<8 | uint32(in[42])<<16 | uint32(in[43])<<24
	j11 := uint32(in[44]) | uint32(in[45])<<8 | uint32(in[46])<<16 | uint32(in[47])<<24
	j12 := uint32(in[48]) | uint32(in[49])<<8 | uint32(in[50])<<16 | uint32(in[51])<<24
	j13 := uint32(in[52]) | uint32(in[53])<<8 | uint32(in[54])<<16 | uint32(in[55])<<24
	j14 := uint32(in[56]) | uint32(in[57])<<8 | uint32(in[58])<<16 | uint32(in[59])<<24
	j15 := uint32(in[60]) | uint32(in[61])<<8 | uint32(in[62])<<16 | uint32(in[63])<<24

	x0, x1, x2, x3, x4, x5, x6, x7, x8 := j0, j1, j2, j3, j4, j5, j6, j7, j8
	x9, x10, x11, x12, x13, x14, x15 := j9, j10, j11, j12, j13, j14, j15

	for i := 0; i < 8; i += 2 {
		u := x0 + x12
		x4 ^= u<<7 | u>>(32-7)
		u = x4 + x0
		x8 ^= u<<9 | u>>(32-9)
		u = x8 + x4
		x12 ^= u<<13 | u>>(32-13)
		u = x12 + x8
		x0 ^= u<<18 | u>>(32-18)

		u = x5 + x1
		x9 ^= u<<7 | u>>(32-7)
		u = x9 + x5
		x13 ^= u<<9 | u>>(32-9)
		u = x13 + x9
		x1 ^= u<<13 | u>>(32-13)
		u = x1 + x13
		x5 ^= u<<18 | u>>(32-18)

		u = x10 + x6
		x14 ^= u<<7 | u>>(32-7)
		u = x14 + x10
		x2 ^= u<<9 | u>>(32-9)
		u = x2 + x14
		x6 ^= u<<13 | u>>(32-13)
		u = x6 + x2
		x10 ^= u<<18 | u>>(32-18)

		u = x15 + x11
		x3 ^= u<<7 | u>>(32-7)
		u = x3 + x15
		x7 ^= u<<9 | u>>(32-9)
		u = x7 + x3
		x11 ^= u<<13 | u>>(32-13)
		u = x11 + x7
		x15 ^= u<<18 | u>>(32-18)

		u = x0 + x3
		x1 ^= u<<7 | u>>(32-7)
		u = x1 + x0
		x2 ^= u<<9 | u>>(32-9)
		u = x2 + x1
		x3 ^= u<<13 | u>>(32-13)
		u = x3 + x2
		x0 ^= u<<18 | u>>(32-18)

		u = x5 + x4
		x6 ^= u<<7 | u>>(32-7)
		u = x6 + x5
		x7 ^= u<<9 | u>>(32-9)
		u = x7 + x6
		x4 ^= u<<13 | u>>(32-13)
		u = x4 + x7
		x5 ^= u<<18 | u>>(32-18)

		u = x10 + x9
		x11 ^= u<<7 | u>>(32-7)
		u = x11 + x10
		x8 ^= u<<9 | u>>(32-9)
		u = x8 + x11
		x9 ^= u<<13 | u>>(32-13)
		u = x9 + x8
		x10 ^= u<<18 | u>>(32-18)

		u = x15 + x14
		x12 ^= u<<7 | u>>(32-7)
		u = x12 + x15
		x13 ^= u<<9 | u>>(32-9)
		u = x13 + x12
		x14 ^= u<<13 | u>>(32-13)
		u = x14 + x13
		x15 ^= u<<18 | u>>(32-18)
	}
	x0 += j0
	x1 += j1
	x2 += j2
	x3 += j3
	x4 += j4
	x5 += j5
	x6 += j6
	x7 += j7
	x8 += j8
	x9 += j9
	x10 += j10
	x11 += j11
	x12 += j12
	x13 += j13
	x14 += j14
	x15 += j15

	out[0] = byte(x0)
	out[1] = byte(x0 >> 8)
	out[2] = byte(x0 >> 16)
	out[3] = byte(x0 >> 24)

	out[4] = byte(x1)
	out[5] = byte(x1 >> 8)
	out[6] = byte(x1 >> 16)
	out[7] = byte(x1 >> 24)

	out[8] = byte(x2)
	out[9] = byte(x2 >> 8)
	out[10] = byte(x2 >> 16)
	out[11] = byte(x2 >> 24)

	out[12] = byte(x3)
	out[13] = byte(x3 >> 8)
	out[14] = byte(x3 >> 16)
	out[15] = byte(x3 >> 24)

	out[16] = byte(x4)
	out[17] = byte(x4 >> 8)
	out[18] = byte(x4 >> 16)
	out[19] = byte(x4 >> 24)

	out[20] = byte(x5)
	out[21] = byte(x5 >> 8)
	out[22] = byte(x5 >> 16)
	out[23] = byte(x5 >> 24)

	out[24] = byte(x6)
	out[25] = byte(x6 >> 8)
	out[26] = byte(x6 >> 16)
	out[27] = byte(x6 >> 24)

	out[28] = byte(x7)
	out[29] = byte(x7 >> 8)
	out[30] = byte(x7 >> 16)
	out[31] = byte(x7 >> 24)

	out[32] = byte(x8)
	out[33] = byte(x8 >> 8)
	out[34] = byte(x8 >> 16)
	out[35] = byte(x8 >> 24)

	out[36] = byte(x9)
	out[37] = byte(x9 >> 8)
	out[38] = byte(x9 >> 16)
	out[39] = byte(x9 >> 24)

	out[40] = byte(x10)
	out[41] = byte(x10 >> 8)
	out[42] = byte(x10 >> 16)
	out[43] = byte(x10 >> 24)

	out[44] = byte(x11)
	out[45] = byte(x11 >> 8)
	out[46] = byte(x11 >> 16)
	out[47] = byte(x11 >> 24)

	out[48] = byte(x12)
	out[49] = byte(x12 >> 8)
	out[50] = byte(x12 >> 16)
	out[51] = byte(x12 >> 24)

	out[52] = byte(x13)
	out[53] = byte(x13 >> 8)
	out[54] = byte(x13 >> 16)
	out[55] = byte(x13 >> 24)

	out[56] = byte(x14)
	out[57] = byte(x14 >> 8)
	out[58] = byte(x14 >> 16)
	out[59] = byte(x14 >> 24)

	out[60] = byte(x15)
	out[61] = byte(x15 >> 8)
	out[62] = byte(x15 >> 16)
	out[63] = byte(x15 >> 24)
}

+ f 66a49e9d4a6340458f3d57f6d6f725ffca8798a7a7caef6faf3526aa8514d664 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_amd64.go
utf8file 24
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!appengine,!gccgo

package salsa

//go:noescape

// salsa2020XORKeyStream is implemented in salsa20_amd64.s.
func salsa2020XORKeyStream(out, in *byte, n uint64, nonce, key *byte)

// XORKeyStream crypts bytes from in to out using the given key and counters.
// In and out must overlap entirely or not at all. Counter
// contains the raw salsa20 counter bytes (both nonce and block counter).
func XORKeyStream(out, in []byte, counter *[16]byte, key *[32]byte) {
	if len(in) == 0 {
		return
	}
	_ = out[len(in)-1]
	salsa2020XORKeyStream(&out[0], &in[0], uint64(len(in)), &counter[0], &key[0])
}

+ f 90ea1a8ff724a32a20dc5882a82b480c4fc7c9246c7da1e2ad085ba55b7b4d0a vendor/golang.org/x/crypto/salsa20/salsa/salsa20_amd64.s
utf8file 884
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!appengine,!gccgo

// This code was translated into a form compatible with 6a from the public
// domain sources in SUPERCOP: https://bench.cr.yp.to/supercop.html

// func salsa2020XORKeyStream(out, in *byte, n uint64, nonce, key *byte)
// This needs up to 64 bytes at 360(SP); hence the non-obvious frame size.
TEXT salsa2020XORKeyStream(SB),0,$456-40 // frame = 424 + 32 byte alignment
	MOVQ out+0(FP),DI
	MOVQ in+8(FP),SI
	MOVQ n+16(FP),DX
	MOVQ nonce+24(FP),CX
	MOVQ key+32(FP),R8

	MOVQ SP,R12
	MOVQ SP,R9
	ADDQ $31, R9
	ANDQ $~31, R9
	MOVQ R9, SP

	MOVQ DX,R9
	MOVQ CX,DX
	MOVQ R8,R10
	CMPQ R9,$0
	JBE DONE
	START:
	MOVL 20(R10),CX
	MOVL 0(R10),R8
	MOVL 0(DX),AX
	MOVL 16(R10),R11
	MOVL CX,0(SP)
	MOVL R8, 4 (SP)
	MOVL AX, 8 (SP)
	MOVL R11, 12 (SP)
	MOVL 8(DX),CX
	MOVL 24(R10),R8
	MOVL 4(R10),AX
	MOVL 4(DX),R11
	MOVL CX,16(SP)
	MOVL R8, 20 (SP)
	MOVL AX, 24 (SP)
	MOVL R11, 28 (SP)
	MOVL 12(DX),CX
	MOVL 12(R10),DX
	MOVL 28(R10),R8
	MOVL 8(R10),AX
	MOVL DX,32(SP)
	MOVL CX, 36 (SP)
	MOVL R8, 40 (SP)
	MOVL AX, 44 (SP)
	MOVQ $1634760805,DX
	MOVQ $857760878,CX
	MOVQ $2036477234,R8
	MOVQ $1797285236,AX
	MOVL DX,48(SP)
	MOVL CX, 52 (SP)
	MOVL R8, 56 (SP)
	MOVL AX, 60 (SP)
	CMPQ R9,$256
	JB BYTESBETWEEN1AND255
	MOVOA 48(SP),X0
	PSHUFL $0X55,X0,X1
	PSHUFL $0XAA,X0,X2
	PSHUFL $0XFF,X0,X3
	PSHUFL $0X00,X0,X0
	MOVOA X1,64(SP)
	MOVOA X2,80(SP)
	MOVOA X3,96(SP)
	MOVOA X0,112(SP)
	MOVOA 0(SP),X0
	PSHUFL $0XAA,X0,X1
	PSHUFL $0XFF,X0,X2
	PSHUFL $0X00,X0,X3
	PSHUFL $0X55,X0,X0
	MOVOA X1,128(SP)
	MOVOA X2,144(SP)
	MOVOA X3,160(SP)
	MOVOA X0,176(SP)
	MOVOA 16(SP),X0
	PSHUFL $0XFF,X0,X1
	PSHUFL $0X55,X0,X2
	PSHUFL $0XAA,X0,X0
	MOVOA X1,192(SP)
	MOVOA X2,208(SP)
	MOVOA X0,224(SP)
	MOVOA 32(SP),X0
	PSHUFL $0X00,X0,X1
	PSHUFL $0XAA,X0,X2
	PSHUFL $0XFF,X0,X0
	MOVOA X1,240(SP)
	MOVOA X2,256(SP)
	MOVOA X0,272(SP)
	BYTESATLEAST256:
	MOVL 16(SP),DX
	MOVL  36 (SP),CX
	MOVL DX,288(SP)
	MOVL CX,304(SP)
	SHLQ $32,CX
	ADDQ CX,DX
	ADDQ $1,DX
	MOVQ DX,CX
	SHRQ $32,CX
	MOVL DX, 292 (SP)
	MOVL CX, 308 (SP)
	ADDQ $1,DX
	MOVQ DX,CX
	SHRQ $32,CX
	MOVL DX, 296 (SP)
	MOVL CX, 312 (SP)
	ADDQ $1,DX
	MOVQ DX,CX
	SHRQ $32,CX
	MOVL DX, 300 (SP)
	MOVL CX, 316 (SP)
	ADDQ $1,DX
	MOVQ DX,CX
	SHRQ $32,CX
	MOVL DX,16(SP)
	MOVL CX, 36 (SP)
	MOVQ R9,352(SP)
	MOVQ $20,DX
	MOVOA 64(SP),X0
	MOVOA 80(SP),X1
	MOVOA 96(SP),X2
	MOVOA 256(SP),X3
	MOVOA 272(SP),X4
	MOVOA 128(SP),X5
	MOVOA 144(SP),X6
	MOVOA 176(SP),X7
	MOVOA 192(SP),X8
	MOVOA 208(SP),X9
	MOVOA 224(SP),X10
	MOVOA 304(SP),X11
	MOVOA 112(SP),X12
	MOVOA 160(SP),X13
	MOVOA 240(SP),X14
	MOVOA 288(SP),X15
	MAINLOOP1:
	MOVOA X1,320(SP)
	MOVOA X2,336(SP)
	MOVOA X13,X1
	PADDL X12,X1
	MOVOA X1,X2
	PSLLL $7,X1
	PXOR X1,X14
	PSRLL $25,X2
	PXOR X2,X14
	MOVOA X7,X1
	PADDL X0,X1
	MOVOA X1,X2
	PSLLL $7,X1
	PXOR X1,X11
	PSRLL $25,X2
	PXOR X2,X11
	MOVOA X12,X1
	PADDL X14,X1
	MOVOA X1,X2
	PSLLL $9,X1
	PXOR X1,X15
	PSRLL $23,X2
	PXOR X2,X15
	MOVOA X0,X1
	PADDL X11,X1
	MOVOA X1,X2
	PSLLL $9,X1
	PXOR X1,X9
	PSRLL $23,X2
	PXOR X2,X9
	MOVOA X14,X1
	PADDL X15,X1
	MOVOA X1,X2
	PSLLL $13,X1
	PXOR X1,X13
	PSRLL $19,X2
	PXOR X2,X13
	MOVOA X11,X1
	PADDL X9,X1
	MOVOA X1,X2
	PSLLL $13,X1
	PXOR X1,X7
	PSRLL $19,X2
	PXOR X2,X7
	MOVOA X15,X1
	PADDL X13,X1
	MOVOA X1,X2
	PSLLL $18,X1
	PXOR X1,X12
	PSRLL $14,X2
	PXOR X2,X12
	MOVOA 320(SP),X1
	MOVOA X12,320(SP)
	MOVOA X9,X2
	PADDL X7,X2
	MOVOA X2,X12
	PSLLL $18,X2
	PXOR X2,X0
	PSRLL $14,X12
	PXOR X12,X0
	MOVOA X5,X2
	PADDL X1,X2
	MOVOA X2,X12
	PSLLL $7,X2
	PXOR X2,X3
	PSRLL $25,X12
	PXOR X12,X3
	MOVOA 336(SP),X2
	MOVOA X0,336(SP)
	MOVOA X6,X0
	PADDL X2,X0
	MOVOA X0,X12
	PSLLL $7,X0
	PXOR X0,X4
	PSRLL $25,X12
	PXOR X12,X4
	MOVOA X1,X0
	PADDL X3,X0
	MOVOA X0,X12
	PSLLL $9,X0
	PXOR X0,X10
	PSRLL $23,X12
	PXOR X12,X10
	MOVOA X2,X0
	PADDL X4,X0
	MOVOA X0,X12
	PSLLL $9,X0
	PXOR X0,X8
	PSRLL $23,X12
	PXOR X12,X8
	MOVOA X3,X0
	PADDL X10,X0
	MOVOA X0,X12
	PSLLL $13,X0
	PXOR X0,X5
	PSRLL $19,X12
	PXOR X12,X5
	MOVOA X4,X0
	PADDL X8,X0
	MOVOA X0,X12
	PSLLL $13,X0
	PXOR X0,X6
	PSRLL $19,X12
	PXOR X12,X6
	MOVOA X10,X0
	PADDL X5,X0
	MOVOA X0,X12
	PSLLL $18,X0
	PXOR X0,X1
	PSRLL $14,X12
	PXOR X12,X1
	MOVOA 320(SP),X0
	MOVOA X1,320(SP)
	MOVOA X4,X1
	PADDL X0,X1
	MOVOA X1,X12
	PSLLL $7,X1
	PXOR X1,X7
	PSRLL $25,X12
	PXOR X12,X7
	MOVOA X8,X1
	PADDL X6,X1
	MOVOA X1,X12
	PSLLL $18,X1
	PXOR X1,X2
	PSRLL $14,X12
	PXOR X12,X2
	MOVOA 336(SP),X12
	MOVOA X2,336(SP)
	MOVOA X14,X1
	PADDL X12,X1
	MOVOA X1,X2
	PSLLL $7,X1
	PXOR X1,X5
	PSRLL $25,X2
	PXOR X2,X5
	MOVOA X0,X1
	PADDL X7,X1
	MOVOA X1,X2
	PSLLL $9,X1
	PXOR X1,X10
	PSRLL $23,X2
	PXOR X2,X10
	MOVOA X12,X1
	PADDL X5,X1
	MOVOA X1,X2
	PSLLL $9,X1
	PXOR X1,X8
	PSRLL $23,X2
	PXOR X2,X8
	MOVOA X7,X1
	PADDL X10,X1
	MOVOA X1,X2
	PSLLL $13,X1
	PXOR X1,X4
	PSRLL $19,X2
	PXOR X2,X4
	MOVOA X5,X1
	PADDL X8,X1
	MOVOA X1,X2
	PSLLL $13,X1
	PXOR X1,X14
	PSRLL $19,X2
	PXOR X2,X14
	MOVOA X10,X1
	PADDL X4,X1
	MOVOA X1,X2
	PSLLL $18,X1
	PXOR X1,X0
	PSRLL $14,X2
	PXOR X2,X0
	MOVOA 320(SP),X1
	MOVOA X0,320(SP)
	MOVOA X8,X0
	PADDL X14,X0
	MOVOA X0,X2
	PSLLL $18,X0
	PXOR X0,X12
	PSRLL $14,X2
	PXOR X2,X12
	MOVOA X11,X0
	PADDL X1,X0
	MOVOA X0,X2
	PSLLL $7,X0
	PXOR X0,X6
	PSRLL $25,X2
	PXOR X2,X6
	MOVOA 336(SP),X2
	MOVOA X12,336(SP)
	MOVOA X3,X0
	PADDL X2,X0
	MOVOA X0,X12
	PSLLL $7,X0
	PXOR X0,X13
	PSRLL $25,X12
	PXOR X12,X13
	MOVOA X1,X0
	PADDL X6,X0
	MOVOA X0,X12
	PSLLL $9,X0
	PXOR X0,X15
	PSRLL $23,X12
	PXOR X12,X15
	MOVOA X2,X0
	PADDL X13,X0
	MOVOA X0,X12
	PSLLL $9,X0
	PXOR X0,X9
	PSRLL $23,X12
	PXOR X12,X9
	MOVOA X6,X0
	PADDL X15,X0
	MOVOA X0,X12
	PSLLL $13,X0
	PXOR X0,X11
	PSRLL $19,X12
	PXOR X12,X11
	MOVOA X13,X0
	PADDL X9,X0
	MOVOA X0,X12
	PSLLL $13,X0
	PXOR X0,X3
	PSRLL $19,X12
	PXOR X12,X3
	MOVOA X15,X0
	PADDL X11,X0
	MOVOA X0,X12
	PSLLL $18,X0
	PXOR X0,X1
	PSRLL $14,X12
	PXOR X12,X1
	MOVOA X9,X0
	PADDL X3,X0
	MOVOA X0,X12
	PSLLL $18,X0
	PXOR X0,X2
	PSRLL $14,X12
	PXOR X12,X2
	MOVOA 320(SP),X12
	MOVOA 336(SP),X0
	SUBQ $2,DX
	JA MAINLOOP1
	PADDL 112(SP),X12
	PADDL 176(SP),X7
	PADDL 224(SP),X10
	PADDL 272(SP),X4
	MOVD X12,DX
	MOVD X7,CX
	MOVD X10,R8
	MOVD X4,R9
	PSHUFL $0X39,X12,X12
	PSHUFL $0X39,X7,X7
	PSHUFL $0X39,X10,X10
	PSHUFL $0X39,X4,X4
	XORL 0(SI),DX
	XORL 4(SI),CX
	XORL 8(SI),R8
	XORL 12(SI),R9
	MOVL DX,0(DI)
	MOVL CX,4(DI)
	MOVL R8,8(DI)
	MOVL R9,12(DI)
	MOVD X12,DX
	MOVD X7,CX
	MOVD X10,R8
	MOVD X4,R9
	PSHUFL $0X39,X12,X12
	PSHUFL $0X39,X7,X7
	PSHUFL $0X39,X10,X10
	PSHUFL $0X39,X4,X4
	XORL 64(SI),DX
	XORL 68(SI),CX
	XORL 72(SI),R8
	XORL 76(SI),R9
	MOVL DX,64(DI)
	MOVL CX,68(DI)
	MOVL R8,72(DI)
	MOVL R9,76(DI)
	MOVD X12,DX
	MOVD X7,CX
	MOVD X10,R8
	MOVD X4,R9
	PSHUFL $0X39,X12,X12
	PSHUFL $0X39,X7,X7
	PSHUFL $0X39,X10,X10
	PSHUFL $0X39,X4,X4
	XORL 128(SI),DX
	XORL 132(SI),CX
	XORL 136(SI),R8
	XORL 140(SI),R9
	MOVL DX,128(DI)
	MOVL CX,132(DI)
	MOVL R8,136(DI)
	MOVL R9,140(DI)
	MOVD X12,DX
	MOVD X7,CX
	MOVD X10,R8
	MOVD X4,R9
	XORL 192(SI),DX
	XORL 196(SI),CX
	XORL 200(SI),R8
	XORL 204(SI),R9
	MOVL DX,192(DI)
	MOVL CX,196(DI)
	MOVL R8,200(DI)
	MOVL R9,204(DI)
	PADDL 240(SP),X14
	PADDL 64(SP),X0
	PADDL 128(SP),X5
	PADDL 192(SP),X8
	MOVD X14,DX
	MOVD X0,CX
	MOVD X5,R8
	MOVD X8,R9
	PSHUFL $0X39,X14,X14
	PSHUFL $0X39,X0,X0
	PSHUFL $0X39,X5,X5
	PSHUFL $0X39,X8,X8
	XORL 16(SI),DX
	XORL 20(SI),CX
	XORL 24(SI),R8
	XORL 28(SI),R9
	MOVL DX,16(DI)
	MOVL CX,20(DI)
	MOVL R8,24(DI)
	MOVL R9,28(DI)
	MOVD X14,DX
	MOVD X0,CX
	MOVD X5,R8
	MOVD X8,R9
	PSHUFL $0X39,X14,X14
	PSHUFL $0X39,X0,X0
	PSHUFL $0X39,X5,X5
	PSHUFL $0X39,X8,X8
	XORL 80(SI),DX
	XORL 84(SI),CX
	XORL 88(SI),R8
	XORL 92(SI),R9
	MOVL DX,80(DI)
	MOVL CX,84(DI)
	MOVL R8,88(DI)
	MOVL R9,92(DI)
	MOVD X14,DX
	MOVD X0,CX
	MOVD X5,R8
	MOVD X8,R9
	PSHUFL $0X39,X14,X14
	PSHUFL $0X39,X0,X0
	PSHUFL $0X39,X5,X5
	PSHUFL $0X39,X8,X8
	XORL 144(SI),DX
	XORL 148(SI),CX
	XORL 152(SI),R8
	XORL 156(SI),R9
	MOVL DX,144(DI)
	MOVL CX,148(DI)
	MOVL R8,152(DI)
	MOVL R9,156(DI)
	MOVD X14,DX
	MOVD X0,CX
	MOVD X5,R8
	MOVD X8,R9
	XORL 208(SI),DX
	XORL 212(SI),CX
	XORL 216(SI),R8
	XORL 220(SI),R9
	MOVL DX,208(DI)
	MOVL CX,212(DI)
	MOVL R8,216(DI)
	MOVL R9,220(DI)
	PADDL 288(SP),X15
	PADDL 304(SP),X11
	PADDL 80(SP),X1
	PADDL 144(SP),X6
	MOVD X15,DX
	MOVD X11,CX
	MOVD X1,R8
	MOVD X6,R9
	PSHUFL $0X39,X15,X15
	PSHUFL $0X39,X11,X11
	PSHUFL $0X39,X1,X1
	PSHUFL $0X39,X6,X6
	XORL 32(SI),DX
	XORL 36(SI),CX
	XORL 40(SI),R8
	XORL 44(SI),R9
	MOVL DX,32(DI)
	MOVL CX,36(DI)
	MOVL R8,40(DI)
	MOVL R9,44(DI)
	MOVD X15,DX
	MOVD X11,CX
	MOVD X1,R8
	MOVD X6,R9
	PSHUFL $0X39,X15,X15
	PSHUFL $0X39,X11,X11
	PSHUFL $0X39,X1,X1
	PSHUFL $0X39,X6,X6
	XORL 96(SI),DX
	XORL 100(SI),CX
	XORL 104(SI),R8
	XORL 108(SI),R9
	MOVL DX,96(DI)
	MOVL CX,100(DI)
	MOVL R8,104(DI)
	MOVL R9,108(DI)
	MOVD X15,DX
	MOVD X11,CX
	MOVD X1,R8
	MOVD X6,R9
	PSHUFL $0X39,X15,X15
	PSHUFL $0X39,X11,X11
	PSHUFL $0X39,X1,X1
	PSHUFL $0X39,X6,X6
	XORL 160(SI),DX
	XORL 164(SI),CX
	XORL 168(SI),R8
	XORL 172(SI),R9
	MOVL DX,160(DI)
	MOVL CX,164(DI)
	MOVL R8,168(DI)
	MOVL R9,172(DI)
	MOVD X15,DX
	MOVD X11,CX
	MOVD X1,R8
	MOVD X6,R9
	XORL 224(SI),DX
	XORL 228(SI),CX
	XORL 232(SI),R8
	XORL 236(SI),R9
	MOVL DX,224(DI)
	MOVL CX,228(DI)
	MOVL R8,232(DI)
	MOVL R9,236(DI)
	PADDL 160(SP),X13
	PADDL 208(SP),X9
	PADDL 256(SP),X3
	PADDL 96(SP),X2
	MOVD X13,DX
	MOVD X9,CX
	MOVD X3,R8
	MOVD X2,R9
	PSHUFL $0X39,X13,X13
	PSHUFL $0X39,X9,X9
	PSHUFL $0X39,X3,X3
	PSHUFL $0X39,X2,X2
	XORL 48(SI),DX
	XORL 52(SI),CX
	XORL 56(SI),R8
	XORL 60(SI),R9
	MOVL DX,48(DI)
	MOVL CX,52(DI)
	MOVL R8,56(DI)
	MOVL R9,60(DI)
	MOVD X13,DX
	MOVD X9,CX
	MOVD X3,R8
	MOVD X2,R9
	PSHUFL $0X39,X13,X13
	PSHUFL $0X39,X9,X9
	PSHUFL $0X39,X3,X3
	PSHUFL $0X39,X2,X2
	XORL 112(SI),DX
	XORL 116(SI),CX
	XORL 120(SI),R8
	XORL 124(SI),R9
	MOVL DX,112(DI)
	MOVL CX,116(DI)
	MOVL R8,120(DI)
	MOVL R9,124(DI)
	MOVD X13,DX
	MOVD X9,CX
	MOVD X3,R8
	MOVD X2,R9
	PSHUFL $0X39,X13,X13
	PSHUFL $0X39,X9,X9
	PSHUFL $0X39,X3,X3
	PSHUFL $0X39,X2,X2
	XORL 176(SI),DX
	XORL 180(SI),CX
	XORL 184(SI),R8
	XORL 188(SI),R9
	MOVL DX,176(DI)
	MOVL CX,180(DI)
	MOVL R8,184(DI)
	MOVL R9,188(DI)
	MOVD X13,DX
	MOVD X9,CX
	MOVD X3,R8
	MOVD X2,R9
	XORL 240(SI),DX
	XORL 244(SI),CX
	XORL 248(SI),R8
	XORL 252(SI),R9
	MOVL DX,240(DI)
	MOVL CX,244(DI)
	MOVL R8,248(DI)
	MOVL R9,252(DI)
	MOVQ 352(SP),R9
	SUBQ $256,R9
	ADDQ $256,SI
	ADDQ $256,DI
	CMPQ R9,$256
	JAE BYTESATLEAST256
	CMPQ R9,$0
	JBE DONE
	BYTESBETWEEN1AND255:
	CMPQ R9,$64
	JAE NOCOPY
	MOVQ DI,DX
	LEAQ 360(SP),DI
	MOVQ R9,CX
	REP; MOVSB
	LEAQ 360(SP),DI
	LEAQ 360(SP),SI
	NOCOPY:
	MOVQ R9,352(SP)
	MOVOA 48(SP),X0
	MOVOA 0(SP),X1
	MOVOA 16(SP),X2
	MOVOA 32(SP),X3
	MOVOA X1,X4
	MOVQ $20,CX
	MAINLOOP2:
	PADDL X0,X4
	MOVOA X0,X5
	MOVOA X4,X6
	PSLLL $7,X4
	PSRLL $25,X6
	PXOR X4,X3
	PXOR X6,X3
	PADDL X3,X5
	MOVOA X3,X4
	MOVOA X5,X6
	PSLLL $9,X5
	PSRLL $23,X6
	PXOR X5,X2
	PSHUFL $0X93,X3,X3
	PXOR X6,X2
	PADDL X2,X4
	MOVOA X2,X5
	MOVOA X4,X6
	PSLLL $13,X4
	PSRLL $19,X6
	PXOR X4,X1
	PSHUFL $0X4E,X2,X2
	PXOR X6,X1
	PADDL X1,X5
	MOVOA X3,X4
	MOVOA X5,X6
	PSLLL $18,X5
	PSRLL $14,X6
	PXOR X5,X0
	PSHUFL $0X39,X1,X1
	PXOR X6,X0
	PADDL X0,X4
	MOVOA X0,X5
	MOVOA X4,X6
	PSLLL $7,X4
	PSRLL $25,X6
	PXOR X4,X1
	PXOR X6,X1
	PADDL X1,X5
	MOVOA X1,X4
	MOVOA X5,X6
	PSLLL $9,X5
	PSRLL $23,X6
	PXOR X5,X2
	PSHUFL $0X93,X1,X1
	PXOR X6,X2
	PADDL X2,X4
	MOVOA X2,X5
	MOVOA X4,X6
	PSLLL $13,X4
	PSRLL $19,X6
	PXOR X4,X3
	PSHUFL $0X4E,X2,X2
	PXOR X6,X3
	PADDL X3,X5
	MOVOA X1,X4
	MOVOA X5,X6
	PSLLL $18,X5
	PSRLL $14,X6
	PXOR X5,X0
	PSHUFL $0X39,X3,X3
	PXOR X6,X0
	PADDL X0,X4
	MOVOA X0,X5
	MOVOA X4,X6
	PSLLL $7,X4
	PSRLL $25,X6
	PXOR X4,X3
	PXOR X6,X3
	PADDL X3,X5
	MOVOA X3,X4
	MOVOA X5,X6
	PSLLL $9,X5
	PSRLL $23,X6
	PXOR X5,X2
	PSHUFL $0X93,X3,X3
	PXOR X6,X2
	PADDL X2,X4
	MOVOA X2,X5
	MOVOA X4,X6
	PSLLL $13,X4
	PSRLL $19,X6
	PXOR X4,X1
	PSHUFL $0X4E,X2,X2
	PXOR X6,X1
	PADDL X1,X5
	MOVOA X3,X4
	MOVOA X5,X6
	PSLLL $18,X5
	PSRLL $14,X6
	PXOR X5,X0
	PSHUFL $0X39,X1,X1
	PXOR X6,X0
	PADDL X0,X4
	MOVOA X0,X5
	MOVOA X4,X6
	PSLLL $7,X4
	PSRLL $25,X6
	PXOR X4,X1
	PXOR X6,X1
	PADDL X1,X5
	MOVOA X1,X4
	MOVOA X5,X6
	PSLLL $9,X5
	PSRLL $23,X6
	PXOR X5,X2
	PSHUFL $0X93,X1,X1
	PXOR X6,X2
	PADDL X2,X4
	MOVOA X2,X5
	MOVOA X4,X6
	PSLLL $13,X4
	PSRLL $19,X6
	PXOR X4,X3
	PSHUFL $0X4E,X2,X2
	PXOR X6,X3
	SUBQ $4,CX
	PADDL X3,X5
	MOVOA X1,X4
	MOVOA X5,X6
	PSLLL $18,X5
	PXOR X7,X7
	PSRLL $14,X6
	PXOR X5,X0
	PSHUFL $0X39,X3,X3
	PXOR X6,X0
	JA MAINLOOP2
	PADDL 48(SP),X0
	PADDL 0(SP),X1
	PADDL 16(SP),X2
	PADDL 32(SP),X3
	MOVD X0,CX
	MOVD X1,R8
	MOVD X2,R9
	MOVD X3,AX
	PSHUFL $0X39,X0,X0
	PSHUFL $0X39,X1,X1
	PSHUFL $0X39,X2,X2
	PSHUFL $0X39,X3,X3
	XORL 0(SI),CX
	XORL 48(SI),R8
	XORL 32(SI),R9
	XORL 16(SI),AX
	MOVL CX,0(DI)
	MOVL R8,48(DI)
	MOVL R9,32(DI)
	MOVL AX,16(DI)
	MOVD X0,CX
	MOVD X1,R8
	MOVD X2,R9
	MOVD X3,AX
	PSHUFL $0X39,X0,X0
	PSHUFL $0X39,X1,X1
	PSHUFL $0X39,X2,X2
	PSHUFL $0X39,X3,X3
	XORL 20(SI),CX
	XORL 4(SI),R8
	XORL 52(SI),R9
	XORL 36(SI),AX
	MOVL CX,20(DI)
	MOVL R8,4(DI)
	MOVL R9,52(DI)
	MOVL AX,36(DI)
	MOVD X0,CX
	MOVD X1,R8
	MOVD X2,R9
	MOVD X3,AX
	PSHUFL $0X39,X0,X0
	PSHUFL $0X39,X1,X1
	PSHUFL $0X39,X2,X2
	PSHUFL $0X39,X3,X3
	XORL 40(SI),CX
	XORL 24(SI),R8
	XORL 8(SI),R9
	XORL 56(SI),AX
	MOVL CX,40(DI)
	MOVL R8,24(DI)
	MOVL R9,8(DI)
	MOVL AX,56(DI)
	MOVD X0,CX
	MOVD X1,R8
	MOVD X2,R9
	MOVD X3,AX
	XORL 60(SI),CX
	XORL 44(SI),R8
	XORL 28(SI),R9
	XORL 12(SI),AX
	MOVL CX,60(DI)
	MOVL R8,44(DI)
	MOVL R9,28(DI)
	MOVL AX,12(DI)
	MOVQ 352(SP),R9
	MOVL 16(SP),CX
	MOVL  36 (SP),R8
	ADDQ $1,CX
	SHLQ $32,R8
	ADDQ R8,CX
	MOVQ CX,R8
	SHRQ $32,R8
	MOVL CX,16(SP)
	MOVL R8, 36 (SP)
	CMPQ R9,$64
	JA BYTESATLEAST65
	JAE BYTESATLEAST64
	MOVQ DI,SI
	MOVQ DX,DI
	MOVQ R9,CX
	REP; MOVSB
	BYTESATLEAST64:
	DONE:
	MOVQ R12,SP
	RET
	BYTESATLEAST65:
	SUBQ $64,R9
	ADDQ $64,DI
	ADDQ $64,SI
	JMP BYTESBETWEEN1AND255

+ f 1d2d257b30b8466374ef35cf85413e1e428867780f54ca08a654b6f607136905 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_noasm.go
utf8file 15
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !amd64 appengine gccgo

package salsa

// XORKeyStream crypts bytes from in to out using the given key and counters.
// In and out must overlap entirely or not at all. Counter
// contains the raw salsa20 counter bytes (both nonce and block counter).
func XORKeyStream(out, in []byte, counter *[16]byte, key *[32]byte) {
	genericXORKeyStream(out, in, counter, key)
}

+ f c3448e28b3ce7d372286270d8bbf1a8cb9e7c39dfb9f43b033d26fae5d08b839 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_ref.go
utf8file 232
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package salsa

const rounds = 20

// core applies the Salsa20 core function to 16-byte input in, 32-byte key k,
// and 16-byte constant c, and puts the result into 64-byte array out.
func core(out *[64]byte, in *[16]byte, k *[32]byte, c *[16]byte) {
	j0 := uint32(c[0]) | uint32(c[1])<<8 | uint32(c[2])<<16 | uint32(c[3])<<24
	j1 := uint32(k[0]) | uint32(k[1])<<8 | uint32(k[2])<<16 | uint32(k[3])<<24
	j2 := uint32(k[4]) | uint32(k[5])<<8 | uint32(k[6])<<16 | uint32(k[7])<<24
	j3 := uint32(k[8]) | uint32(k[9])<<8 | uint32(k[10])<<16 | uint32(k[11])<<24
	j4 := uint32(k[12]) | uint32(k[13])<<8 | uint32(k[14])<<16 | uint32(k[15])<<24
	j5 := uint32(c[4]) | uint32(c[5])<<8 | uint32(c[6])<<16 | uint32(c[7])<<24
	j6 := uint32(in[0]) | uint32(in[1])<<8 | uint32(in[2])<<16 | uint32(in[3])<<24
	j7 := uint32(in[4]) | uint32(in[5])<<8 | uint32(in[6])<<16 | uint32(in[7])<<24
	j8 := uint32(in[8]) | uint32(in[9])<<8 | uint32(in[10])<<16 | uint32(in[11])<<24
	j9 := uint32(in[12]) | uint32(in[13])<<8 | uint32(in[14])<<16 | uint32(in[15])<<24
	j10 := uint32(c[8]) | uint32(c[9])<<8 | uint32(c[10])<<16 | uint32(c[11])<<24
	j11 := uint32(k[16]) | uint32(k[17])<<8 | uint32(k[18])<<16 | uint32(k[19])<<24
	j12 := uint32(k[20]) | uint32(k[21])<<8 | uint32(k[22])<<16 | uint32(k[23])<<24
	j13 := uint32(k[24]) | uint32(k[25])<<8 | uint32(k[26])<<16 | uint32(k[27])<<24
	j14 := uint32(k[28]) | uint32(k[29])<<8 | uint32(k[30])<<16 | uint32(k[31])<<24
	j15 := uint32(c[12]) | uint32(c[13])<<8 | uint32(c[14])<<16 | uint32(c[15])<<24

	x0, x1, x2, x3, x4, x5, x6, x7, x8 := j0, j1, j2, j3, j4, j5, j6, j7, j8
	x9, x10, x11, x12, x13, x14, x15 := j9, j10, j11, j12, j13, j14, j15

	for i := 0; i < rounds; i += 2 {
		u := x0 + x12
		x4 ^= u<<7 | u>>(32-7)
		u = x4 + x0
		x8 ^= u<<9 | u>>(32-9)
		u = x8 + x4
		x12 ^= u<<13 | u>>(32-13)
		u = x12 + x8
		x0 ^= u<<18 | u>>(32-18)

		u = x5 + x1
		x9 ^= u<<7 | u>>(32-7)
		u = x9 + x5
		x13 ^= u<<9 | u>>(32-9)
		u = x13 + x9
		x1 ^= u<<13 | u>>(32-13)
		u = x1 + x13
		x5 ^= u<<18 | u>>(32-18)

		u = x10 + x6
		x14 ^= u<<7 | u>>(32-7)
		u = x14 + x10
		x2 ^= u<<9 | u>>(32-9)
		u = x2 + x14
		x6 ^= u<<13 | u>>(32-13)
		u = x6 + x2
		x10 ^= u<<18 | u>>(32-18)

		u = x15 + x11
		x3 ^= u<<7 | u>>(32-7)
		u = x3 + x15
		x7 ^= u<<9 | u>>(32-9)
		u = x7 + x3
		x11 ^= u<<13 | u>>(32-13)
		u = x11 + x7
		x15 ^= u<<18 | u>>(32-18)

		u = x0 + x3
		x1 ^= u<<7 | u>>(32-7)
		u = x1 + x0
		x2 ^= u<<9 | u>>(32-9)
		u = x2 + x1
		x3 ^= u<<13 | u>>(32-13)
		u = x3 + x2
		x0 ^= u<<18 | u>>(32-18)

		u = x5 + x4
		x6 ^= u<<7 | u>>(32-7)
		u = x6 + x5
		x7 ^= u<<9 | u>>(32-9)
		u = x7 + x6
		x4 ^= u<<13 | u>>(32-13)
		u = x4 + x7
		x5 ^= u<<18 | u>>(32-18)

		u = x10 + x9
		x11 ^= u<<7 | u>>(32-7)
		u = x11 + x10
		x8 ^= u<<9 | u>>(32-9)
		u = x8 + x11
		x9 ^= u<<13 | u>>(32-13)
		u = x9 + x8
		x10 ^= u<<18 | u>>(32-18)

		u = x15 + x14
		x12 ^= u<<7 | u>>(32-7)
		u = x12 + x15
		x13 ^= u<<9 | u>>(32-9)
		u = x13 + x12
		x14 ^= u<<13 | u>>(32-13)
		u = x14 + x13
		x15 ^= u<<18 | u>>(32-18)
	}
	x0 += j0
	x1 += j1
	x2 += j2
	x3 += j3
	x4 += j4
	x5 += j5
	x6 += j6
	x7 += j7
	x8 += j8
	x9 += j9
	x10 += j10
	x11 += j11
	x12 += j12
	x13 += j13
	x14 += j14
	x15 += j15

	out[0] = byte(x0)
	out[1] = byte(x0 >> 8)
	out[2] = byte(x0 >> 16)
	out[3] = byte(x0 >> 24)

	out[4] = byte(x1)
	out[5] = byte(x1 >> 8)
	out[6] = byte(x1 >> 16)
	out[7] = byte(x1 >> 24)

	out[8] = byte(x2)
	out[9] = byte(x2 >> 8)
	out[10] = byte(x2 >> 16)
	out[11] = byte(x2 >> 24)

	out[12] = byte(x3)
	out[13] = byte(x3 >> 8)
	out[14] = byte(x3 >> 16)
	out[15] = byte(x3 >> 24)

	out[16] = byte(x4)
	out[17] = byte(x4 >> 8)
	out[18] = byte(x4 >> 16)
	out[19] = byte(x4 >> 24)

	out[20] = byte(x5)
	out[21] = byte(x5 >> 8)
	out[22] = byte(x5 >> 16)
	out[23] = byte(x5 >> 24)

	out[24] = byte(x6)
	out[25] = byte(x6 >> 8)
	out[26] = byte(x6 >> 16)
	out[27] = byte(x6 >> 24)

	out[28] = byte(x7)
	out[29] = byte(x7 >> 8)
	out[30] = byte(x7 >> 16)
	out[31] = byte(x7 >> 24)

	out[32] = byte(x8)
	out[33] = byte(x8 >> 8)
	out[34] = byte(x8 >> 16)
	out[35] = byte(x8 >> 24)

	out[36] = byte(x9)
	out[37] = byte(x9 >> 8)
	out[38] = byte(x9 >> 16)
	out[39] = byte(x9 >> 24)

	out[40] = byte(x10)
	out[41] = byte(x10 >> 8)
	out[42] = byte(x10 >> 16)
	out[43] = byte(x10 >> 24)

	out[44] = byte(x11)
	out[45] = byte(x11 >> 8)
	out[46] = byte(x11 >> 16)
	out[47] = byte(x11 >> 24)

	out[48] = byte(x12)
	out[49] = byte(x12 >> 8)
	out[50] = byte(x12 >> 16)
	out[51] = byte(x12 >> 24)

	out[52] = byte(x13)
	out[53] = byte(x13 >> 8)
	out[54] = byte(x13 >> 16)
	out[55] = byte(x13 >> 24)

	out[56] = byte(x14)
	out[57] = byte(x14 >> 8)
	out[58] = byte(x14 >> 16)
	out[59] = byte(x14 >> 24)

	out[60] = byte(x15)
	out[61] = byte(x15 >> 8)
	out[62] = byte(x15 >> 16)
	out[63] = byte(x15 >> 24)
}

// genericXORKeyStream is the generic implementation of XORKeyStream to be used
// when no assembly implementation is available.
func genericXORKeyStream(out, in []byte, counter *[16]byte, key *[32]byte) {
	var block [64]byte
	var counterCopy [16]byte
	copy(counterCopy[:], counter[:])

	for len(in) >= 64 {
		core(&block, &counterCopy, key, &Sigma)
		for i, x := range block {
			out[i] = in[i] ^ x
		}
		u := uint32(1)
		for i := 8; i < 16; i++ {
			u += uint32(counterCopy[i])
			counterCopy[i] = byte(u)
			u >>= 8
		}
		in = in[64:]
		out = out[64:]
	}

	if len(in) > 0 {
		core(&block, &counterCopy, key, &Sigma)
		for i, v := range in {
			out[i] = v ^ block[i]
		}
	}
}

+ f e08e8aeb1137e1f9a4de4978b094cc92e0f931e1165aa1b837701d2c76761910 vendor/golang.org/x/sys/cpu/asm_aix_ppc64.s
utf8file 18
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !gccgo

#include "textflag.h"

//
// System calls for ppc64, AIX are implemented in runtime/syscall_aix.go
//

TEXT syscall6(SB),NOSPLIT,$0-88
	JMP	syscallsyscall6(SB)

TEXT rawSyscall6(SB),NOSPLIT,$0-88
	JMP	syscallrawSyscall6(SB)

+ f fc62e9bef2371b48a736cbb017451a1f53dca0edeae565a89e85726ccca796f2 vendor/golang.org/x/sys/cpu/byteorder.go
utf8file 61
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"runtime"
)

// byteOrder is a subset of encoding/binary.ByteOrder.
type byteOrder interface {
	Uint32([]byte) uint32
	Uint64([]byte) uint64
}

type littleEndian struct{}
type bigEndian struct{}

func (littleEndian) Uint32(b []byte) uint32 {
	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}

func (littleEndian) Uint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
}

func (bigEndian) Uint32(b []byte) uint32 {
	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
	return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
}

func (bigEndian) Uint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
}

// hostByteOrder returns binary.LittleEndian on little-endian machines and
// binary.BigEndian on big-endian machines.
func hostByteOrder() byteOrder {
	switch runtime.GOARCH {
	case "386", "amd64", "amd64p32",
		"arm", "arm64",
		"mipsle", "mips64le", "mips64p32le",
		"ppc64le",
		"riscv", "riscv64":
		return littleEndian{}
	case "armbe", "arm64be",
		"mips", "mips64", "mips64p32",
		"ppc", "ppc64",
		"s390", "s390x",
		"sparc", "sparc64":
		return bigEndian{}
	}
	panic("unknown architecture")
}

+ f 33ea1dda0d9252688116122fe41bf481491332a2c64bbf2638659d215e94e2db vendor/golang.org/x/sys/cpu/cpu.go
utf8file 163
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package cpu implements processor feature detection for
// various CPU architectures.
package cpu

// Initialized reports whether the CPU features were initialized.
//
// For some GOOS/GOARCH combinations initialization of the CPU features depends
// on reading an operating specific file, e.g. /proc/self/auxv on linux/arm
// Initialized will report false if reading the file fails.
var Initialized bool

// CacheLinePad is used to pad structs to avoid false sharing.
type CacheLinePad struct{ _ [cacheLineSize]byte }

// X86 contains the supported CPU features of the
// current X86/AMD64 platform. If the current platform
// is not X86/AMD64 then all feature flags are false.
//
// X86 is padded to avoid false sharing. Further the HasAVX
// and HasAVX2 are only set if the OS supports XMM and YMM
// registers in addition to the CPUID feature bit being set.
var X86 struct {
	_            CacheLinePad
	HasAES       bool // AES hardware implementation (AES NI)
	HasADX       bool // Multi-precision add-carry instruction extensions
	HasAVX       bool // Advanced vector extension
	HasAVX2      bool // Advanced vector extension 2
	HasBMI1      bool // Bit manipulation instruction set 1
	HasBMI2      bool // Bit manipulation instruction set 2
	HasERMS      bool // Enhanced REP for MOVSB and STOSB
	HasFMA       bool // Fused-multiply-add instructions
	HasOSXSAVE   bool // OS supports XSAVE/XRESTOR for saving/restoring XMM registers.
	HasPCLMULQDQ bool // PCLMULQDQ instruction - most often used for AES-GCM
	HasPOPCNT    bool // Hamming weight instruction POPCNT.
	HasRDRAND    bool // RDRAND instruction (on-chip random number generator)
	HasRDSEED    bool // RDSEED instruction (on-chip random number generator)
	HasSSE2      bool // Streaming SIMD extension 2 (always available on amd64)
	HasSSE3      bool // Streaming SIMD extension 3
	HasSSSE3     bool // Supplemental streaming SIMD extension 3
	HasSSE41     bool // Streaming SIMD extension 4 and 4.1
	HasSSE42     bool // Streaming SIMD extension 4 and 4.2
	_            CacheLinePad
}

// ARM64 contains the supported CPU features of the
// current ARMv8(aarch64) platform. If the current platform
// is not arm64 then all feature flags are false.
var ARM64 struct {
	_           CacheLinePad
	HasFP       bool // Floating-point instruction set (always available)
	HasASIMD    bool // Advanced SIMD (always available)
	HasEVTSTRM  bool // Event stream support
	HasAES      bool // AES hardware implementation
	HasPMULL    bool // Polynomial multiplication instruction set
	HasSHA1     bool // SHA1 hardware implementation
	HasSHA2     bool // SHA2 hardware implementation
	HasCRC32    bool // CRC32 hardware implementation
	HasATOMICS  bool // Atomic memory operation instruction set
	HasFPHP     bool // Half precision floating-point instruction set
	HasASIMDHP  bool // Advanced SIMD half precision instruction set
	HasCPUID    bool // CPUID identification scheme registers
	HasASIMDRDM bool // Rounding double multiply add/subtract instruction set
	HasJSCVT    bool // Javascript conversion from floating-point to integer
	HasFCMA     bool // Floating-point multiplication and addition of complex numbers
	HasLRCPC    bool // Release Consistent processor consistent support
	HasDCPOP    bool // Persistent memory support
	HasSHA3     bool // SHA3 hardware implementation
	HasSM3      bool // SM3 hardware implementation
	HasSM4      bool // SM4 hardware implementation
	HasASIMDDP  bool // Advanced SIMD double precision instruction set
	HasSHA512   bool // SHA512 hardware implementation
	HasSVE      bool // Scalable Vector Extensions
	HasASIMDFHM bool // Advanced SIMD multiplication FP16 to FP32
	_           CacheLinePad
}

// ARM contains the supported CPU features of the current ARM (32-bit) platform.
// All feature flags are false if:
//   1. the current platform is not arm, or
//   2. the current operating system is not Linux.
var ARM struct {
	_           CacheLinePad
	HasSWP      bool // SWP instruction support
	HasHALF     bool // Half-word load and store support
	HasTHUMB    bool // ARM Thumb instruction set
	Has26BIT    bool // Address space limited to 26-bits
	HasFASTMUL  bool // 32-bit operand, 64-bit result multiplication support
	HasFPA      bool // Floating point arithmetic support
	HasVFP      bool // Vector floating point support
	HasEDSP     bool // DSP Extensions support
	HasJAVA     bool // Java instruction set
	HasIWMMXT   bool // Intel Wireless MMX technology support
	HasCRUNCH   bool // MaverickCrunch context switching and handling
	HasTHUMBEE  bool // Thumb EE instruction set
	HasNEON     bool // NEON instruction set
	HasVFPv3    bool // Vector floating point version 3 support
	HasVFPv3D16 bool // Vector floating point version 3 D8-D15
	HasTLS      bool // Thread local storage support
	HasVFPv4    bool // Vector floating point version 4 support
	HasIDIVA    bool // Integer divide instruction support in ARM mode
	HasIDIVT    bool // Integer divide instruction support in Thumb mode
	HasVFPD32   bool // Vector floating point version 3 D15-D31
	HasLPAE     bool // Large Physical Address Extensions
	HasEVTSTRM  bool // Event stream support
	HasAES      bool // AES hardware implementation
	HasPMULL    bool // Polynomial multiplication instruction set
	HasSHA1     bool // SHA1 hardware implementation
	HasSHA2     bool // SHA2 hardware implementation
	HasCRC32    bool // CRC32 hardware implementation
	_           CacheLinePad
}

// PPC64 contains the supported CPU features of the current ppc64/ppc64le platforms.
// If the current platform is not ppc64/ppc64le then all feature flags are false.
//
// For ppc64/ppc64le, it is safe to check only for ISA level starting on ISA v3.00,
// since there are no optional categories. There are some exceptions that also
// require kernel support to work (DARN, SCV), so there are feature bits for
// those as well. The minimum processor requirement is POWER8 (ISA 2.07).
// The struct is padded to avoid false sharing.
var PPC64 struct {
	_        CacheLinePad
	HasDARN  bool // Hardware random number generator (requires kernel enablement)
	HasSCV   bool // Syscall vectored (requires kernel enablement)
	IsPOWER8 bool // ISA v2.07 (POWER8)
	IsPOWER9 bool // ISA v3.00 (POWER9)
	_        CacheLinePad
}

// S390X contains the supported CPU features of the current IBM Z
// (s390x) platform. If the current platform is not IBM Z then all
// feature flags are false.
//
// S390X is padded to avoid false sharing. Further HasVX is only set
// if the OS supports vector registers in addition to the STFLE
// feature bit being set.
var S390X struct {
	_         CacheLinePad
	HasZARCH  bool // z/Architecture mode is active [mandatory]
	HasSTFLE  bool // store facility list extended
	HasLDISP  bool // long (20-bit) displacements
	HasEIMM   bool // 32-bit immediates
	HasDFP    bool // decimal floating point
	HasETF3EH bool // ETF-3 enhanced
	HasMSA    bool // message security assist (CPACF)
	HasAES    bool // KM-AES{128,192,256} functions
	HasAESCBC bool // KMC-AES{128,192,256} functions
	HasAESCTR bool // KMCTR-AES{128,192,256} functions
	HasAESGCM bool // KMA-GCM-AES{128,192,256} functions
	HasGHASH  bool // KIMD-GHASH function
	HasSHA1   bool // K{I,L}MD-SHA-1 functions
	HasSHA256 bool // K{I,L}MD-SHA-256 functions
	HasSHA512 bool // K{I,L}MD-SHA-512 functions
	HasSHA3   bool // K{I,L}MD-SHA3-{224,256,384,512} and K{I,L}MD-SHAKE-{128,256} functions
	HasVX     bool // vector facility
	HasVXE    bool // vector-enhancements facility 1
	_         CacheLinePad
}

+ f b6b51a2c686ad149796aa56b104634db35ee494ef870ea596f504e5677b9f190 vendor/golang.org/x/sys/cpu/cpu_aix_ppc64.go
utf8file 35
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix,ppc64

package cpu

const cacheLineSize = 128

const (
	// getsystemcfg constants
	_SC_IMPL     = 2
	_IMPL_POWER8 = 0x10000
	_IMPL_POWER9 = 0x20000
)

func init() {
	impl := getsystemcfg(_SC_IMPL)
	if impl&_IMPL_POWER8 != 0 {
		PPC64.IsPOWER8 = true
	}
	if impl&_IMPL_POWER9 != 0 {
		PPC64.IsPOWER9 = true
	}

	Initialized = true
}

func getsystemcfg(label int) (n uint64) {
	r0, _ := callgetsystemcfg(label)
	n = uint64(r0)
	return
}

+ f be550c9a4fb5003bd10ef67c81124d4ef262a2f611f1195af1542705fbd68a76 vendor/golang.org/x/sys/cpu/cpu_arm.go
utf8file 41
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

const cacheLineSize = 32

// HWCAP/HWCAP2 bits.
// These are specific to Linux.
const (
	hwcap_SWP       = 1 << 0
	hwcap_HALF      = 1 << 1
	hwcap_THUMB     = 1 << 2
	hwcap_26BIT     = 1 << 3
	hwcap_FAST_MULT = 1 << 4
	hwcap_FPA       = 1 << 5
	hwcap_VFP       = 1 << 6
	hwcap_EDSP      = 1 << 7
	hwcap_JAVA      = 1 << 8
	hwcap_IWMMXT    = 1 << 9
	hwcap_CRUNCH    = 1 << 10
	hwcap_THUMBEE   = 1 << 11
	hwcap_NEON      = 1 << 12
	hwcap_VFPv3     = 1 << 13
	hwcap_VFPv3D16  = 1 << 14
	hwcap_TLS       = 1 << 15
	hwcap_VFPv4     = 1 << 16
	hwcap_IDIVA     = 1 << 17
	hwcap_IDIVT     = 1 << 18
	hwcap_VFPD32    = 1 << 19
	hwcap_LPAE      = 1 << 20
	hwcap_EVTSTRM   = 1 << 21

	hwcap2_AES   = 1 << 0
	hwcap2_PMULL = 1 << 1
	hwcap2_SHA1  = 1 << 2
	hwcap2_SHA2  = 1 << 3
	hwcap2_CRC32 = 1 << 4
)

+ f 8cbe02af951310a38a51725be0acbe6ab8ea0739bfdcbd2be70930ecfac20b41 vendor/golang.org/x/sys/cpu/cpu_arm64.go
utf8file 139
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import "runtime"

const cacheLineSize = 64

func init() {
	switch runtime.GOOS {
	case "android", "darwin":
		// Android and iOS don't seem to allow reading these registers.
		// Fake the minimal features expected by
		// TestARM64minimalFeatures.
		ARM64.HasASIMD = true
		ARM64.HasFP = true
	case "linux":
		doinit()
	default:
		readARM64Registers()
	}
}

func readARM64Registers() {
	Initialized = true

	// ID_AA64ISAR0_EL1
	isar0 := getisar0()

	switch extractBits(isar0, 4, 7) {
	case 1:
		ARM64.HasAES = true
	case 2:
		ARM64.HasAES = true
		ARM64.HasPMULL = true
	}

	switch extractBits(isar0, 8, 11) {
	case 1:
		ARM64.HasSHA1 = true
	}

	switch extractBits(isar0, 12, 15) {
	case 1:
		ARM64.HasSHA2 = true
	case 2:
		ARM64.HasSHA2 = true
		ARM64.HasSHA512 = true
	}

	switch extractBits(isar0, 16, 19) {
	case 1:
		ARM64.HasCRC32 = true
	}

	switch extractBits(isar0, 20, 23) {
	case 2:
		ARM64.HasATOMICS = true
	}

	switch extractBits(isar0, 28, 31) {
	case 1:
		ARM64.HasASIMDRDM = true
	}

	switch extractBits(isar0, 32, 35) {
	case 1:
		ARM64.HasSHA3 = true
	}

	switch extractBits(isar0, 36, 39) {
	case 1:
		ARM64.HasSM3 = true
	}

	switch extractBits(isar0, 40, 43) {
	case 1:
		ARM64.HasSM4 = true
	}

	switch extractBits(isar0, 44, 47) {
	case 1:
		ARM64.HasASIMDDP = true
	}

	// ID_AA64ISAR1_EL1
	isar1 := getisar1()

	switch extractBits(isar1, 0, 3) {
	case 1:
		ARM64.HasDCPOP = true
	}

	switch extractBits(isar1, 12, 15) {
	case 1:
		ARM64.HasJSCVT = true
	}

	switch extractBits(isar1, 16, 19) {
	case 1:
		ARM64.HasFCMA = true
	}

	switch extractBits(isar1, 20, 23) {
	case 1:
		ARM64.HasLRCPC = true
	}

	// ID_AA64PFR0_EL1
	pfr0 := getpfr0()

	switch extractBits(pfr0, 16, 19) {
	case 0:
		ARM64.HasFP = true
	case 1:
		ARM64.HasFP = true
		ARM64.HasFPHP = true
	}

	switch extractBits(pfr0, 20, 23) {
	case 0:
		ARM64.HasASIMD = true
	case 1:
		ARM64.HasASIMD = true
		ARM64.HasASIMDHP = true
	}

	switch extractBits(pfr0, 32, 35) {
	case 1:
		ARM64.HasSVE = true
	}
}

func extractBits(data uint64, start, end uint) uint {
	return (uint)(data>>start) & ((1 << (end - start + 1)) - 1)
}

+ f efdbc301fe53ec2215c855c0da88e36899299fd972216c84130611089d297cfd vendor/golang.org/x/sys/cpu/cpu_arm64.s
utf8file 32
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !gccgo

#include "textflag.h"

// func getisar0() uint64
TEXT getisar0(SB),NOSPLIT,$0-8
	// get Instruction Set Attributes 0 into x0
	// mrs x0, ID_AA64ISAR0_EL1 = d5380600
	WORD	$0xd5380600
	MOVD	R0, ret+0(FP)
	RET

// func getisar1() uint64
TEXT getisar1(SB),NOSPLIT,$0-8
	// get Instruction Set Attributes 1 into x0
	// mrs x0, ID_AA64ISAR1_EL1 = d5380620
	WORD	$0xd5380620
	MOVD	R0, ret+0(FP)
	RET

// func getpfr0() uint64
TEXT getpfr0(SB),NOSPLIT,$0-8
	// get Processor Feature Register 0 into x0
	// mrs x0, ID_AA64PFR0_EL1 = d5380400
	WORD	$0xd5380400
	MOVD	R0, ret+0(FP)
	RET

+ f a9f945291c7369ea21711df497af44de75f43f2a76abfafe3b9db49fcef12f4e vendor/golang.org/x/sys/cpu/cpu_gc_arm64.go
utf8file 12
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !gccgo

package cpu

func getisar0() uint64
func getisar1() uint64
func getpfr0() uint64

+ f 7a0824d4694a9df955c680896b3bc44ac587159beae26e3cd655909d070480e5 vendor/golang.org/x/sys/cpu/cpu_gc_s390x.go
utf8file 22
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !gccgo

package cpu

// haveAsmFunctions reports whether the other functions in this file can
// be safely called.
func haveAsmFunctions() bool { return true }

// The following feature detection functions are defined in cpu_s390x.s.
// They are likely to be expensive to call so the results should be cached.
func stfle() facilityList
func kmQuery() queryResult
func kmcQuery() queryResult
func kmctrQuery() queryResult
func kmaQuery() queryResult
func kimdQuery() queryResult
func klmdQuery() queryResult

+ f 6fc774c3f7ecf49f39efb02f10f1e555e328a34404643910fae532e44c2550a0 vendor/golang.org/x/sys/cpu/cpu_gc_x86.go
utf8file 17
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build 386 amd64 amd64p32
// +build !gccgo

package cpu

// cpuid is implemented in cpu_x86.s for gc compiler
// and in cpu_gccgo.c for gccgo.
func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)

// xgetbv with ecx = 0 is implemented in cpu_x86.s for gc compiler
// and in cpu_gccgo.c for gccgo.
func xgetbv() (eax, edx uint32)

+ f 48dad35499bc0256782f885eae350100223b2f26ea4d2770655f3cf32f5ed205 vendor/golang.org/x/sys/cpu/cpu_gccgo_arm64.go
utf8file 12
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build gccgo

package cpu

func getisar0() uint64 { return 0 }
func getisar1() uint64 { return 0 }
func getpfr0() uint64  { return 0 }

+ f dc75338ae401f04bae2680f62101c4fc1dcd9d38fc429bfb26edd822c2993d7f vendor/golang.org/x/sys/cpu/cpu_gccgo_s390x.go
utf8file 23
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build gccgo

package cpu

// haveAsmFunctions reports whether the other functions in this file can
// be safely called.
func haveAsmFunctions() bool { return false }

// TODO(mundaym): the following feature detection functions are currently
// stubs. See https://golang.org/cl/162887 for how to fix this.
// They are likely to be expensive to call so the results should be cached.
func stfle() facilityList     { panic("not implemented for gccgo") }
func kmQuery() queryResult    { panic("not implemented for gccgo") }
func kmcQuery() queryResult   { panic("not implemented for gccgo") }
func kmctrQuery() queryResult { panic("not implemented for gccgo") }
func kmaQuery() queryResult   { panic("not implemented for gccgo") }
func kimdQuery() queryResult  { panic("not implemented for gccgo") }
func klmdQuery() queryResult  { panic("not implemented for gccgo") }

+ f 949fb3fb19310e131e4b9ace39546965dcfdef017b28edf65b92c714acd32e19 vendor/golang.org/x/sys/cpu/cpu_gccgo_x86.c
utf8file 44
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build 386 amd64 amd64p32
// +build gccgo

#include <cpuid.h>
#include <stdint.h>

// Need to wrap __get_cpuid_count because it's declared as static.
int
gccgoGetCpuidCount(uint32_t leaf, uint32_t subleaf,
                   uint32_t *eax, uint32_t *ebx,
                   uint32_t *ecx, uint32_t *edx)
{
	return __get_cpuid_count(leaf, subleaf, eax, ebx, ecx, edx);
}

// xgetbv reads the contents of an XCR (Extended Control Register)
// specified in the ECX register into registers EDX:EAX.
// Currently, the only supported value for XCR is 0.
//
// TODO: Replace with a better alternative:
//
//     #include <xsaveintrin.h>
//
//     #pragma GCC target("xsave")
//
//     void gccgoXgetbv(uint32_t *eax, uint32_t *edx) {
//       unsigned long long x = _xgetbv(0);
//       *eax = x & 0xffffffff;
//       *edx = (x >> 32) & 0xffffffff;
//     }
//
// Note that _xgetbv is defined starting with GCC 8.
void
gccgoXgetbv(uint32_t *eax, uint32_t *edx)
{
	__asm("  xorl %%ecx, %%ecx\n"
	      "  xgetbv"
	    : "=a"(*eax), "=d"(*edx));
}

+ f bd5d1935113d1e40748858119b360d742432aac9ecd3c9a0ac79e1e71ddbbd1c vendor/golang.org/x/sys/cpu/cpu_gccgo_x86.go
utf8file 27
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build 386 amd64 amd64p32
// +build gccgo

package cpu

//extern gccgoGetCpuidCount
func gccgoGetCpuidCount(eaxArg, ecxArg uint32, eax, ebx, ecx, edx *uint32)

func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32) {
	var a, b, c, d uint32
	gccgoGetCpuidCount(eaxArg, ecxArg, &a, &b, &c, &d)
	return a, b, c, d
}

//extern gccgoXgetbv
func gccgoXgetbv(eax, edx *uint32)

func xgetbv() (eax, edx uint32) {
	var a, d uint32
	gccgoXgetbv(&a, &d)
	return a, d
}

+ f b19549fd2044207f8b0d188487f44e46459c108528a0f9946d6a47ea2b27adba vendor/golang.org/x/sys/cpu/cpu_linux.go
utf8file 16
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !386,!amd64,!amd64p32,!arm64

package cpu

func init() {
	if err := readHWCAP(); err != nil {
		return
	}
	doinit()
	Initialized = true
}

+ f 5c2f68fd8e53218eb96b8d67375564242a6bf825021a4ecbc8347af6f47898c0 vendor/golang.org/x/sys/cpu/cpu_linux_arm.go
utf8file 40
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

func doinit() {
	ARM.HasSWP = isSet(hwCap, hwcap_SWP)
	ARM.HasHALF = isSet(hwCap, hwcap_HALF)
	ARM.HasTHUMB = isSet(hwCap, hwcap_THUMB)
	ARM.Has26BIT = isSet(hwCap, hwcap_26BIT)
	ARM.HasFASTMUL = isSet(hwCap, hwcap_FAST_MULT)
	ARM.HasFPA = isSet(hwCap, hwcap_FPA)
	ARM.HasVFP = isSet(hwCap, hwcap_VFP)
	ARM.HasEDSP = isSet(hwCap, hwcap_EDSP)
	ARM.HasJAVA = isSet(hwCap, hwcap_JAVA)
	ARM.HasIWMMXT = isSet(hwCap, hwcap_IWMMXT)
	ARM.HasCRUNCH = isSet(hwCap, hwcap_CRUNCH)
	ARM.HasTHUMBEE = isSet(hwCap, hwcap_THUMBEE)
	ARM.HasNEON = isSet(hwCap, hwcap_NEON)
	ARM.HasVFPv3 = isSet(hwCap, hwcap_VFPv3)
	ARM.HasVFPv3D16 = isSet(hwCap, hwcap_VFPv3D16)
	ARM.HasTLS = isSet(hwCap, hwcap_TLS)
	ARM.HasVFPv4 = isSet(hwCap, hwcap_VFPv4)
	ARM.HasIDIVA = isSet(hwCap, hwcap_IDIVA)
	ARM.HasIDIVT = isSet(hwCap, hwcap_IDIVT)
	ARM.HasVFPD32 = isSet(hwCap, hwcap_VFPD32)
	ARM.HasLPAE = isSet(hwCap, hwcap_LPAE)
	ARM.HasEVTSTRM = isSet(hwCap, hwcap_EVTSTRM)
	ARM.HasAES = isSet(hwCap2, hwcap2_AES)
	ARM.HasPMULL = isSet(hwCap2, hwcap2_PMULL)
	ARM.HasSHA1 = isSet(hwCap2, hwcap2_SHA1)
	ARM.HasSHA2 = isSet(hwCap2, hwcap2_SHA2)
	ARM.HasCRC32 = isSet(hwCap2, hwcap2_CRC32)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

+ f 10489a511b2f6ebd7ca1e7a53d18cb20079f6c8c000ac9b45e3119578056eb5e vendor/golang.org/x/sys/cpu/cpu_linux_arm64.go
utf8file 72
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

// HWCAP/HWCAP2 bits. These are exposed by Linux.
const (
	hwcap_FP       = 1 << 0
	hwcap_ASIMD    = 1 << 1
	hwcap_EVTSTRM  = 1 << 2
	hwcap_AES      = 1 << 3
	hwcap_PMULL    = 1 << 4
	hwcap_SHA1     = 1 << 5
	hwcap_SHA2     = 1 << 6
	hwcap_CRC32    = 1 << 7
	hwcap_ATOMICS  = 1 << 8
	hwcap_FPHP     = 1 << 9
	hwcap_ASIMDHP  = 1 << 10
	hwcap_CPUID    = 1 << 11
	hwcap_ASIMDRDM = 1 << 12
	hwcap_JSCVT    = 1 << 13
	hwcap_FCMA     = 1 << 14
	hwcap_LRCPC    = 1 << 15
	hwcap_DCPOP    = 1 << 16
	hwcap_SHA3     = 1 << 17
	hwcap_SM3      = 1 << 18
	hwcap_SM4      = 1 << 19
	hwcap_ASIMDDP  = 1 << 20
	hwcap_SHA512   = 1 << 21
	hwcap_SVE      = 1 << 22
	hwcap_ASIMDFHM = 1 << 23
)

func doinit() {
	if err := readHWCAP(); err != nil {
		// failed to read /proc/self/auxv, try reading registers directly
		readARM64Registers()
		return
	}

	// HWCAP feature bits
	ARM64.HasFP = isSet(hwCap, hwcap_FP)
	ARM64.HasASIMD = isSet(hwCap, hwcap_ASIMD)
	ARM64.HasEVTSTRM = isSet(hwCap, hwcap_EVTSTRM)
	ARM64.HasAES = isSet(hwCap, hwcap_AES)
	ARM64.HasPMULL = isSet(hwCap, hwcap_PMULL)
	ARM64.HasSHA1 = isSet(hwCap, hwcap_SHA1)
	ARM64.HasSHA2 = isSet(hwCap, hwcap_SHA2)
	ARM64.HasCRC32 = isSet(hwCap, hwcap_CRC32)
	ARM64.HasATOMICS = isSet(hwCap, hwcap_ATOMICS)
	ARM64.HasFPHP = isSet(hwCap, hwcap_FPHP)
	ARM64.HasASIMDHP = isSet(hwCap, hwcap_ASIMDHP)
	ARM64.HasCPUID = isSet(hwCap, hwcap_CPUID)
	ARM64.HasASIMDRDM = isSet(hwCap, hwcap_ASIMDRDM)
	ARM64.HasJSCVT = isSet(hwCap, hwcap_JSCVT)
	ARM64.HasFCMA = isSet(hwCap, hwcap_FCMA)
	ARM64.HasLRCPC = isSet(hwCap, hwcap_LRCPC)
	ARM64.HasDCPOP = isSet(hwCap, hwcap_DCPOP)
	ARM64.HasSHA3 = isSet(hwCap, hwcap_SHA3)
	ARM64.HasSM3 = isSet(hwCap, hwcap_SM3)
	ARM64.HasSM4 = isSet(hwCap, hwcap_SM4)
	ARM64.HasASIMDDP = isSet(hwCap, hwcap_ASIMDDP)
	ARM64.HasSHA512 = isSet(hwCap, hwcap_SHA512)
	ARM64.HasSVE = isSet(hwCap, hwcap_SVE)
	ARM64.HasASIMDFHM = isSet(hwCap, hwcap_ASIMDFHM)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

+ f 4d241dd2e5c348dde4210a02ffa396a1f622bee45588a5d0a62e21b60643b75d vendor/golang.org/x/sys/cpu/cpu_linux_noinit.go
utf8file 10
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build linux,!arm,!arm64,!ppc64,!ppc64le,!s390x

package cpu

func doinit() {}

+ f 940d99cc88cd93bbd716cd0db638220ee2f453fdd4f4455d3fe37d895f769976 vendor/golang.org/x/sys/cpu/cpu_linux_ppc64x.go
utf8file 34
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build linux
// +build ppc64 ppc64le

package cpu

const cacheLineSize = 128

// HWCAP/HWCAP2 bits. These are exposed by the kernel.
const (
	// ISA Level
	_PPC_FEATURE2_ARCH_2_07 = 0x80000000
	_PPC_FEATURE2_ARCH_3_00 = 0x00800000

	// CPU features
	_PPC_FEATURE2_DARN = 0x00200000
	_PPC_FEATURE2_SCV  = 0x00100000
)

func doinit() {
	// HWCAP2 feature bits
	PPC64.IsPOWER8 = isSet(hwCap2, _PPC_FEATURE2_ARCH_2_07)
	PPC64.IsPOWER9 = isSet(hwCap2, _PPC_FEATURE2_ARCH_3_00)
	PPC64.HasDARN = isSet(hwCap2, _PPC_FEATURE2_DARN)
	PPC64.HasSCV = isSet(hwCap2, _PPC_FEATURE2_SCV)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

+ f 900d0ba8c415449943c30d8e2157c7385dbadf7437ed7989b7c4810d87be9781 vendor/golang.org/x/sys/cpu/cpu_linux_s390x.go
utf8file 162
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

const cacheLineSize = 256

const (
	// bit mask values from /usr/include/bits/hwcap.h
	hwcap_ZARCH  = 2
	hwcap_STFLE  = 4
	hwcap_MSA    = 8
	hwcap_LDISP  = 16
	hwcap_EIMM   = 32
	hwcap_DFP    = 64
	hwcap_ETF3EH = 256
	hwcap_VX     = 2048
	hwcap_VXE    = 8192
)

// bitIsSet reports whether the bit at index is set. The bit index
// is in big endian order, so bit index 0 is the leftmost bit.
func bitIsSet(bits []uint64, index uint) bool {
	return bits[index/64]&((1<<63)>>(index%64)) != 0
}

// function is the code for the named cryptographic function.
type function uint8

const (
	// KM{,A,C,CTR} function codes
	aes128 function = 18 // AES-128
	aes192 function = 19 // AES-192
	aes256 function = 20 // AES-256

	// K{I,L}MD function codes
	sha1     function = 1  // SHA-1
	sha256   function = 2  // SHA-256
	sha512   function = 3  // SHA-512
	sha3_224 function = 32 // SHA3-224
	sha3_256 function = 33 // SHA3-256
	sha3_384 function = 34 // SHA3-384
	sha3_512 function = 35 // SHA3-512
	shake128 function = 36 // SHAKE-128
	shake256 function = 37 // SHAKE-256

	// KLMD function codes
	ghash function = 65 // GHASH
)

// queryResult contains the result of a Query function
// call. Bits are numbered in big endian order so the
// leftmost bit (the MSB) is at index 0.
type queryResult struct {
	bits [2]uint64
}

// Has reports whether the given functions are present.
func (q *queryResult) Has(fns ...function) bool {
	if len(fns) == 0 {
		panic("no function codes provided")
	}
	for _, f := range fns {
		if !bitIsSet(q.bits[:], uint(f)) {
			return false
		}
	}
	return true
}

// facility is a bit index for the named facility.
type facility uint8

const (
	// cryptography facilities
	msa4 facility = 77  // message-security-assist extension 4
	msa8 facility = 146 // message-security-assist extension 8
)

// facilityList contains the result of an STFLE call.
// Bits are numbered in big endian order so the
// leftmost bit (the MSB) is at index 0.
type facilityList struct {
	bits [4]uint64
}

// Has reports whether the given facilities are present.
func (s *facilityList) Has(fs ...facility) bool {
	if len(fs) == 0 {
		panic("no facility bits provided")
	}
	for _, f := range fs {
		if !bitIsSet(s.bits[:], uint(f)) {
			return false
		}
	}
	return true
}

func doinit() {
	// test HWCAP bit vector
	has := func(featureMask uint) bool {
		return hwCap&featureMask == featureMask
	}

	// mandatory
	S390X.HasZARCH = has(hwcap_ZARCH)

	// optional
	S390X.HasSTFLE = has(hwcap_STFLE)
	S390X.HasLDISP = has(hwcap_LDISP)
	S390X.HasEIMM = has(hwcap_EIMM)
	S390X.HasETF3EH = has(hwcap_ETF3EH)
	S390X.HasDFP = has(hwcap_DFP)
	S390X.HasMSA = has(hwcap_MSA)
	S390X.HasVX = has(hwcap_VX)
	if S390X.HasVX {
		S390X.HasVXE = has(hwcap_VXE)
	}

	// We need implementations of stfle, km and so on
	// to detect cryptographic features.
	if !haveAsmFunctions() {
		return
	}

	// optional cryptographic functions
	if S390X.HasMSA {
		aes := []function{aes128, aes192, aes256}

		// cipher message
		km, kmc := kmQuery(), kmcQuery()
		S390X.HasAES = km.Has(aes...)
		S390X.HasAESCBC = kmc.Has(aes...)
		if S390X.HasSTFLE {
			facilities := stfle()
			if facilities.Has(msa4) {
				kmctr := kmctrQuery()
				S390X.HasAESCTR = kmctr.Has(aes...)
			}
			if facilities.Has(msa8) {
				kma := kmaQuery()
				S390X.HasAESGCM = kma.Has(aes...)
			}
		}

		// compute message digest
		kimd := kimdQuery() // intermediate (no padding)
		klmd := klmdQuery() // last (padding)
		S390X.HasSHA1 = kimd.Has(sha1) && klmd.Has(sha1)
		S390X.HasSHA256 = kimd.Has(sha256) && klmd.Has(sha256)
		S390X.HasSHA512 = kimd.Has(sha512) && klmd.Has(sha512)
		S390X.HasGHASH = kimd.Has(ghash) // KLMD-GHASH does not exist
		sha3 := []function{
			sha3_224, sha3_256, sha3_384, sha3_512,
			shake128, shake256,
		}
		S390X.HasSHA3 = kimd.Has(sha3...) && klmd.Has(sha3...)
	}
}

+ f 978b377363e31a1449d616f7131d53e0f9275dfaefdc001a2e1fcefefac3a97d vendor/golang.org/x/sys/cpu/cpu_mips64x.go
utf8file 10
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build mips64 mips64le

package cpu

const cacheLineSize = 32

+ f 3d31b2feb02b25f50e89742158233d946bac26874772a22cbea8f9aae0e84507 vendor/golang.org/x/sys/cpu/cpu_mipsx.go
utf8file 10
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build mips mipsle

package cpu

const cacheLineSize = 32

+ f 15f7c263a4937fb9bff31c8552f9297cb2eebf457e91231adda41787bb6235c8 vendor/golang.org/x/sys/cpu/cpu_other_arm64.go
utf8file 10
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !linux,arm64

package cpu

func doinit() {}

+ f 557c79c5e1a75c88fb09b5286199c338d6b8160e34a871ac684bf6d5ffae2f57 vendor/golang.org/x/sys/cpu/cpu_riscv64.go
utf8file 10
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build riscv64

package cpu

const cacheLineSize = 32

+ f 2ac782d64a1b7ec95bce69241eb94982acd526608a5848a18ac0bc6a2fd0b2f5 vendor/golang.org/x/sys/cpu/cpu_s390x.s
utf8file 58
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !gccgo

#include "textflag.h"

// func stfle() facilityList
TEXT stfle(SB), NOSPLIT|NOFRAME, $0-32
	MOVD $ret+0(FP), R1
	MOVD $3, R0          // last doubleword index to store
	XC   $32, (R1), (R1) // clear 4 doublewords (32 bytes)
	WORD $0xb2b01000     // store facility list extended (STFLE)
	RET

// func kmQuery() queryResult
TEXT kmQuery(SB), NOSPLIT|NOFRAME, $0-16
	MOVD $0, R0         // set function code to 0 (KM-Query)
	MOVD $ret+0(FP), R1 // address of 16-byte return value
	WORD $0xB92E0024    // cipher message (KM)
	RET

// func kmcQuery() queryResult
TEXT kmcQuery(SB), NOSPLIT|NOFRAME, $0-16
	MOVD $0, R0         // set function code to 0 (KMC-Query)
	MOVD $ret+0(FP), R1 // address of 16-byte return value
	WORD $0xB92F0024    // cipher message with chaining (KMC)
	RET

// func kmctrQuery() queryResult
TEXT kmctrQuery(SB), NOSPLIT|NOFRAME, $0-16
	MOVD $0, R0         // set function code to 0 (KMCTR-Query)
	MOVD $ret+0(FP), R1 // address of 16-byte return value
	WORD $0xB92D4024    // cipher message with counter (KMCTR)
	RET

// func kmaQuery() queryResult
TEXT kmaQuery(SB), NOSPLIT|NOFRAME, $0-16
	MOVD $0, R0         // set function code to 0 (KMA-Query)
	MOVD $ret+0(FP), R1 // address of 16-byte return value
	WORD $0xb9296024    // cipher message with authentication (KMA)
	RET

// func kimdQuery() queryResult
TEXT kimdQuery(SB), NOSPLIT|NOFRAME, $0-16
	MOVD $0, R0         // set function code to 0 (KIMD-Query)
	MOVD $ret+0(FP), R1 // address of 16-byte return value
	WORD $0xB93E0024    // compute intermediate message digest (KIMD)
	RET

// func klmdQuery() queryResult
TEXT klmdQuery(SB), NOSPLIT|NOFRAME, $0-16
	MOVD $0, R0         // set function code to 0 (KLMD-Query)
	MOVD $ret+0(FP), R1 // address of 16-byte return value
	WORD $0xB93F0024    // compute last message digest (KLMD)
	RET

+ f 3f3f1ed25237b86e108020786bdce5c6102a4a151bd528cd80e37e2667903e60 vendor/golang.org/x/sys/cpu/cpu_wasm.go
utf8file 14
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build wasm

package cpu

// We're compiling the cpu package for an unknown (software-abstracted) CPU.
// Make CacheLinePad an empty struct and hope that the usual struct alignment
// rules are good enough.

const cacheLineSize = 0

+ f df640a269ad926db7789bb735a2307e9d4e3d7c9cd083062e7dcbba2c3e8aa0b vendor/golang.org/x/sys/cpu/cpu_x86.go
utf8file 60
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build 386 amd64 amd64p32

package cpu

const cacheLineSize = 64

func init() {
	Initialized = true

	maxID, _, _, _ := cpuid(0, 0)

	if maxID < 1 {
		return
	}

	_, _, ecx1, edx1 := cpuid(1, 0)
	X86.HasSSE2 = isSet(26, edx1)

	X86.HasSSE3 = isSet(0, ecx1)
	X86.HasPCLMULQDQ = isSet(1, ecx1)
	X86.HasSSSE3 = isSet(9, ecx1)
	X86.HasFMA = isSet(12, ecx1)
	X86.HasSSE41 = isSet(19, ecx1)
	X86.HasSSE42 = isSet(20, ecx1)
	X86.HasPOPCNT = isSet(23, ecx1)
	X86.HasAES = isSet(25, ecx1)
	X86.HasOSXSAVE = isSet(27, ecx1)
	X86.HasRDRAND = isSet(30, ecx1)

	osSupportsAVX := false
	// For XGETBV, OSXSAVE bit is required and sufficient.
	if X86.HasOSXSAVE {
		eax, _ := xgetbv()
		// Check if XMM and YMM registers have OS support.
		osSupportsAVX = isSet(1, eax) && isSet(2, eax)
	}

	X86.HasAVX = isSet(28, ecx1) && osSupportsAVX

	if maxID < 7 {
		return
	}

	_, ebx7, _, _ := cpuid(7, 0)
	X86.HasBMI1 = isSet(3, ebx7)
	X86.HasAVX2 = isSet(5, ebx7) && osSupportsAVX
	X86.HasBMI2 = isSet(8, ebx7)
	X86.HasERMS = isSet(9, ebx7)
	X86.HasRDSEED = isSet(18, ebx7)
	X86.HasADX = isSet(19, ebx7)
}

func isSet(bitpos uint, value uint32) bool {
	return value&(1<<bitpos) != 0
}

+ f 5ae0471e439f6a906450f72ca46cc2a503253588940d0c935392705b7ad732f2 vendor/golang.org/x/sys/cpu/cpu_x86.s
utf8file 28
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build 386 amd64 amd64p32
// +build !gccgo

#include "textflag.h"

// func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)
TEXT cpuid(SB), NOSPLIT, $0-24
	MOVL eaxArg+0(FP), AX
	MOVL ecxArg+4(FP), CX
	CPUID
	MOVL AX, eax+8(FP)
	MOVL BX, ebx+12(FP)
	MOVL CX, ecx+16(FP)
	MOVL DX, edx+20(FP)
	RET

// func xgetbv() (eax, edx uint32)
TEXT xgetbv(SB),NOSPLIT,$0-8
	MOVL $0, CX
	XGETBV
	MOVL AX, eax+0(FP)
	MOVL DX, edx+4(FP)
	RET

+ f d5dcac74c0407b4c33efc38a97dd3206c2e3cb74220c41d5612293c05147d224 vendor/golang.org/x/sys/cpu/hwcap_linux.go
utf8file 57
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"io/ioutil"
)

const (
	_AT_HWCAP  = 16
	_AT_HWCAP2 = 26

	procAuxv = "/proc/self/auxv"

	uintSize = int(32 << (^uint(0) >> 63))
)

// For those platforms don't have a 'cpuid' equivalent we use HWCAP/HWCAP2
// These are initialized in cpu_$GOARCH.go
// and should not be changed after they are initialized.
var hwCap uint
var hwCap2 uint

func readHWCAP() error {
	buf, err := ioutil.ReadFile(procAuxv)
	if err != nil {
		// e.g. on android /proc/self/auxv is not accessible, so silently
		// ignore the error and leave Initialized = false. On some
		// architectures (e.g. arm64) doinit() implements a fallback
		// readout and will set Initialized = true again.
		return err
	}
	bo := hostByteOrder()
	for len(buf) >= 2*(uintSize/8) {
		var tag, val uint
		switch uintSize {
		case 32:
			tag = uint(bo.Uint32(buf[0:]))
			val = uint(bo.Uint32(buf[4:]))
			buf = buf[8:]
		case 64:
			tag = uint(bo.Uint64(buf[0:]))
			val = uint(bo.Uint64(buf[8:]))
			buf = buf[16:]
		}
		switch tag {
		case _AT_HWCAP:
			hwCap = val
		case _AT_HWCAP2:
			hwCap2 = val
		}
	}
	return nil
}

+ f baf3d699b9d94ac7ed555c4a3a9812960ef0b06e621e56d7a0da9a924cd8fc1e vendor/golang.org/x/sys/cpu/syscall_aix_ppc64_gc.go
utf8file 37
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Minimal copy of x/sys/unix so the cpu package can make a
// system call on AIX without depending on x/sys/unix.
// (See golang.org/issue/32102)

// +build aix,ppc64
// +build !gccgo

package cpu

import (
	"syscall"
	"unsafe"
)

//go:cgo_import_dynamic libc_getsystemcfg getsystemcfg "libc.a/shr_64.o"

//go:linkname libc_getsystemcfg libc_getsystemcfg

type syscallFunc uintptr

var libc_getsystemcfg syscallFunc

type errno = syscall.Errno

// Implemented in runtime/syscall_aix.go.
func rawSyscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err errno)
func syscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err errno)

func callgetsystemcfg(label int) (r1 uintptr, e1 errno) {
	r1, _, e1 = syscall6(uintptr(unsafe.Pointer(&libc_getsystemcfg)), 1, uintptr(label), 0, 0, 0, 0, 0)
	return
}

- f 334250a30969fe3c1b8db14c77a5293d911f1dfaa9e6c5bef8c6f03bed915988 vendor/golang.org/x/sys/unix/asm_linux_riscv64.s
+ f 13b17ae3c256fb84d2c66d68c9032aba04333e22bc1831cb64f1b3bc887686ad vendor/golang.org/x/sys/unix/asm_linux_riscv64.s
dmppatch 8
@@ -587,56 +587,8 @@
  A2%0A
-%09MOV%09$0, A3%0A%09MOV%09$0, A4%0A%09MOV%09$0, A5%0A%09MOV%09$0, A6%0A
 %09MOV
@@ -951,50 +951,8 @@
  A2%0A
-%09MOV%09ZERO, A3%0A%09MOV%09ZERO, A4%0A%09MOV%09ZERO, A5%0A
 %09MOV
- f 434279e5a2e214c450fef5f9c428df1968a2ea4b9510958978a73d4a3304c8c1 vendor/golang.org/x/sys/unix/mkerrors.sh
+ f 28e788c278685da9bb7e3eff1c8e854b59ce3ad5850fbfd251c0bbfc51fab791 vendor/golang.org/x/sys/unix/mkerrors.sh
dmppatch 5
@@ -11910,60 +11910,66 @@
  &&%0A
-%09%09$2 ~ /%5E(IFF%7CIFT%7CNET_RT%7CRTM%7CRTF%7CRTV%7CRTA%7CRTAX)_/ %7C%7C%0A
+%09%09$2 ~ /%5E(IFF%7CIFT%7CNET_RT%7CRTM(GRP)?%7CRTF%7CRTV%7CRTA%7CRTAX)_/ %7C%7C%0A
 %09%09$2
- f 65c167ff3cd44c7d255c1792c367cad2ddcba54d18146d91954f3a2c9c2405ee vendor/golang.org/x/sys/unix/syscall_bsd.go
+ f a17f7d7e32b34fedab412a245f4b167a20640a68a6ff2874247e27bacfc79470 vendor/golang.org/x/sys/unix/syscall_bsd.go
dmppatch 4
@@ -12979,24 +12979,365 @@
 :n%5D, nil%0A%7D%0A%0A
+func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 //sys%09utimes
- f 2e4853e8cc8b933e22e6867232631ecb37df542df4f551d26e9a4948903c2e95 vendor/golang.org/x/sys/unix/syscall_darwin.go
+ f 9d5edc113ff4a8303b99827516df8937e377497feba3d6ae68de10ffa3a737cb vendor/golang.org/x/sys/unix/syscall_darwin.go
dmppatch 4
@@ -4491,349 +4491,8 @@
 r)%0A%0A
-func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 //sy
- f 0a2553402e0d97905e85868097519ff3d954e50921e2a46d62b65fc9c46798e2 vendor/golang.org/x/sys/unix/syscall_darwin_arm.1_11.go
+ f 71e569be580271e661729f5e22973655e92b30b95fac710228cd7ed0d2d1b783 vendor/golang.org/x/sys/unix/syscall_darwin_arm.1_11.go
dmppatch 5
@@ -157,37 +157,37 @@
 e.%0A%0A
-// +build darwin,386,!go1.12%0A
+// +build darwin,arm,!go1.12%0A
 %0Apac
- f 1a029a02c05adaf80653dda2507d92316bb2204db78f585d391f878e287c417d vendor/golang.org/x/sys/unix/syscall_freebsd.go
+ f 2e3b8d84f1cde016e5f6e0b885748f6d9dcca33773c375c12d2dc682f54ddcbd vendor/golang.org/x/sys/unix/syscall_freebsd.go
dmppatch 4
@@ -13660,340 +13660,8 @@
 %0A%7D%0A%0A
-func PtraceIO(req int, pid int, addr uintptr, out %5B%5Dbyte, countin int) (count int, err error) %7B%0A%09ioDesc := PtraceIoDesc%7BOp: int32(req), Offs: (*byte)(unsafe.Pointer(addr)), Addr: (*byte)(unsafe.Pointer(&out%5B0%5D)), Len: uint(countin)%7D%0A%09err = ptrace(PTRACE_IO, pid, uintptr(unsafe.Pointer(&ioDesc)), 0)%0A%09return int(ioDesc.Len), err%0A%7D%0A%0A
 func
- f 70811b83e3110480182101edec70574f95186738f61c590c24322e4de12e9ed3 vendor/golang.org/x/sys/unix/syscall_freebsd_386.go
+ f 485672f2474585851595e5941d5598075d326b57d61d3241813032267318efb0 vendor/golang.org/x/sys/unix/syscall_freebsd_386.go
dmppatch 3
@@ -1310,8 +1310,342 @@
 .Errno)%0A
+%0Afunc PtraceIO(req int, pid int, addr uintptr, out %5B%5Dbyte, countin int) (count int, err error) %7B%0A%09ioDesc := PtraceIoDesc%7BOp: int32(req), Offs: (*byte)(unsafe.Pointer(addr)), Addr: (*byte)(unsafe.Pointer(&out%5B0%5D)), Len: uint32(countin)%7D%0A%09err = ptrace(PTRACE_IO, pid, uintptr(unsafe.Pointer(&ioDesc)), 0)%0A%09return int(ioDesc.Len), err%0A%7D%0A
- f 2c741ce85043e32bb1bf8ac8bb14960fdadec93c40a95ddae93ae0789be65f3b vendor/golang.org/x/sys/unix/syscall_freebsd_amd64.go
+ f 874450dab69d0b9fe4d077a426c57af41a20a0d2ee3d94f4b1f223048ec756b5 vendor/golang.org/x/sys/unix/syscall_freebsd_amd64.go
dmppatch 3
@@ -1263,8 +1263,342 @@
 .Errno)%0A
+%0Afunc PtraceIO(req int, pid int, addr uintptr, out %5B%5Dbyte, countin int) (count int, err error) %7B%0A%09ioDesc := PtraceIoDesc%7BOp: int32(req), Offs: (*byte)(unsafe.Pointer(addr)), Addr: (*byte)(unsafe.Pointer(&out%5B0%5D)), Len: uint64(countin)%7D%0A%09err = ptrace(PTRACE_IO, pid, uintptr(unsafe.Pointer(&ioDesc)), 0)%0A%09return int(ioDesc.Len), err%0A%7D%0A
- f fd76abc482151a595a067e66674acc5b7fc56c7cae83812b434ed1741db7d2ae vendor/golang.org/x/sys/unix/syscall_freebsd_arm.go
+ f 9da72e5fcd95c4bfe37ec06348185b69ca28c9cd313f0da6b3f1e29a701003da vendor/golang.org/x/sys/unix/syscall_freebsd_arm.go
dmppatch 3
@@ -1296,8 +1296,342 @@
 .Errno)%0A
+%0Afunc PtraceIO(req int, pid int, addr uintptr, out %5B%5Dbyte, countin int) (count int, err error) %7B%0A%09ioDesc := PtraceIoDesc%7BOp: int32(req), Offs: (*byte)(unsafe.Pointer(addr)), Addr: (*byte)(unsafe.Pointer(&out%5B0%5D)), Len: uint32(countin)%7D%0A%09err = ptrace(PTRACE_IO, pid, uintptr(unsafe.Pointer(&ioDesc)), 0)%0A%09return int(ioDesc.Len), err%0A%7D%0A
- f d195840853e4bd34dc1bf3cce4425ad85774a25701c42fbd8ba48f638dc3d109 vendor/golang.org/x/sys/unix/syscall_freebsd_arm64.go
+ f 278d66e92a4bf6bc043bdedd2944fec7785b67052aee42faa208b14a1ff4142a vendor/golang.org/x/sys/unix/syscall_freebsd_arm64.go
dmppatch 3
@@ -1263,8 +1263,342 @@
 .Errno)%0A
+%0Afunc PtraceIO(req int, pid int, addr uintptr, out %5B%5Dbyte, countin int) (count int, err error) %7B%0A%09ioDesc := PtraceIoDesc%7BOp: int32(req), Offs: (*byte)(unsafe.Pointer(addr)), Addr: (*byte)(unsafe.Pointer(&out%5B0%5D)), Len: uint64(countin)%7D%0A%09err = ptrace(PTRACE_IO, pid, uintptr(unsafe.Pointer(&ioDesc)), 0)%0A%09return int(ioDesc.Len), err%0A%7D%0A
- f 27b14ae53f533d07b3d686e514e3eab87b81d9318270b7b3053fbf307a041b76 vendor/golang.org/x/sys/unix/syscall_linux.go
+ f 26f79e3f5b48e713d9db60ead34c8841946675d3fa14957c1751a8b2318c75ea vendor/golang.org/x/sys/unix/syscall_linux.go
dmppatch 9
@@ -46081,136 +46081,140 @@
 or)%0A
-//sys%09Capget(hdr *CapUserHeader, data *CapUserData) (err error)%0A//sys%09Capset(hdr *CapUserHeader, data *CapUserData) (err error)%0A
+//sysnb%09Capget(hdr *CapUserHeader, data *CapUserData) (err error)%0A//sysnb%09Capset(hdr *CapUserHeader, data *CapUserData) (err error)%0A
 //sy
@@ -51123,32 +51123,803 @@
 turn EOPNOTSUPP%0A
+%7D%0A%0A// SetfsgidRetGid sets fsgid for current thread and returns previous fsgid set.%0A// setfsgid(2) will return a non-nil error only if its caller lacks CAP_SETUID capability.%0A// If the call fails due to other reasons, current fsgid will be returned.%0Afunc SetfsgidRetGid(gid int) (int, error) %7B%0A%09return setfsgid(gid)%0A%7D%0A%0A// SetfsuidRetUid sets fsuid for current thread and returns previous fsuid set.%0A// setfsgid(2) will return a non-nil error only if its caller lacks CAP_SETUID capability%0A// If the call fails due to other reasons, current fsuid will be returned.%0Afunc SetfsuidRetUid(uid int) (int, error) %7B%0A%09return setfsuid(uid)%0A%7D%0A%0Afunc Setfsgid(gid int) error %7B%0A%09_, err := setfsgid(gid)%0A%09return err%0A%7D%0A%0Afunc Setfsuid(uid int) error %7B%0A%09_, err := setfsuid(uid)%0A%09return err%0A
 %7D%0A%0Afunc Signalfd
- f 7230bc2e24ce247f1483d4831c1ef0b3fa1987edef59c7ef9dc3eaf5d2c63c8b vendor/golang.org/x/sys/unix/syscall_linux_386.go
+ f 9f5452e22d24a288f3abfa625a88351e765c74c3c867629a6a12695b20826036 vendor/golang.org/x/sys/unix/syscall_linux_386.go
dmppatch 5
@@ -2382,114 +2382,134 @@
 E64%0A
-//sys%09Setfsgid(gid int) (err error) = SYS_SETFSGID32%0A//sys%09Setfsuid(uid int) (err error) = SYS_SETFSUID32%0A
+//sys%09setfsgid(gid int) (prev int, err error) = SYS_SETFSGID32%0A//sys%09setfsuid(uid int) (prev int, err error) = SYS_SETFSUID32%0A
 //sy
- f 0ad9bb0905b4578e5b188055d98e5593e882f9fbfdd8b25e1a506f25573d7e7e vendor/golang.org/x/sys/unix/syscall_linux_amd64.go
+ f b3dc158541844e04e72ae43c26cff1b8e4769eda02681bba99a32657ec6ee8ef vendor/golang.org/x/sys/unix/syscall_linux_amd64.go
dmppatch 5
@@ -2134,80 +2134,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f 3560187bcbe88fb7f40e986fc1b54d43edb0c116fbd280b009b34c7668e23828 vendor/golang.org/x/sys/unix/syscall_linux_arm.go
+ f b573301ec3525b996b898bc6ff97d05287b14089f7d0777b021e9216dc5cbbc8 vendor/golang.org/x/sys/unix/syscall_linux_arm.go
dmppatch 5
@@ -3816,114 +3816,134 @@
 ECT%0A
-//sys%09Setfsgid(gid int) (err error) = SYS_SETFSGID32%0A//sys%09Setfsuid(uid int) (err error) = SYS_SETFSUID32%0A
+//sys%09setfsgid(gid int) (prev int, err error) = SYS_SETFSGID32%0A//sys%09setfsuid(uid int) (prev int, err error) = SYS_SETFSUID32%0A
 //sy
- f 96bb7b0a913f3e6abdd0cacd6fab5625ee71bf5624c7cec19c234582b6933c97 vendor/golang.org/x/sys/unix/syscall_linux_arm64.go
+ f 2b37b6a3bf4ed5a9a055b8d12b2aefdc16d101a8c817fc5aa66d759267be54f2 vendor/golang.org/x/sys/unix/syscall_linux_arm64.go
dmppatch 5
@@ -1634,80 +1634,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f 7f6fe3ef27c6dc16e40862acb0a4340f1e363786d8b2b8024cf066a30a51b4b6 vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go
+ f 770ddf95f7c533829879a2bfbdad91e2d43544a0dd064c52c7ab6a9e97ef70a9 vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go
dmppatch 9
@@ -1563,80 +1563,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
@@ -6687,16 +6687,84 @@
 length)%0A
+%7D%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09return InotifyInit1(0)%0A
 %7D%0A%0A//sys
- f 1dbe3a9a64bcb1d9afdfa85c8e78452c3c2bbc6a351f8322cbfa7400d81ddcd8 vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go
+ f 55f5f4375a835b1d7dbc5b1818050e983d73b6a6e2ca9faf526b4dffc9bceaea vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go
dmppatch 5
@@ -1384,80 +1384,100 @@
 E64%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f 18b79609bb16bb4256cbeb7975c8e164f3bd0b3c7f57612fb2ee013d45a82213 vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go
+ f f7513104426c907e2210f00e9dbe4cc1ffbe20cdeaf100349d545e98458bc265 vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go
dmppatch 5
@@ -1764,80 +1764,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f 61c517eb24866108d34aef3c2aed16aab36a39f9da55f05bb4152d5090fdefd4 vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go
+ f 93b778699f072488c14bd55816b49d83eb9c07b97a00b35ff33bb8c7263c54e6 vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go
dmppatch 5
@@ -1549,80 +1549,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f 40214fabc99070931db0541eb11b2794ae14394869b3439d3d1b85c4540914de vendor/golang.org/x/sys/unix/syscall_linux_s390x.go
+ f 2c7ddea61fdd1b305a59cbfe2f387476144e8d268897f120df8a849f5c5b8e39 vendor/golang.org/x/sys/unix/syscall_linux_s390x.go
dmppatch 5
@@ -1609,80 +1609,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f 612780cf1138122cc94c2fa23cfeab149e6180c5c5a87dd1791ed807d06a5131 vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go
+ f 209b69f4b02b35abddb576ef92a48394d87a001bd19cb58a4c57dfa79a6c9c1a vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go
dmppatch 5
@@ -1577,80 +1577,100 @@
 or)%0A
-//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A
+//sys%09setfsgid(gid int) (prev int, err error)%0A//sys%09setfsuid(uid int) (prev int, err error)%0A
 //sy
- f a4f649f8465a364459d9eb6378d68f00690a2bdf4c8b5dc6a4c1c3be0394fdbf vendor/golang.org/x/sys/unix/syscall_netbsd.go
+ f 82f4e68a2c3e307543194f612d6b2565b7222cccb7039b7d3790c0761e3803e0 vendor/golang.org/x/sys/unix/syscall_netbsd.go
dmppatch 18
@@ -2734,349 +2734,8 @@
 %0A%7D%0A%0A
-func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 //sy
@@ -6307,32 +6307,84 @@
 nt) (err error)%0A
+//sys%09Dup3(from int, to int, flags int) (err error)%0A
 //sys%09Exit(code 
@@ -8339,76 +8339,87 @@
 or)%0A
-//sys%09Fstatvfs1(fd int, buf *Statvfs_t) (err error) = SYS_FSTATVFS1%0A
+//sys%09Fstatvfs1(fd int, buf *Statvfs_t, flags int) (err error) = SYS_FSTATVFS1%0A
 //sy
@@ -11261,79 +11261,90 @@
 or)%0A
-//sys%09Statvfs1(path string, buf *Statvfs_t) (err error) = SYS_STATVFS1%0A
+//sys%09Statvfs1(path string, buf *Statvfs_t, flags int) (err error) = SYS_STATVFS1%0A
 //sy
- f 485b60f302ef2bd1883de13ca1b0c92b0c08917db24d002deea6bd58bd8bcefb vendor/golang.org/x/sys/unix/syscall_openbsd.go
+ f da774b22cc8e4440fe796b752926abaf32b504f8c55c0ee64ade242fc358a98b vendor/golang.org/x/sys/unix/syscall_openbsd.go
dmppatch 26
@@ -1584,349 +1584,8 @@
 %0A%7D%0A%0A
-func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 func
@@ -1907,47 +1907,8 @@
 %0A%7D%0A%0A
-//sysnb pipe(p *%5B2%5D_C_int) (err error)%0A
 func
@@ -1928,32 +1928,145 @@
 ) (err error) %7B%0A
+%09return Pipe2(p, 0)%0A%7D%0A%0A//sysnb%09pipe2(p *%5B2%5D_C_int, flags int) (err error)%0Afunc Pipe2(p %5B%5Dint, flags int) error %7B%0A
 %09if len(p) != 2 
@@ -2108,25 +2108,34 @@
 int%0A
-%09err = pipe(&pp)%0A
+%09err := pipe2(&pp, flags)%0A
 %09p%5B0
@@ -2168,24 +2168,28 @@
 (pp%5B1%5D)%0A
-%09return%0A
+%09return err%0A
 %7D%0A%0A//sys
@@ -5889,24 +5889,76 @@
 (err error)%0A
+//sys%09Dup3(from int, to int, flags int) (err error)%0A
 //sys%09Exit(c
- f ae6c25a4c6eff98dcb5dc16f1de64adccc561609af46841d93cea28fe2be5ede vendor/golang.org/x/sys/unix/zerrors_linux_386.go
+ f c2c1b7de3d21bea32a8513aabbca44de929569700807c493f536061574c55ed4 vendor/golang.org/x/sys/unix/zerrors_linux_386.go
dmppatch 89
@@ -12497,24 +12497,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21604,16 +21604,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21765,24 +21765,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37573,59 +37573,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37663,32 +37663,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39269,59 +39269,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64521,16 +64521,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65189,16 +65189,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83290,16 +83290,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83924,16 +83924,132 @@
 008743f%0A
+%09PPPIOCGIDLE32                               = 0x8008743f%0A%09PPPIOCGIDLE64                               = 0x8010743f%0A
 %09PPPIOCG
@@ -101837,24 +101837,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -102940,16 +102940,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104196,16 +104196,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -104928,60 +104928,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105284,24 +105284,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106072,112 +106072,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117507,60 +117507,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -122991,24 +122991,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129317,16 +129317,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134521,24 +134521,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136384,24 +136384,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f dd5042ed767d25d107dfc4a3c28fdf129ae5b2e93fbf61457c49f9e36313ab60 vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
+ f d43a2acaba2aa2a0076d51d86387815dd4fe9415509576ea88a70469d487d45e vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
dmppatch 89
@@ -12499,24 +12499,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21606,16 +21606,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21767,24 +21767,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37575,59 +37575,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37665,32 +37665,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39271,59 +39271,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64523,16 +64523,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65191,16 +65191,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83289,16 +83289,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83923,16 +83923,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x8008743f%0A%09PPPIOCGIDLE64                               = 0x8010743f%0A
 %09PPPIOCG
@@ -101896,24 +101896,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -102999,16 +102999,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104255,16 +104255,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -104987,60 +104987,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105343,24 +105343,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106131,112 +106131,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117566,60 +117566,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -123050,24 +123050,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129376,16 +129376,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134580,24 +134580,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136443,24 +136443,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f bc9b5bc230524a47fddb3a1e8cbba9d5313a8ec8e213f938aaf0b9eb60be4da2 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
+ f 8d76a56a0fca5ca0ed05a94b3567133d12964158e2b401b41b454875db10edda vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
dmppatch 89
@@ -12487,24 +12487,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21594,16 +21594,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21755,24 +21755,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37505,59 +37505,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37595,32 +37595,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39201,59 +39201,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64453,16 +64453,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65121,16 +65121,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83170,16 +83170,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83804,16 +83804,132 @@
 008743f%0A
+%09PPPIOCGIDLE32                               = 0x8008743f%0A%09PPPIOCGIDLE64                               = 0x8010743f%0A
 %09PPPIOCG
@@ -102192,24 +102192,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -103295,16 +103295,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104551,16 +104551,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -105283,60 +105283,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105639,24 +105639,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106427,112 +106427,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117862,60 +117862,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -123346,24 +123346,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129672,16 +129672,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134876,24 +134876,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136739,24 +136739,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f af75b502f65941143cce954a717b1ffbe75574fef2cb82da8f6a4dd8c37e573f vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
+ f 7bfcae82f0a2606b452bd7fa2578a20c8b0c1d1abdea2820fa6229164283a517 vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
dmppatch 89
@@ -12517,24 +12517,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21624,16 +21624,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21785,24 +21785,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37709,59 +37709,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37799,32 +37799,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39405,59 +39405,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64657,16 +64657,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65325,16 +65325,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83370,16 +83370,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -84004,16 +84004,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x8008743f%0A%09PPPIOCGIDLE64                               = 0x8010743f%0A
 %09PPPIOCG
@@ -101511,24 +101511,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -102614,16 +102614,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -103870,16 +103870,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -104602,60 +104602,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -104958,24 +104958,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -105746,112 +105746,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117181,60 +117181,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -122665,24 +122665,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129049,16 +129049,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134253,24 +134253,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136116,24 +136116,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f a2ee6e10cb81d6db78846807c11cea68dbd4acca30ec536e4215e55a695686a9 vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
+ f 870708ca33f1ae9037a9bd4794d57cabc350f030fd07bcf48677e6f1de64250b vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
dmppatch 89
@@ -12540,24 +12540,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21647,16 +21647,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21808,24 +21808,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37557,59 +37557,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37647,32 +37647,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39253,59 +39253,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64516,16 +64516,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65184,16 +65184,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83261,16 +83261,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83899,16 +83899,132 @@
 008743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -101968,24 +101968,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -103071,16 +103071,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104327,16 +104327,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -105059,60 +105059,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105415,24 +105415,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106203,112 +106203,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117651,60 +117651,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -123226,24 +123226,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129498,16 +129498,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134850,24 +134850,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136713,24 +136713,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f 4d227188101c05e347ce318b39f57d66a198e42b41a81d803ed6b99f7096f272 vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
+ f 83b9c60b4cc778001b80f71c7fd4eff757344624e72b3ddbb4fc90c0cae076cc vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
dmppatch 89
@@ -12542,24 +12542,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21649,16 +21649,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21810,24 +21810,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37559,59 +37559,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37649,32 +37649,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39255,59 +39255,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64512,16 +64512,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65180,16 +65180,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83254,16 +83254,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83892,16 +83892,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -101969,24 +101969,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -103072,16 +103072,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104328,16 +104328,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -105060,60 +105060,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105416,24 +105416,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106204,112 +106204,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117652,60 +117652,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -123227,24 +123227,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129499,16 +129499,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134851,24 +134851,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136714,24 +136714,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f 3cd190237dacf26e5540bdf636f563f7d83f161b79d5719f0e46a0b3769d6ccf vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
+ f b119574b31707917919e464dc01211a137235f47d09cbf80c9e68c2a73849cbf vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
dmppatch 89
@@ -12544,24 +12544,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21651,16 +21651,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21812,24 +21812,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37561,59 +37561,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37651,32 +37651,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39257,59 +39257,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64514,16 +64514,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65182,16 +65182,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83256,16 +83256,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83894,16 +83894,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -101971,24 +101971,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -103074,16 +103074,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104330,16 +104330,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -105062,60 +105062,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105418,24 +105418,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106206,112 +106206,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117654,60 +117654,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -123229,24 +123229,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129501,16 +129501,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134853,24 +134853,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136716,24 +136716,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f 7922e9e1a41253656f369655bc60a249c462cd5d6fc353d8666b0899b6795e38 vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
+ f b7320a4905c288cc9cf20737ac41f79263158cff103aaad59f1492042b1f4251 vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
dmppatch 89
@@ -12542,24 +12542,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21649,16 +21649,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21810,24 +21810,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37559,59 +37559,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37649,32 +37649,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39255,59 +39255,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64518,16 +64518,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65186,16 +65186,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83263,16 +83263,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83901,16 +83901,132 @@
 008743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -101970,24 +101970,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -103073,16 +103073,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -104329,16 +104329,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -105061,60 +105061,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -105417,24 +105417,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -106205,112 +106205,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -117653,60 +117653,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -123228,24 +123228,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -129500,16 +129500,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -134852,24 +134852,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -136715,24 +136715,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f b9283eb5f8d89d35f28b667142eded8187db661cf0842b55ddf3f09497787bd1 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
+ f dffcee0fd224871036f706d307c03f879bab2c4e87661755188d54a942d43e25 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
dmppatch 93
@@ -12509,24 +12509,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21610,16 +21610,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21771,24 +21771,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37530,59 +37530,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37620,32 +37620,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39226,59 +39226,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64486,16 +64486,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65154,16 +65154,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -66512,24 +66512,79 @@
   = 0x20000%0A
+%09MAP_SYNC                                    = 0x80000%0A
 %09MAP_TYPE   
@@ -83358,16 +83358,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83996,16 +83996,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -105022,24 +105022,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -106125,16 +106125,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -107381,16 +107381,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -108113,60 +108113,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -108469,24 +108469,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -109257,112 +109257,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -120700,60 +120700,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -126184,24 +126184,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -132407,16 +132407,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -138019,24 +138019,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -139882,24 +139882,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f bdc54cf60b690253020547f997b2f8588a025a508075c991f67c81c28dd4b127 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
+ f dd61342d892103df6de8c84833ec218f9182dd8210475767276c89142a252ea1 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
dmppatch 93
@@ -12511,24 +12511,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21612,16 +21612,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21773,24 +21773,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37532,59 +37532,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37622,32 +37622,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39228,59 +39228,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64488,16 +64488,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65156,16 +65156,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -66514,24 +66514,79 @@
   = 0x20000%0A
+%09MAP_SYNC                                    = 0x80000%0A
 %09MAP_TYPE   
@@ -83360,16 +83360,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83998,16 +83998,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -105024,24 +105024,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -106127,16 +106127,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -107383,16 +107383,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -108115,60 +108115,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -108471,24 +108471,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -109259,112 +109259,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -120702,60 +120702,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -126186,24 +126186,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -132409,16 +132409,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -138021,24 +138021,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -139884,24 +139884,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f c63b820cc5526bf7d3a73cf56b56bb046484c6b0fa9ba3b824c52b9bae3e85f3 vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
+ f b5a748bba5bd8ab5f90de29588075634fd8227b523bc64c18241337558ad6678 vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
dmppatch 89
@@ -12491,24 +12491,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21598,16 +21598,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21759,24 +21759,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37509,59 +37509,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37599,32 +37599,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39205,59 +39205,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64457,16 +64457,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65125,16 +65125,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83171,16 +83171,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83805,16 +83805,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x8008743f%0A%09PPPIOCGIDLE64                               = 0x8010743f%0A
 %09PPPIOCG
@@ -101208,24 +101208,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -102311,16 +102311,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -103567,16 +103567,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -104299,60 +104299,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -104655,24 +104655,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -105443,112 +105443,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -116878,60 +116878,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -122362,24 +122362,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -128688,16 +128688,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -133892,24 +133892,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -135755,24 +135755,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f 7dc96d155cae01ccbdda258c732083983682a18b3d92525e3120c1ce5468bf2b vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
+ f ac94d780966a485996061bb6104d1a43540b971de3819f504bfdef29c88cac1b vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
dmppatch 89
@@ -12517,24 +12517,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21624,16 +21624,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21785,24 +21785,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37535,59 +37535,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37625,32 +37625,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39231,59 +39231,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64483,16 +64483,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65151,16 +65151,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -83197,16 +83197,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -83831,16 +83831,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x8008743f%0A%09PPPIOCGIDLE64                               = 0x8010743f%0A
 %09PPPIOCG
@@ -105069,24 +105069,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -106172,16 +106172,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -107428,16 +107428,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -108160,60 +108160,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -108516,24 +108516,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -109304,112 +109304,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -120739,60 +120739,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -126223,24 +126223,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -132549,16 +132549,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -137753,24 +137753,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -139616,24 +139616,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f 505a3bbc6b0f43896ad55a2698b3db8d14e6bbb07511595512e11878ba6529a2 vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
+ f f8cc12299dae5fa9c622c1a061b3f580a8028caeec47e7d3a9ffc3d98979e8ed vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
dmppatch 93
@@ -12699,24 +12699,77 @@
      = 0x20%0A
+%09BPF_F_MMAPABLE                              = 0x400%0A
 %09BPF_F_NO_CO
@@ -21806,16 +21806,68 @@
  = 0x40%0A
+%09CLONE_ARGS_SIZE_VER1                        = 0x50%0A
 %09CLONE_C
@@ -21967,24 +21967,83 @@
 = 0x1000000%0A
+%09CLONE_CLEAR_SIGHAND                         = 0x100000000%0A
 %09CLONE_DETAC
@@ -37771,59 +37771,59 @@
 0x3%0A
-%09FSCRYPT_POLICY_FLAGS_VALID                  = 0x7%0A
+%09FSCRYPT_POLICY_FLAGS_VALID                  = 0xf%0A
 %09FSC
@@ -37861,32 +37861,83 @@
           = 0x4%0A
+%09FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64          = 0x8%0A
 %09FSCRYPT_POLICY_
@@ -39467,59 +39467,59 @@
 0x3%0A
-%09FS_POLICY_FLAGS_VALID                       = 0x7%0A
+%09FS_POLICY_FLAGS_VALID                       = 0xf%0A
 %09FUT
@@ -64726,16 +64726,68 @@
  = 0x40%0A
+%09MADV_COLD                                   = 0x14%0A
 %09MADV_DO
@@ -65394,16 +65394,68 @@
   = 0x0%0A
+%09MADV_PAGEOUT                                = 0x15%0A
 %09MADV_RA
@@ -66805,24 +66805,79 @@
   = 0x20000%0A
+%09MAP_SYNC                                    = 0x80000%0A
 %09MAP_TYPE   
@@ -83541,16 +83541,74 @@
 0495045%0A
+%09PPC_CMM_MAGIC                               = 0xc7571590%0A
 %09PPPIOCA
@@ -84179,16 +84179,132 @@
 010743f%0A
+%09PPPIOCGIDLE32                               = 0x4008743f%0A%09PPPIOCGIDLE64                               = 0x4010743f%0A
 %09PPPIOCG
@@ -104803,24 +104803,811 @@
     = 0x800%0A
+%09RTMGRP_DECnet_IFADDR                        = 0x1000%0A%09RTMGRP_DECnet_ROUTE                         = 0x4000%0A%09RTMGRP_IPV4_IFADDR                          = 0x10%0A%09RTMGRP_IPV4_MROUTE                          = 0x20%0A%09RTMGRP_IPV4_ROUTE                           = 0x40%0A%09RTMGRP_IPV4_RULE                            = 0x80%0A%09RTMGRP_IPV6_IFADDR                          = 0x100%0A%09RTMGRP_IPV6_IFINFO                          = 0x800%0A%09RTMGRP_IPV6_MROUTE                          = 0x200%0A%09RTMGRP_IPV6_PREFIX                          = 0x20000%0A%09RTMGRP_IPV6_ROUTE                           = 0x400%0A%09RTMGRP_LINK                                 = 0x1%0A%09RTMGRP_NEIGH                                = 0x4%0A%09RTMGRP_NOTIFY                               = 0x2%0A%09RTMGRP_TC                                   = 0x8%0A
 %09RTM_BASE   
@@ -105906,16 +105906,68 @@
  = 0x11%0A
+%09RTM_DELLINKPROP                             = 0x6d%0A
 %09RTM_DEL
@@ -107162,16 +107162,68 @@
  = 0x12%0A
+%09RTM_GETLINKPROP                             = 0x6e%0A
 %09RTM_GET
@@ -107894,60 +107894,60 @@
 x2e%0A
-%09RTM_MAX                                     = 0x6b%0A
+%09RTM_MAX                                     = 0x6f%0A
 %09RTM
@@ -108250,24 +108250,76 @@
      = 0x10%0A
+%09RTM_NEWLINKPROP                             = 0x6c%0A
 %09RTM_NEWMDB 
@@ -109038,112 +109038,112 @@
 x2c%0A
-%09RTM_NR_FAMILIES                             = 0x17%0A%09RTM_NR_MSGTYPES                             = 0x5c%0A
+%09RTM_NR_FAMILIES                             = 0x18%0A%09RTM_NR_MSGTYPES                             = 0x60%0A
 %09RTM
@@ -120488,60 +120488,62 @@
 11b%0A
-%09SOMAXCONN                                   = 0x80%0A
+%09SOMAXCONN                                   = 0x1000%0A
 %09SO_
@@ -126018,24 +126018,80 @@
      = 0x40%0A
+%09STATX_ATTR_VERITY                           = 0x100000%0A
 %09STATX_BASIC
@@ -132302,16 +132302,68 @@
  = 0x18%0A
+%09TCP_TX_DELAY                                = 0x25%0A
 %09TCP_ULP
@@ -137553,24 +137553,232 @@
       = 0x1%0A
+%09TIPC_AEAD_ALG_NAME                          = 0x20%0A%09TIPC_AEAD_KEYLEN_MAX                        = 0x24%0A%09TIPC_AEAD_KEYLEN_MIN                        = 0x14%0A%09TIPC_AEAD_KEY_SIZE_MAX                      = 0x48%0A
 %09TIPC_CFG_SR
@@ -139416,24 +139416,76 @@
      = 0x10%0A
+%09TIPC_NODELAY                                = 0x8a%0A
 %09TIPC_NODE_B
- f a632da2baac9a14c0d99bb5afd37ac9d369ec939f0da51872f02aa87d7ad73f9 vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
+ f daeccb27df238e57b9a00b15fcd4cdc0783e0b2f446beeb5d3fba821a497106d vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
dmppatch 20
@@ -11249,105 +11249,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11529,105 +11529,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -51983,102 +51983,129 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -52219,102 +52219,129 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 016c9ea07508aefbe70070b5a6d49c259d091b654efc0a6cbe301aa30d8eab7d vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
+ f ee254cb8b95f2099a0e2fae635bc16925991f30b810898d7a8d81e148878e89d vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
dmppatch 20
@@ -11234,105 +11234,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11514,105 +11514,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -52179,100 +52179,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -52413,100 +52413,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 73ba1d7d77adb3532246805e155161813dca5d6e055afedb79cd105142f0918a vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
+ f 0099da86198f46087277d879a6d66a9060146201673d684e031772b9ace38a75 vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
dmppatch 20
@@ -11254,105 +11254,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11534,105 +11534,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -56032,102 +56032,129 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -56268,102 +56268,129 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 3eb9e796a57f758185640f56807843486bbf97c55e07d013e9cc6913cfda5887 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
+ f e87a39d87bedadc48400b2db49ad7b45c524ecfd2c8751be0de8d7dd239e0590 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
dmppatch 20
@@ -11234,105 +11234,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11514,105 +11514,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -50508,100 +50508,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -50742,100 +50742,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 38a3b3b4f915c69fa431e0fc81528dd39202cc3adb8e01707b9515bb0f1c5e47 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
+ f 683ac911a401eb9a4ddc682dcb221f5f33d34ea2c04f6effb46f92c6a2c75dbd vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
dmppatch 20
@@ -11258,105 +11258,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11538,105 +11538,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -50472,100 +50472,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -50706,100 +50706,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 289e1446788dee25e11e2b852a8c341c20a4fb3898c497414c429ccb1401a9c1 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
+ f 02401f152abc26bc55b41595a55d233b207b31301744cb5540f4ef3dbec7d2c1 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
dmppatch 20
@@ -11238,105 +11238,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11518,105 +11518,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -50866,100 +50866,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -51100,100 +51100,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f a67e76c01a38d6ecfb761f80a519641414be835f902654f646e9a77894f87b5d vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
+ f 96128e49be4ea7e1d20224d9449567f1cbc4f3e97a805314cbc33eb346a7db32 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
dmppatch 20
@@ -11242,105 +11242,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11522,105 +11522,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -50870,100 +50870,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -51104,100 +51104,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 30d9dcf5d02235eb3558f7c95c0f3b57a5a08a70b51fe5ec8abd794297b404bc vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
+ f b002a9dbcbfb8ecfb9103049d6f78b96d7af5a1b9e2cf6fd6899b92c1d69734b vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
dmppatch 20
@@ -11262,105 +11262,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11542,105 +11542,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -50476,100 +50476,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -50710,100 +50710,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 239307276f805e27d2f186b241fd3d62970d911902171203d0a7ca1d9280625d vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
+ f 41feded12bf5b4d5cfea436224278323c57546429b0e931559241316c1c646a7 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
dmppatch 20
@@ -11235,105 +11235,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11515,105 +11515,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -52916,100 +52916,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -53150,100 +53150,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 027ac04b7b26793c9896756161431e3294bacfbfa0f3711b10ac8a58d914e1d9 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
+ f 288c37040ff59307c3aaea39a92e6371190711a499203a96955fd403b4886762 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
dmppatch 20
@@ -11239,105 +11239,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11519,105 +11519,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -52920,100 +52920,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -53154,100 +53154,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f f40513dc6947d9ed52251115e45d98ed770e02536aa11533ab34d6b46a871b8e vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
+ f 42d86be33a195fd5b5861b5a97e7d9c72f65e2d5978b3801bd210ea09c874b1f vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
dmppatch 20
@@ -11240,105 +11240,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11520,105 +11520,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -50005,100 +50005,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -50239,100 +50239,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f c880ac2c855694d5c1cd6006ec23314bf88ccd32e15a30233e5bdefb1c321c52 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
+ f fac716bf06cabccea8fb9fa32885b3da3d6459904c5e2e54a7a82288af692aa4 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
dmppatch 20
@@ -11234,105 +11234,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11514,105 +11514,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -52249,100 +52249,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -52483,100 +52483,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f 20f81a9134c01cfed76b800274d6fc7be97dace75a75fb7cc6ea68ecbde603cc vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
+ f 424fb871d13ad03c032ecfa8db692307acd6932e7174b8d9c6c260348d665488 vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
dmppatch 20
@@ -11240,105 +11240,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -11520,105 +11520,108 @@
 ) %7B%0A
-%09_, _, e1 := Syscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
+%09_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)%0A
 %09if 
@@ -52227,100 +52227,127 @@
 IT%0A%0A
-func Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A
+func setfsgid(gid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
@@ -52461,100 +52461,127 @@
 IT%0A%0A
-func Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A
+func setfsuid(uid int) (prev int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09prev = int(r0)%0A
 %09if 
- f f5885b6f6d9623fe4150c8928bc0475d44f9b86d44151476ac7bec4b6789fd80 vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
+ f d450e32217e9b0bda189d50bc70727f9f751d208e22b7d2e4ff5c68c2b65fb18 vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
dmppatch 12
@@ -9159,516 +9159,8 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -10266,16 +10266,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -13617,24 +13617,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 4c07550fb20f798e8d8855619ac02675e5ed6979262950111299c4565d4ac9e6 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
+ f a2438e5186211dbe9f1b1f31069a9cc34f8868042549c3eb546c0a89e2cadf64 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
dmppatch 12
@@ -9160,516 +9160,8 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -10267,16 +10267,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -13618,24 +13618,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 465b8fc6db540713e28925005cb3e8b579d5625b1cf4289d65307d48436045ff vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
+ f 79efef2cfae2cdcf27d684c3c1735e7e55b98174fa32625506fdba4e7e718744 vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
dmppatch 12
@@ -9164,516 +9164,8 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -10271,16 +10271,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -13622,24 +13622,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f a7f2c5c7780f409ca9b053c83415367a4474b969a60b4e04e3410521490e656d vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go
+ f 106801910bda1bebada81cd8d7cc238677e075582d0a602d344dbae846810193 vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go
dmppatch 12
@@ -9160,516 +9160,8 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -10267,16 +10267,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -13618,24 +13618,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f cb83331d8543958b6a4d5ede92a255c3e67d1b7c7bf3a7ddd6ea51d24decf688 vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
+ f e5dc95300ffc17ff740685f705cc6aecc6976c405302752a7bb580936e7ec32f vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
dmppatch 13
@@ -9164,622 +9164,140 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A
+func pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A
 %09if 
@@ -10284,16 +10284,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -14009,24 +14009,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 3cf8e16cab6ef09ab38cc249a2f408683497da941f39d990de26be104bab8570 vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
+ f 0f0adeda090d405ac1e24cf953ec72bd3397cb9f7bc48623e9e63cf72c01b61a vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
dmppatch 13
@@ -9165,622 +9165,140 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A
+func pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A
 %09if 
@@ -10285,16 +10285,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -14010,24 +14010,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 500318963dd59300f120feffced08059aacb855b980e298eb4a7f6c92a9b27c3 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
+ f 3f6079e4ea3c96073e388e23c326d45d215e988c122837c254668d1e51c5d0fc vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
dmppatch 13
@@ -9169,622 +9169,140 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A
+func pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A
 %09if 
@@ -10289,16 +10289,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -14014,24 +14014,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 9acc97c3d6cfd1c404b7f00732a23742b8c7924612dbcbaf3d0db885d40a61b1 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm64.go
+ f 045c1e97da08190638a56e3df9f8030eb5e397065bb1db6e0e9055724f71691f vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm64.go
dmppatch 13
@@ -9165,622 +9165,140 @@
 IT%0A%0A
-func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A
+func pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A
 %09if 
@@ -10285,16 +10285,524 @@
 r(arg))%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if e1 !
@@ -14010,24 +14010,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f eab67ad589cd703106df0dfa774ca9d6fe277b067ab28cdb71644c3095a81416 vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go
+ f 20fa872caf90f540f23f4c4335e7ca86554d4bce74781a1a872036a2eab51172 vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go
dmppatch 4
@@ -9996,10 +9996,44 @@
   = 434%0A
+%09SYS_CLONE3                 = 435%0A
 )%0A
- f 9bbdd44eb528906e6dc3cb8910800818f7c183fe3dcdd291d4a4f08fb0b8722e vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
+ f b6ef64fb4cfbc468441118d9917a06f4c392d9c5f471d982102ade838a7c9a9b vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
dmppatch 3
@@ -6981,16 +6981,148 @@
 ine  %5B32%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz      int32%0A%09Tick    int32%0A%09Tickadj int32%0A%09Stathz  int32%0A%09Profhz  int32%0A%7D%0A
- f aa4933a20387bac9b0c6c3c9fb576e95f2732d3610cfec825e0bafbf96f9b9ae vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
+ f 414be8ebcb34a82b0bd15c134f8673d04129a481cc8e420a813f395d7c0d6ead vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
dmppatch 8
@@ -6624,19 +6624,21 @@
 yte%0A
-%09Len  uint%0A
+%09Len  uint32%0A
 %7D%0A%0At
@@ -10816,16 +10816,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f f48937a5ee8b68bce8071cfac6491ea44f792d52d8e77ee9677430af48bee521 vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
+ f 1c7319b11ee1bf947e0584234e60982849373e564895732e04973005e6f9d5e1 vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
dmppatch 8
@@ -6680,19 +6680,21 @@
 yte%0A
-%09Len  uint%0A
+%09Len  uint64%0A
 %7D%0A%0At
@@ -10889,16 +10889,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f 6a0f2421552e3f9d2b73e9e135a36a9278ebd63d548a738e5fe93f6ddee71ebd vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
+ f 22ed24b82f9439fb2dca94c0e729583c5b952f69ea49cea4dce0981a13331de8 vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
dmppatch 8
@@ -6374,19 +6374,21 @@
 yte%0A
-%09Len  uint%0A
+%09Len  uint32%0A
 %7D%0A%0At
@@ -10587,16 +10587,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f 24ee41a86c7381b8b592b6366451abff2514158c474e66b327a86100701df96e vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go
+ f a2552605db374dfbf7faf248e78d11d3a319cf6dd2e764cc5d9ef8a05cf773fd vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go
dmppatch 8
@@ -6367,19 +6367,21 @@
 yte%0A
-%09Len  uint%0A
+%09Len  uint64%0A
 %7D%0A%0At
@@ -10576,16 +10576,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f afd2d68d986be9f6e0d4cb3d893a8fbcbc35d767d227f82a9485193b25ffd0f3 vendor/golang.org/x/sys/unix/ztypes_linux_386.go
+ f a8f2f8a9b56dce740f6f1c0b1293ee13f5f54360b19dece078c266f2d17db65e vendor/golang.org/x/sys/unix/ztypes_linux_386.go
dmppatch 10
@@ -11413,40 +11413,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73897,58 +73897,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 70dbd35b18270aacabc61a099572b44731c7cbe87470b92d3b8e885cb73b93ef vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
+ f 32f0f7a642b659a68a4d82960e40b72c86e2845c4f46ab201988af9d9b896952 vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
dmppatch 10
@@ -11438,40 +11438,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -74153,58 +74153,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 6adcf15a9dbb2c763d51faf6625d2d9b739a106c3ab9b22699733b1d61c9702b vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
+ f eeb60706c5717bb18999282467e8027e23eb6aed9780154933b07bc721b36bcf vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
dmppatch 10
@@ -11477,40 +11477,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73806,58 +73806,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f bd727accecc895f5996580b29f221cf2f01524b81e491ea6c4266a960beebbc8 vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
+ f f50794e9c58b32f258553a7be0239dc77c6fa832ffeb42163173afea8ba176f3 vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
dmppatch 10
@@ -11463,40 +11463,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73797,58 +73797,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f f26ab4f33853d12f235cae9d7a106d8ac6012449417f364998c228c3d7b68bbb vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
+ f 438d139ebcbbeccb3e5aa76985d7ab3ede53f2607185e7989ad32f27d05b5c33 vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
dmppatch 10
@@ -11463,40 +11463,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73885,58 +73885,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 632e326b2e8eabbd4096234f14fbe9d9e7e09308b6eb11f179e3f21d5e9049c4 vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
+ f 9a11b9e3bf1c0cf72d12bc7eae9a8d219b74f9f0ecb227da3157a95300a54393 vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
dmppatch 10
@@ -11456,40 +11456,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73853,58 +73853,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 1211de69100f4e76cdf89030671699c66cfa325fd4b8a701ddf1a51521cadbd9 vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
+ f 9c396cdcc9ad33a81abf8be499f40cb5186865dceeddbaba8bfebd612904289b vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
dmppatch 10
@@ -11458,40 +11458,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73855,58 +73855,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 143c667e524f8662a7436401a310757118f946e6c2d22195054fdf43d4906157 vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
+ f 1a182f76935d7d847c898d54ec2a6e007c8bbfbe0266637c21db26becc3a8a58 vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
dmppatch 10
@@ -11465,40 +11465,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73887,58 +73887,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 8aff06fb1c5b9f3cf0687d4b5de455a22068932c3ea106c6d51b0e644c145f17 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
+ f c1e7cc90e0b64678c44315dac38b868767b27440bbad59710023d14fae05d9b2 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
dmppatch 10
@@ -11466,40 +11466,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -74011,58 +74011,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f e39bff64897acf9eb471529f8c2fe5113d2d5db9f40fdc1a2a727f7d32306227 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
+ f aed37ae14f1f40a194b5bf822b87195df390354830bdbdee35bf777831a96bba vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
dmppatch 10
@@ -11468,40 +11468,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -74013,58 +74013,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f cb4bc6965774aea901568fed0d96fa3cfdcbbc31702888afb1b8c4ab5628917e vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go
+ f 349d0fecba5a3dc283430e865aa15cfa0fbf7f5024939db250a74a632556436e vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go
dmppatch 10
@@ -11454,40 +11454,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -74141,58 +74141,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f 13bda1c3c64a125db03d8620393a75d2f636cc2e7a76be6899f2a3718b32669d vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
+ f d590738f2e40a7e6906f2aa9ecfc4844e97d9b9d7af63a09b137e59aa8ccc801 vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
dmppatch 10
@@ -11447,40 +11447,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -74313,58 +74313,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f a84b64613efd353c3e9e16220a6e43a2723fb0c7b8e4d5fa9d5d1db1b4341f8d vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go
+ f 9569561ed4b1a6bfa6d02cfa6e3e46ed8f3f13401aca1169f7264542392c535f vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go
dmppatch 10
@@ -11494,40 +11494,40 @@
 x33%0A
-%09IFLA_MAX                = 0x33%0A
+%09IFLA_MAX                = 0x35%0A
 %09IFL
@@ -73861,58 +73861,58 @@
 x3e%0A
-%09DEVLINK_ATTR_MAX                          = 0x89%0A
+%09DEVLINK_ATTR_MAX                          = 0x8c%0A
 %09DEV
- f bb14314f4b5eb782985f887d298103e9d9b10ac9b84acc1bab77378bf0e6ec73 vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
+ f 89cbf006bc203700f58d857637794f5e234897bea1b57ed5fcd273985563248d vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
dmppatch 8
@@ -3031,24 +3031,135 @@
 e  int32%0A%7D%0A%0A
+type Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0A
 type Inet6Pk
@@ -3660,16 +3660,46 @@
   = 0xc%0A
+%09SizeofInet4Pktinfo     = 0xc%0A
 %09SizeofI
- f 170a4f52546abf516b149c62c6169c9e981857a42077a25e2954bb6883602d8e vendor/golang.org/x/sys/windows/types_windows.go
+ f bff74f7724a7485d92a01b57c72d843398e76ba8151813a8a3f82a50605f04d0 vendor/golang.org/x/sys/windows/types_windows.go
dmppatch 18
@@ -21440,16 +21440,33 @@
     = 2%0A
+%09AF_NETBIOS = 17%0A
 %09AF_INET
@@ -21474,33 +21474,50 @@
    = 23%0A
-%09AF_NETBIOS = 17%0A
+%09AF_IRDA    = 26%0A%09AF_BTH     = 32%0A
 %0A%09SOCK_S
@@ -21569,16 +21569,36 @@
     = 3%0A
+%09SOCK_RDM       = 4%0A
 %09SOCK_SE
@@ -21614,102 +21614,202 @@
  5%0A%0A
-%09IPPROTO_IP   = 0%0A%09IPPROTO_ICMP = 1%0A%09IPPROTO_IPV6 = 0x29%0A%09IPPROTO_TCP  = 6%0A%09IPPROTO_UDP  = 17%0A
+%09IPPROTO_IP      = 0%0A%09IPPROTO_ICMP    = 1%0A%09IPPROTO_IGMP    = 2%0A%09BTHPROTO_RFCOMM = 3%0A%09IPPROTO_TCP     = 6%0A%09IPPROTO_UDP     = 17%0A%09IPPROTO_IPV6    = 41%0A%09IPPROTO_ICMPV6  = 58%0A%09IPPROTO_RM      = 113%0A
 %0A%09SO
- f 0f34ad08d8fcc5d37c3773b154d3ff131d50ece3d25ade8eac4d8bf243379761 vendor/modules.txt
+ f 174432ce61dc893ca831c78dbd7e167bf112ca626d1b19eccc49c403575b73ae vendor/modules.txt
dmppatch 40
@@ -1453,40 +1453,40 @@
 log%0A
-# github.com/fatih/color v1.7.0%0A
+# github.com/fatih/color v1.9.0%0A
 gith
@@ -1545,16 +1545,56 @@
  v1.0.1%0A
+github.com/frankbraun/codechain/archive%0A
 github.c
@@ -1773,24 +1773,100 @@
 n/patchfile%0A
+github.com/frankbraun/codechain/secpkg%0Agithub.com/frankbraun/codechain/ssot%0A
 github.com/f
@@ -2132,24 +2132,69 @@
 n/util/file%0A
+github.com/frankbraun/codechain/util/gnumake%0A
 github.com/f
@@ -2222,16 +2222,103 @@
 til/hex%0A
+github.com/frankbraun/codechain/util/home%0Agithub.com/frankbraun/codechain/util/homedir%0A
 github.c
@@ -2857,45 +2857,45 @@
 ble%0A
-# github.com/mattn/go-isatty v0.0.11%0A
+# github.com/mattn/go-isatty v0.0.12%0A
 gith
@@ -2921,65 +2921,165 @@
 tty%0A
-# golang.org/x/crypto v0.0.0-20200214034016-1d94cc7ab1c6%0A
+# golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975%0Agolang.org/x/crypto/internal/subtle%0Agolang.org/x/crypto/nacl/secretbox%0Agolang.org/x/crypto/poly1305%0A
 gola
@@ -3104,16 +3104,50 @@
 pemd160%0A
+golang.org/x/crypto/salsa20/salsa%0A
 golang.o
@@ -3175,62 +3175,83 @@
 nal%0A
-# golang.org/x/sys v0.0.0-20191224085550-c709ea063b76%0A
+# golang.org/x/sys v0.0.0-20200219091948-cb0a6d8edb6c%0Agolang.org/x/sys/cpu%0A
 gola
- f 1f7fa4752a9a7a30198a50bf8c84ded63ccbecc5da96eb3eb9bd5d03e2836cc4 vhcd.go
+ f fb25eae9f919eb928589c357e89172f8c1f4b76c48ada06fc4cd4f9b623253aa vhcd.go
dmppatch 8
@@ -464,16 +464,56 @@
 ersion%22%0A
+%09%22github.com/valhallacoin/vhcd/updater%22%0A
 )%0A%0Avar c
@@ -1356,24 +1356,150 @@
 ()%0A%09%09%7D%0A%09%7D()%0A
+%0A%09// Make sure the vhcd is up-to-date.%0A%09err = updater.UpToDate()%0A%09if err != nil %7B%0A%09%09vhcdLog.Errorf(%22%25v%22, err)%0A%09%09return err%0A%09%7D%0A
 %0A%09// Get a c
treehash 7ba641a46373fadde8c73c7e3061f95e24116c2d7e12c1097318f1189c7d1f4e
